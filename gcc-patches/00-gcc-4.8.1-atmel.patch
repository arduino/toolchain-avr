diff --git gcc/ChangeLog.AVR gcc/ChangeLog.AVR
new file mode 100644
index 0000000..ebc64d8
--- /dev/null
+++ gcc/ChangeLog.AVR
@@ -0,0 +1,105 @@
+2013-08-26  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from fsf-gcc/trunk:
+      2013-04-10  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+		  Jason Merrill  <jason@redhat.com>
+	* common.opt: Add -gdwarf.
+	* opts.c (common_handle_option): Handle it.
+	* gcc.c (ASM_DEBUG_SPEC): Don't expect "-2" for DWARF.
+
+2013-08-23  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from fsf-gcc/trunk:
+      2013-05-27  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR rtl-optimization/56833
+	* postreload.c (move2add_record_mode): New function.
+	(move2add_record_sym_value, move2add_valid_value_p): Likewise.
+	(move2add_use_add2_insn): Use move2add_record_sym_value.
+	(move2add_use_add3_insn): Likewise.
+	(reload_cse_move2add): Use move2add_valid_value_p and
+	move2add_record_mode.  Invalidate call-clobbered and REG_INC
+	affected regs by setting reg_mode to VOIDmode.
+	(move2add_note_store): Don't pretend the inside of a SUBREG is
+	the actual destination.  Invalidate single/leading registers by
+	setting reg_mode to VOIDmode.
+	Use move2add_record_sym_value, move2add_valid_value_p and
+	move2add_record_mode.
+      2013-05-28  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR rtl-optimization/57439
+	* postreload.c (move2add_use_add2_insn): Use gen_lowpart_common.
+      2013-05-30  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR rtl-optimization/57439
+	* postreload.c (move2add_valid_value_p): Check that we have
+	a zero subreg_regno_offset when accessing the register in
+	the requested mode.
+      2013-06-16  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR rtl-optimization/57425
+	PR rtl-optimization/57569
+	* alias.c (write_dependence_p): Add new parameters mem_mode,
+	canon_mem_addr and mem_canonicalized.  Change type of writep to bool.
+	Changed all callers.
+	(canon_anti_dependence): New function.
+	* cse.c (check_dependence): Use canon_anti_dependence.
+	* cselib.c (cselib_invalidate_mem): Likewise.
+	* rtl.h (canon_anti_dependence): Declare.
+      2013-06-20  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR rtl-optimization/57425
+	PR rtl-optimization/57569
+	* alias.c (write_dependence_p): Remove parameters mem_mode and
+	canon_mem_addr.  Add parameters x_mode, x_addr and x_canonicalized.
+	Changed all callers.
+	(canon_anti_dependence): Get comments and semantics in sync.
+	Add parameter mem_canonicalized.  Changed all callers.
+	* rtl.h (canon_anti_dependence): Update prototype.
+      2013-05-14  Joern Rennecke <joern.rennecke@embecosm.com>
+	* config/avr/avr.c (avr_encode_section_info): Bail out if the type
+	is error_mark_node.
+      2013-07-10  Georg-Johann Lay  <avr@gjlay.de>
+	PR target/56987
+	* config/avr/avr.opt (Waddr-space-convert): Fix typo.
+      2013-07-10  Georg-Johann Lay  <avr@gjlay.de>
+	PR target/57506
+	* config/avr/avr-mcus.def (atmega16hva, atmega16hva2, atmega16hvb)
+	(atmega16m1, atmega16u4, atmega32a, atmega32c1, atmega32hvb)
+	(atmega32m1, atmega32u4, atmega32u6, atmega64c1, atmega64m1):
+	Remove duplicate devices.
+	* config/avr/gen-avr-mmcu-texi.c (print_mcus): Fail on duplicate MCUs.
+	* config/avr/t-multilib: Regenerate.
+	* config/avr/avr-tables.opt: Regenerate.
+	* doc/avr-mmcu.texi: Regenerate.
+      2013-07-10  Georg-Johann Lay  <avr@gjlay.de>
+	PR target/57844
+	* config/avr/avr.c (avr_prologue_setup_frame): Trunk -size to mode
+	of my_fp.
+      2013-07-11  Georg-Johann Lay  <avr@gjlay.de>
+	PR target/57631
+	* config/avr/avr.c (avr_set_current_function): Sanity-check signal
+	name seen by assembler/linker rather if available.
+      2013-07-19  Georg-Johann Lay  <avr@gjlay.de>
+	PR target/57516
+	* config/avr/avr-fixed.md (round<mode>3_const): Turn expander to insn.
+	* config/avr/avr.md (adjust_len): Add `round'.
+	* config/avr/avr-protos.h (avr_out_round): New prototype.
+	(avr_out_plus): Add `out_label' argument.
+	* config/avr/avr.c (avr_out_plus_1): Add `out_label' argument.
+	(avr_out_plus): Pass down `out_label' to avr_out_plus_1.
+	Handle the case where `insn' is just a pattern.
+	(avr_out_bitop): Handle the case where `insn' is just a pattern.
+	(avr_out_round): New function.
+	(avr_adjust_insn_length): Handle ADJUST_LEN_ROUND.
+      2013-07-22  Georg-Johann Lay  <avr@gjlay.de>
+	* config/avr/avr.c (avr_out_xload): No SBIS around LPM so that
+	instruction sequence is 1 byte shorter.
+      2013-07-23  Georg-Johann Lay  <avr@gjlay.de>
+	* config/avr/avr.md: Explain asm print modifier 'r' for REG.
+      Merged from embecosm/avr-gcc-mainline:
+      2013-05-02  Joern Rennecke <joern.rennecke@embecosm.com>
+	* reload.c (find_valid_class): Allow classes that do not include
+	FIRST_PSEUDO_REGISTER - 1.
+      2013-05-26  Joern Rennecke <joern.rennecke@embecosm.com>
+	* config/avr/avr-stdint.h (INT16_TYPE): Change default to "int".
+	(UINT16_TYPE): Change default to "unsigned int".
+	* config/avr/avr.h (WCHAR_TYPE, WINT_TYPE): Define to "int".
+      2013-06-25  Joern Rennecke <joern.rennecke@embecosm.com>
+	* config/avr/avr.opt (mfract-convert-truncate): New option.
+	* config/avr/avr.c (avr_out_fract): Unless TARGET_FRACT_CONV_TRUNC
+	is set, round negative fractional integers according to n1169
+	when converting to integer types.
diff --git gcc/ChangeLog.Atmel gcc/ChangeLog.Atmel
new file mode 100644
index 0000000..3497c28
--- /dev/null
+++ gcc/ChangeLog.Atmel
@@ -0,0 +1,166 @@
+2013-01-08  Senthil Kumar Selvaraj <senthil_kumar.selvaraj@atmel.com>
+
+	* config/avr/avr.h: Modify ASM_SPEC to recognize -mrelax and propagate it
+	to the assembler
+
+2013-01-08  Vishnu K.S <vishnu.k_s@atmel.com>
+
+	* config/avr/avr-mcus.def (attiny441): New avr25 MCU.
+	* config/avr/avr-tables.opt: Regenerate.
+	* config/avr/t-multilib: Regenerate.
+	* doc/avr-mmcu.texi: Regenerate.
+
+2013-01-08  Vishnu K.S <vishnu.k_s@atmel.com>
+
+	* config/avr/avr-mcus.def (attiny841): New avr25 MCU.
+	* config/avr/avr-tables.opt: Regenerate.
+	* config/avr/t-multilib: Regenerate.
+	* doc/avr-mmcu.texi: Regenerate.
+
+2013-01-08  Pitchumani Sivanupandi <pitchumani.s@atmel.com>
+        Vishnu K.S <vishnu.k_s@atmel.com>
+		Senthil Kumar Selvaraj <senthil_kumar.selvaraj@atmel.com>
+
+    * config/avr/avr-arch.h: Add new arch avr7.
+	* config/avr/avr-deivces.c: Same.
+	* config/avr/avr-mcus.def (ata6289): move to avr4 arch.
+	 (ata6616c, attiny828): New avr25 MCU.
+	 (ata6617c, ata664251): New avr35 MCU.
+	 (ata6212c): New avr4 MCU.
+	 (ata6613c, ata6614q, atmega325pa, atmega64hve2, atmega644rfr2):
+	 New avr5 MCU.
+	 (atmega128rfr2, atmega1284rfr2): New avr51 MCU.
+	 (atmega256rfr2, atmega2564rfr2): New avr6 MCU.
+	 (ata5831): New avr7 MCU.
+	 (atxmega8e5, atxmega16e5, atxmega32c3, atxmega32d3): New avrxmega2 MCU.
+	* config/avr/t-multilib: Regenerate.
+	* config/avr/avr-tables.opt: Regenerate.
+	* doc/avr-mmcu.texi: Regenerate.
+
+2013-01-08  Vidya Praveen <vidya.praveen@atmel.com>
+	    Praveen Kumar Kaushik <Praveen_Kumar.Kaushik@atmel.com>
+	    Senthil Kumar Selvaraj <Senthil_Kumar.Selvaraj@atmel.com>
+	    Pitchumani Sivanupandi <Pitchumani.S@atmel.com>
+
+	Added AVRTINY architecture to avr target.
+	* config/avr/avr-arch.h (avr_arch): Added AVRTINY architecture.
+	(base_arch_s): member added for AVRTINY architecture.
+	* config/avr/avr.c: Added TINY_ADIW, TINY_SBIW macros as AVRTINY
+	alternate for adiw/sbiw instructions. Added AVR_TMP_REGNO and
+	AVR_ZERO_REGNO macros for tmp and zero registers. Replaced TMP_REGNO
+	and ZERO_REGNO occurrences by AVR_TMP_REGNO and AVR_ZERO_REGNO
+	respectively. LAST_CALLEE_SAVED_REG macro added for the last register
+	in callee saved register list.
+	(avr_option_override): CCP address updated for AVRTINY.
+	(avr_init_expanders): tmp and zero rtx initialized as per arch.
+	Reset avr_have_dimode if AVRTINY.
+	(sequent_regs_live): Use LAST_CALLEE_SAVED_REG instead magic number.
+	(emit_push_sfr): Use AVR_TMP_REGNO for tmp register number.
+	(avr_prologue_setup_frame): Don't minimize prologue if AVRTINY.
+	Use LAST_CALLEE_SAVED_REG to refer last callee saved register.
+	(expand_epilogue): Likewise.
+	(avr_print_operand): Print CCP address in case of AVRTINY also.
+	<TBD>bad address
+	(function_arg_regno_p): Check different register list for arguments
+	if AVRTINY.
+	(init_cumulative_args): Check for AVRTINY to update number of argument
+	registers.
+	(tiny_valid_direct_memory_access_range): New function. Return false if
+	direct memory access range is not in accepted range for AVRTINY.
+	(avr_out_movqi_r_mr_reg_disp_tiny): New function to handle register
+	indirect load (with displacement) for AVRTINY.
+	(out_movqi_r_mr): Updated instruction length for AVRTINY. Call
+	avr_out_movqi_r_mr_reg_disp_tiny for load from reg+displacement.
+	(avr_out_movhi_r_mr_reg_no_disp_tiny): New function to handle register
+	indirect load (no displacement) for AVRTINY.
+	(avr_out_movhi_r_mr_reg_disp_tiny): New function to handle register
+	indirect load (with displacement) for AVRTINY.
+	(avr_out_movhi_r_mr_pre_dec_tiny): New function to handle register
+	indirect load for pre-decrement address.
+	(out_movhi_r_mr): In case of AVRTINY, call tiny register indirect load
+	functions. Update instruction length for AVRTINY.
+	(avr_out_movsi_r_mr_reg_no_disp_tiny): New function. Likewise, for
+	SImode.
+	(avr_out_movsi_r_mr_reg_disp_tiny): New function. Likewise, for SImode.
+	(out_movsi_r_mr): Likewise, for SImode.
+	(avr_out_movsi_mr_r_reg_no_disp_tiny): New function to handle register
+	indirect store (no displacement) for AVRTINY.
+	(avr_out_movsi_mr_r_reg_disp_tiny): New function to handle register
+	indirect store (with displacement) for AVRTINY.
+	(out_movsi_mr_r): Emit out insn for IO address store. Update store
+	instruction's size for AVRTINY. For AVRTINY, call tiny SImode indirect
+	store functions.
+	(avr_out_load_psi_reg_no_disp_tiny): New function to handle register
+	indirect load (no displacement) for PSImode in AVRTINY.
+	(avr_out_load_psi_reg_disp_tiny): New function to handle register
+	indirect load (with displacement) for PSImode in AVRTINY.
+	(avr_out_load_psi): Call PSImode register indirect load functions for
+	AVRTINY. Update instruction length for AVRTINY.
+	(avr_out_store_psi_reg_no_disp_tiny): New function to handle register
+	indirect store (no displacement) for PSImode in AVRTINY.
+	(avr_out_store_psi_reg_disp_tiny): New function to handle register
+	indirect store (with displacement) for PSImode in AVRTINY.
+	(avr_out_store_psi): Update instruction length for AVRTINY. Call tiny
+	register indirect store functions for AVRTINY.
+	(avr_out_movqi_mr_r_reg_disp_tiny): New function to handle QImode
+	register indirect store (with displacement) for AVRTINY.
+	(out_movqi_mr_r): Update instruction length for AVRTINY. Call tiny
+	register indirect store function for QImode in AVRTINY.
+	(avr_out_movhi_mr_r_xmega): Update instruction length for AVRTINY.
+	(avr_out_movhi_mr_r_reg_no_disp_tiny): New function to handle register
+	indirect store (no displacement) for HImode in AVRTINY.
+	(avr_out_movhi_mr_r_reg_disp_tiny): New function to handle register
+	indirect store (with displacement) for HImode in AVRTINY.
+	(avr_out_movhi_mr_r_post_inc_tiny): New function to handle register
+    indirect store for post-increment address in HImode.
+	(out_movhi_mr_r): Update instruction length for AVRTINY. Call tiny
+	register indirect store function for HImode in AVRTINY.
+	(avr_out_compare): Use TINY_SBIW/ TINY_ADIW in place of sbiw/adiw
+	in case of AVRTINY.
+	(order_regs_for_local_alloc): Updated register allocation order for
+	AVRTINY.
+	(avr_conditional_register_usage): New function. It is a target hook
+	(TARGET_CONDITIONAL_REGISTER_USAGE) function which updates fixed, call
+	used registers list and register allocation order for AVRTINY.
+	(avr_return_in_memory): Update return value size for AVRTINY.
+	* config/avr/avr-c.c (avr_cpu_cpp_builtins): Added builtin macros
+	for AVRTINY arch and tiny program memory base address.
+	* config/avr/avr-devices.c (avr_arch_types): Added AVRTINY arch.
+	(avr_texinfo): Added description for AVRTINY arch.
+	* config/avr/avr.h: Added macro to identify AVRTINY arch. Updated
+	STATIC_CHAIN_REGNUM for AVRTINY.
+	* config/avr/avr-mcus.def: Added AVRTINY arch devices.
+	* config/avr/avr.md: Added constants for tmp/ zero registers in
+	AVRTINY. Attributes for AVRTINY added.
+	(mov<mode>): Move src/ dest address to register if it is not in AVRTINY
+	memory access range.
+	(mov<mode>_insn): Avoid QImode direct load for AVRTINY if address not
+	in AVRTINY memory access range.
+	(*mov<mode>): Likewise for HImode and SImode.
+	(*movsf): Likewise for SFmode.
+	(delay_cycles_2): Updated instructions to be emitted as AVRTINY does
+	not have sbiw.
+    * config/avr/avr-protos.h: Added function prototype for
+	tiny_valid_direct_memory_access_range.
+    * config/avr/avr-tables.opt: Regenerate.
+    * gcc/config/avr/t-multilib: Regenerate.
+    * doc/avr-mmcu.texi: Regenerate.
+
+2013-01-08  Eric B. Weddington  <eric.weddington@atmel.com>
+
+	* config/avr/avr.c (avr_nmi_function_p): New function to handle
+	nmi function attribute.
+	(avr_set_current_function): Set nmi attribute after checking. Added
+	nmi attribute check also in the places of interrupt and signal
+	attribute check.
+	(avr_attribute_table): Added nmi attribute entry
+	* config/avr/avr.h (machine_function): Added attribute member
+	for nmi.
+
+2013-09-12  Pitchumani Sivanupandi <pitchumani.s@atmel.com>
+
+    * config/avr/avr-mcus.def: Remove unsupported devices
+    * config/avr/avr-tables.opt: Regenerate
+    * config/avr/t-multilib: Regenerate
+    * doc/avr-mmcu.texi: Regenerate
+
diff --git gcc/alias.c gcc/alias.c
index 970bdb0..6be87c6 100644
--- gcc/alias.c
+++ gcc/alias.c
@@ -156,7 +156,9 @@ static int insert_subset_children (splay_tree_node, void*);
 static alias_set_entry get_alias_set_entry (alias_set_type);
 static bool nonoverlapping_component_refs_p (const_rtx, const_rtx);
 static tree decl_for_component_ref (tree);
-static int write_dependence_p (const_rtx, const_rtx, int);
+static int write_dependence_p (const_rtx,
+			       const_rtx, enum machine_mode, rtx,
+			       bool, bool, bool);
 
 static void memory_modified_1 (rtx, const_rtx, void *);
 
@@ -2558,15 +2560,24 @@ canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,
 }
 
 /* Returns nonzero if a write to X might alias a previous read from
-   (or, if WRITEP is nonzero, a write to) MEM.  */
+   (or, if WRITEP is true, a write to) MEM.
+   If X_CANONCALIZED is true, then X_ADDR is the canonicalized address of X,
+   and X_MODE the mode for that access.
+   If MEM_CANONICALIZED is true, MEM is canonicalized.  */
 
 static int
-write_dependence_p (const_rtx mem, const_rtx x, int writep)
+write_dependence_p (const_rtx mem,
+		    const_rtx x, enum machine_mode x_mode, rtx x_addr,
+		    bool mem_canonicalized, bool x_canonicalized, bool writep)
 {
-  rtx x_addr, mem_addr;
+  rtx mem_addr;
   rtx base;
   int ret;
 
+  gcc_checking_assert (x_canonicalized
+		       ? (x_addr != NULL_RTX && x_mode != VOIDmode)
+		       : (x_addr == NULL_RTX && x_mode == VOIDmode));
+
   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))
     return 1;
 
@@ -2590,17 +2601,21 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)
   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
     return 1;
 
-  x_addr = XEXP (x, 0);
   mem_addr = XEXP (mem, 0);
-  if (!((GET_CODE (x_addr) == VALUE
-	 && GET_CODE (mem_addr) != VALUE
-	 && reg_mentioned_p (x_addr, mem_addr))
-	|| (GET_CODE (x_addr) != VALUE
-	    && GET_CODE (mem_addr) == VALUE
-	    && reg_mentioned_p (mem_addr, x_addr))))
+  if (!x_addr)
     {
-      x_addr = get_addr (x_addr);
-      mem_addr = get_addr (mem_addr);
+      x_addr = XEXP (x, 0);
+      if (!((GET_CODE (x_addr) == VALUE
+	     && GET_CODE (mem_addr) != VALUE
+	     && reg_mentioned_p (x_addr, mem_addr))
+	    || (GET_CODE (x_addr) != VALUE
+		&& GET_CODE (mem_addr) == VALUE
+		&& reg_mentioned_p (mem_addr, x_addr))))
+	{
+	  x_addr = get_addr (x_addr);
+	  if (!mem_canonicalized)
+	    mem_addr = get_addr (mem_addr);
+	}
     }
 
   if (! writep)
@@ -2616,11 +2631,16 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)
 			  GET_MODE (mem)))
     return 0;
 
-  x_addr = canon_rtx (x_addr);
-  mem_addr = canon_rtx (mem_addr);
+  if (!x_canonicalized)
+    {
+      x_addr = canon_rtx (x_addr);
+      x_mode = GET_MODE (x);
+    }
+  if (!mem_canonicalized)
+    mem_addr = canon_rtx (mem_addr);
 
   if ((ret = memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,
-				 SIZE_FOR_MODE (x), x_addr, 0)) != -1)
+				 GET_MODE_SIZE (x_mode), x_addr, 0)) != -1)
     return ret;
 
   if (nonoverlapping_memrefs_p (x, mem, false))
@@ -2634,7 +2654,23 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)
 int
 anti_dependence (const_rtx mem, const_rtx x)
 {
-  return write_dependence_p (mem, x, /*writep=*/0);
+  return write_dependence_p (mem, x, VOIDmode, NULL_RTX,
+			     /*mem_canonicalized=*/false,
+			     /*x_canonicalized*/false, /*writep=*/false);
+}
+
+/* Likewise, but we already have a canonicalized MEM, and X_ADDR for X.
+   Also, consider X in X_MODE (which might be from an enclosing
+   STRICT_LOW_PART / ZERO_EXTRACT).
+   If MEM_CANONICALIZED is true, MEM is canonicalized.  */
+
+int
+canon_anti_dependence (const_rtx mem, bool mem_canonicalized,
+		       const_rtx x, enum machine_mode x_mode, rtx x_addr)
+{
+  return write_dependence_p (mem, x, x_mode, x_addr,
+			     mem_canonicalized, /*x_canonicalized=*/true,
+			     /*writep=*/false);
 }
 
 /* Output dependence: X is written after store in MEM takes place.  */
@@ -2642,7 +2678,9 @@ anti_dependence (const_rtx mem, const_rtx x)
 int
 output_dependence (const_rtx mem, const_rtx x)
 {
-  return write_dependence_p (mem, x, /*writep=*/1);
+  return write_dependence_p (mem, x, VOIDmode, NULL_RTX,
+			     /*mem_canonicalized=*/false,
+			     /*x_canonicalized*/false, /*writep=*/true);
 }
 
 
diff --git gcc/c-family/ChangeLog.AVR gcc/c-family/ChangeLog.AVR
new file mode 100644
index 0000000..185fefb
--- /dev/null
+++ gcc/c-family/ChangeLog.AVR
@@ -0,0 +1,15 @@
+2013-08-26  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from embecosm/avr-gcc-mainline:
+      2013-07-17  Joern Rennecke <joern.rennecke@embecosm.com>
+	* c-common.c (same_scalar_type_ignoring_signedness): Also
+	accept short/int as equivalent if they have the same type.
+      Merged from fsf-gcc/trunk:
+      2013-04-29  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+	* c-common.c (check_user_alignment): Emit error for negative values.
+
+2013-08-23  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from fsf-gcc/trunk:
+      2013-07-04  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR c/57821
+	* c-common.c (complete_array_type): Delay folding first index
+	like other indices.  When folding, check for index overflow.
diff --git gcc/c-family/c-common.c gcc/c-family/c-common.c
index 0d91cc3..04753f8 100644
--- gcc/c-family/c-common.c
+++ gcc/c-family/c-common.c
@@ -7309,9 +7309,10 @@ check_user_alignment (const_tree align, bool allow_zero)
     }
   else if (allow_zero && integer_zerop (align))
     return -1;
-  else if ((i = tree_log2 (align)) == -1)
+  else if (tree_int_cst_sgn (align) == -1
+           || (i = tree_log2 (align)) == -1)
     {
-      error ("requested alignment is not a power of 2");
+      error ("requested alignment is not a positive power of 2");
       return -1;
     }
   else if (i >= HOST_BITS_PER_INT - BITS_PER_UNIT_LOG)
@@ -9784,6 +9785,7 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)
   tree maxindex, type, main_type, elt, unqual_elt;
   int failure = 0, quals;
   hashval_t hashcode = 0;
+  bool overflow_p = false;
 
   maxindex = size_zero_node;
   if (initial_value)
@@ -9812,8 +9814,8 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)
 	      bool fold_p = false;
 
 	      if ((*v)[0].index)
-		maxindex = fold_convert_loc (input_location, sizetype,
-					     (*v)[0].index);
+		maxindex = (*v)[0].index, fold_p = true;
+
 	      curindex = maxindex;
 
 	      for (cnt = 1; vec_safe_iterate (v, cnt, &ce); cnt++)
@@ -9824,15 +9826,26 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)
 		  else
 		    {
 		      if (fold_p)
-		        curindex = fold_convert (sizetype, curindex);
+			{
+			  /* Since we treat size types now as ordinary
+			     unsigned types, we need an explicit overflow
+			     check.  */
+			  tree orig = curindex;
+		          curindex = fold_convert (sizetype, curindex);
+			  overflow_p |= tree_int_cst_lt (curindex, orig);
+			}
 		      curindex = size_binop (PLUS_EXPR, curindex,
 					     size_one_node);
 		    }
 		  if (tree_int_cst_lt (maxindex, curindex))
 		    maxindex = curindex, fold_p = curfold_p;
 		}
-	       if (fold_p)
-	         maxindex = fold_convert (sizetype, maxindex);
+	      if (fold_p)
+		{
+		  tree orig = maxindex;
+	          maxindex = fold_convert (sizetype, maxindex);
+		  overflow_p |= tree_int_cst_lt (maxindex, orig);
+		}
 	    }
 	}
       else
@@ -9893,7 +9906,7 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)
 
   if (COMPLETE_TYPE_P (type)
       && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST
-      && TREE_OVERFLOW (TYPE_SIZE_UNIT (type)))
+      && (overflow_p || TREE_OVERFLOW (TYPE_SIZE_UNIT (type))))
     {
       error ("size of array is too large");
       /* If we proceed with the array type as it is, we'll eventually
@@ -10648,10 +10661,22 @@ same_scalar_type_ignoring_signedness (tree t1, tree t2)
 	      && (c2 == INTEGER_TYPE || c2 == REAL_TYPE
 		  || c2 == FIXED_POINT_TYPE));
 
+  t1 = c_common_signed_type (t1);
+  t2 = c_common_signed_type (t2);
   /* Equality works here because c_common_signed_type uses
      TYPE_MAIN_VARIANT.  */
-  return c_common_signed_type (t1)
-    == c_common_signed_type (t2);
+  if (t1 == t2)
+    return true;
+  if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2))
+    return false;
+  /* When short and int are the same size, we promote vectors of short
+     to vectors of int when doing arithmetic with scalars.  Hence,
+     we also have to accept mixing short / int vectors in this case.
+     Example: c-c++-common/vector-scalar.c for target avr.  */
+  if ((t1 == integer_type_node && t2 == short_integer_type_node)
+      || (t2 == integer_type_node && t1 == short_integer_type_node))
+    return true;
+  return false;
 }
 
 /* Check for missing format attributes on function pointers.  LTYPE is
diff --git gcc/c/ChangeLog.AVR gcc/c/ChangeLog.AVR
new file mode 100644
index 0000000..c07c050
--- /dev/null
+++ gcc/c/ChangeLog.AVR
@@ -0,0 +1,12 @@
+2013-08-26  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from embecosm/avr-gcc-mainline:
+      2013-05-14  Joern Rennecke <joern.rennecke@embecosm.com>
+	* c-typeck.c (c_common_type): Prefer double_type_node over
+	other REAL_TYPE types with the same precision.
+	(convert_arguments): Likewise.
+
+2013-08-23  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from fsf-gcc/trunk:
+      2013-07-04  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR c/57821
+	* c-typeck.c (set_init_index): When folding, check for index overflow.
diff --git gcc/c/c-typeck.c gcc/c/c-typeck.c
index ddb6d39..9efa48d 100644
--- gcc/c/c-typeck.c
+++ gcc/c/c-typeck.c
@@ -919,6 +919,13 @@ c_common_type (tree t1, tree t2)
       || TYPE_MAIN_VARIANT (t2) == long_double_type_node)
     return long_double_type_node;
 
+  /* Likewise, prefer double to float even if same size.
+     We got a couple of embedded targets with 32 bit doubles, and the
+     pdp11 might have 64 bit floats.  */
+  if (TYPE_MAIN_VARIANT (t1) == double_type_node
+      || TYPE_MAIN_VARIANT (t2) == double_type_node)
+    return double_type_node;
+
   /* Otherwise prefer the unsigned one.  */
 
   if (TYPE_UNSIGNED (t1))
@@ -3139,7 +3146,9 @@ convert_arguments (tree typelist, vec<tree, va_gc> *values,
 	}
       else if (TREE_CODE (valtype) == REAL_TYPE
 	       && (TYPE_PRECISION (valtype)
-		   < TYPE_PRECISION (double_type_node))
+		   <= TYPE_PRECISION (double_type_node))
+	       && valtype != double_type_node
+	       && valtype != long_double_type_node
 	       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (valtype)))
         {
 	  if (type_generic)
@@ -7206,6 +7215,11 @@ set_init_index (tree first, tree last,
       if (last)
 	constant_expression_warning (last);
       constructor_index = convert (bitsizetype, first);
+      if (tree_int_cst_lt (constructor_index, first))
+	{
+	  constructor_index = copy_node (constructor_index);
+	  TREE_OVERFLOW (constructor_index) = 1;
+	}
 
       if (last)
 	{
diff --git gcc/common.opt gcc/common.opt
index bdbd3b6..f025331 100644
--- gcc/common.opt
+++ gcc/common.opt
@@ -2303,9 +2303,13 @@ Common JoinedOrMissing
 Generate debug information in default format
 
 gcoff
-Common JoinedOrMissing Negative(gdwarf-)
+Common JoinedOrMissing Negative(gdwarf)
 Generate debug information in COFF format
 
+gdwarf
+Common JoinedOrMissing Negative(gdwarf-)
+Generate debug information in default version of DWARF format
+
 gdwarf-
 Common Joined UInteger Var(dwarf_version) Init(4) Negative(gstabs)
 Generate debug information in DWARF v2 (or later) format
diff --git gcc/config/avr/avr-arch.h gcc/config/avr/avr-arch.h
index 27cea73..2261650 100644
--- gcc/config/avr/avr-arch.h
+++ gcc/config/avr/avr-arch.h
@@ -35,6 +35,8 @@ enum avr_arch
   ARCH_AVR5,
   ARCH_AVR51,
   ARCH_AVR6,
+  ARCH_AVR7,
+  ARCH_AVRTINY,
   ARCH_AVRXMEGA2,
   ARCH_AVRXMEGA4,
   ARCH_AVRXMEGA5,
@@ -75,6 +77,9 @@ typedef struct
      and thus also the RAMPX, RAMPY and RAMPZ registers.  */
   int have_rampd;
 
+  /* This is a TINY core. */
+  int tiny_p;
+
   /* Default start of data section address for architecture.  */
   int default_data_section_start;
 
diff --git gcc/config/avr/avr-c.c gcc/config/avr/avr-c.c
index 4e64405..4a4c46b 100644
--- gcc/config/avr/avr-c.c
+++ gcc/config/avr/avr-c.c
@@ -322,6 +322,23 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)
     }
   if (AVR_XMEGA)
     cpp_define (pfile, "__AVR_XMEGA__");
+
+  if (AVR_TINY)
+    {
+      cpp_define (pfile, "__AVR_TINY__");
+
+      /* Define macro "__AVR_TINY_PM_BASE_ADDRESS__" with mapped program memory
+         start address. This macro shall be referred where mapped program memory
+         is accessed. (Eg. copying data section (do_copy_data) contents to data
+         memory region.
+         NOTE:
+         Program memory of AVR_TINY devices can not be accessed directly, it has
+         been mapped to the data memory. For AVR_TINY devices (ATtiny4/ 5/ 9/ 10/
+         20 and 40) mapped program memory starts at 0x4000.
+      */
+      cpp_define (pfile, "__AVR_TINY_PM_BASE_ADDRESS__=0x4000");
+    }
+
   if (avr_current_arch->have_eijmp_eicall)
     {
       cpp_define (pfile, "__AVR_HAVE_EIJMP_EICALL__");
diff --git gcc/config/avr/avr-devices.c gcc/config/avr/avr-devices.c
index 48a9523..5ab0ce3 100644
--- gcc/config/avr/avr-devices.c
+++ gcc/config/avr/avr-devices.c
@@ -31,29 +31,31 @@ const avr_arch_t
 avr_arch_types[] =
 {
   /* unknown device specified */
-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL,              "avr2"  },
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, NULL,  "avr2"  },
   /*
-    A  M  J  LM E  E  E  X  R   d S   S O   A
-    S  U  M  PO L  L  I  M  A   a t   F ff  r
-    M  L  P  MV P  P  J  E  M   t a   R s   c
-             XW M  M  M  G  P   a r     e   h
-                   X  P  A  D     t     t   ID   */
-  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "1",   "avr1"  },
-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "2",   "avr2"  },
-  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "25",  "avr25" },
-  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "3",   "avr3"  },
-  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 32, "31",  "avr31" },
-  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, "35",  "avr35" },
-  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "4",   "avr4"  },
-  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, "5",   "avr5"  },
-  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, "51",  "avr51" },
-  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 32, "6",   "avr6"  },
+    A  M  J  LM E  E  E  X  R  T  d S   S O   A
+    S  U  M  PO L  L  I  M  A  I  a t   F ff  r
+    M  L  P  MV P  P  J  E  M  N  t a   R s   c
+             XW M  M  M  G  P  Y  a r     e   h
+                   X  P  A  D       t     t   ID   */
+  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "1",   "avr1"  },
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "2",   "avr2"  },
+  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "25",  "avr25" },
+  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, "3",   "avr3"  },
+  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, "31",  "avr31" },
+  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "35",  "avr35" },
+  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "4",   "avr4"  },
+  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, "5",   "avr5"  },
+  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0x0060, 32, "51",  "avr51" },
+  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, "6",   "avr6"  },
+  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0x0200, 32, "7",   "avr7"  },
 
-  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0x2000,  0, "102", "avrxmega2" },
-  { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0x2000,  0, "104", "avrxmega4" },
-  { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0x2000,  0, "105", "avrxmega5" },
-  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, "106", "avrxmega6" },
-  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0x2000,  0, "107", "avrxmega7" }
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0x0040,  0, "100", "avrtiny" },
+  { 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0x2000,  0, "102", "avrxmega2" },
+  { 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0x2000,  0, "104", "avrxmega4" },
+  { 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0x2000,  0, "105", "avrxmega5" },
+  { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0x2000,  0, "106", "avrxmega6" },
+  { 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0x2000,  0, "107", "avrxmega7" }
 };
 
 const avr_arch_info_t
@@ -85,6 +87,11 @@ avr_texinfo[] =
   { ARCH_AVR6,
     "``Enhanced'' devices with 3-byte PC, i.e.@: with more than 128@tie{}KiB "
     "of program memory." },
+  { ARCH_AVR7,
+   "``Enhanced'' devices with 20@tie{}KiB of program memory starts at 0x8000."},
+  { ARCH_AVRTINY,
+    "``TINY'' Tiny core devices with 512@tie{}B up to 4@tie{}KiB of "
+    "program memory." },
   { ARCH_AVRXMEGA2,
     "``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB "
     "of program memory." },
diff --git gcc/config/avr/avr-fixed.md gcc/config/avr/avr-fixed.md
index 7d9b525..b2f0b9a 100644
--- gcc/config/avr/avr-fixed.md
+++ gcc/config/avr/avr-fixed.md
@@ -447,49 +447,18 @@
 ;; "roundqq3_const"  "rounduqq3_const"
 ;; "roundhq3_const"  "rounduhq3_const"  "roundha3_const"  "rounduha3_const"
 ;; "roundsq3_const"  "roundusq3_const"  "roundsa3_const"  "roundusa3_const"
-(define_expand "round<mode>3_const"
-  [(parallel [(match_operand:ALL124QA 0 "register_operand" "")
-              (match_operand:ALL124QA 1 "register_operand" "")
-              (match_operand:HI 2 "const_int_operand" "")])]
+(define_insn "round<mode>3_const"
+  [(set (match_operand:ALL124QA 0 "register_operand"                  "=d")
+        (unspec:ALL124QA [(match_operand:ALL124QA 1 "register_operand" "0")
+                          (match_operand:HI 2 "const_int_operand"      "n")
+                          (const_int 0)]
+                         UNSPEC_ROUND))]
   ""
   {
-    // The rounding point RP is $2.  The smallest fractional
-    // bit that is not cleared by the rounding is 2^(-RP).
-
-    enum machine_mode imode = int_mode_for_mode (<MODE>mode);
-    int fbit = (int) GET_MODE_FBIT (<MODE>mode);
-
-    // Add-Saturate  1/2 * 2^(-RP)
-
-    double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (operands[2]));
-    rtx x_add = const_fixed_from_double_int (i_add, <MODE>mode);
-
-    if (SIGNED_FIXED_POINT_MODE_P (<MODE>mode))
-      emit_move_insn (operands[0],
-                      gen_rtx_SS_PLUS (<MODE>mode, operands[1], x_add));
-    else
-      emit_move_insn (operands[0],
-                      gen_rtx_US_PLUS (<MODE>mode, operands[1], x_add));
-
-    // Keep  all bits from RP and higher:   ... 2^(-RP)
-    // Clear all bits from RP+1 and lower:              2^(-RP-1) ...
-    // Rounding point                           ^^^^^^^
-    // Added above                                      ^^^^^^^^^
-
-    rtx xreg = simplify_gen_subreg (imode, operands[0], <MODE>mode, 0);
-    rtx xmask = immed_double_int_const (-i_add - i_add, imode);
-
-    if (SImode == imode)
-      emit_insn (gen_andsi3 (xreg, xreg, xmask));
-    else if (HImode == imode)
-      emit_insn (gen_andhi3 (xreg, xreg, xmask));
-    else if (QImode == imode)
-      emit_insn (gen_andqi3 (xreg, xreg, xmask));
-    else
-      gcc_unreachable();
-
-    DONE;
-  })
+    return avr_out_round (insn, operands);
+  }
+  [(set_attr "cc" "clobber")
+   (set_attr "adjust_len" "round")])
 
 
 ;; "*roundqq3.libgcc"  "*rounduqq3.libgcc"
diff --git gcc/config/avr/avr-mcus.def gcc/config/avr/avr-mcus.def
index 2a730ac..8c6329d 100644
--- gcc/config/avr/avr-mcus.def
+++ gcc/config/avr/avr-mcus.def
@@ -59,7 +59,7 @@
 
    "avr2" must be first for the "0" default to work as intended.  */
 
-/* Classic, <= 8K.  */
+/* Classic, <= 8K, 2-byte PC.  */
 AVR_MCU ("avr2",                 ARCH_AVR2, NULL,                        0, 1, 0x0060, 6, "s8515")
 AVR_MCU ("at90s2313",            ARCH_AVR2, "__AVR_AT90S2313__",         1, 0, 0x0060, 1, "s2313")
 AVR_MCU ("at90s2323",            ARCH_AVR2, "__AVR_AT90S2323__",         1, 0, 0x0060, 1, "s2323")
@@ -73,10 +73,10 @@ AVR_MCU ("at90s4434",            ARCH_AVR2, "__AVR_AT90S4434__",         0, 0, 0
 AVR_MCU ("at90s8515",            ARCH_AVR2, "__AVR_AT90S8515__",         0, 1, 0x0060, 1, "s8515")
 AVR_MCU ("at90c8534",            ARCH_AVR2, "__AVR_AT90C8534__",         0, 0, 0x0060, 1, "c8534")
 AVR_MCU ("at90s8535",            ARCH_AVR2, "__AVR_AT90S8535__",         0, 0, 0x0060, 1, "s8535")
-/* Classic + MOVW, <= 8K.  */
+/* Classic + MOVW/LPMX, <= 8K + 2-byte PC.  */
 AVR_MCU ("avr25",                ARCH_AVR25, NULL,                       0, 0, 0x0060, 1, "tn85")
-AVR_MCU ("ata6289",              ARCH_AVR25, "__AVR_ATA6289__",          0, 0, 0x0100, 1, "a6289")
 AVR_MCU ("ata5272",              ARCH_AVR25, "__AVR_ATA5272__",          0, 0, 0x0100, 1, "a5272")
+AVR_MCU ("ata6616c",             ARCH_AVR25, "__AVR_ATA6616C__",         0, 0, 0x0100, 1, "a6616c")
 AVR_MCU ("attiny13",             ARCH_AVR25, "__AVR_ATtiny13__",         1, 0, 0x0060, 1, "tn13")
 AVR_MCU ("attiny13a",            ARCH_AVR25, "__AVR_ATtiny13A__",        1, 0, 0x0060, 1, "tn13a")
 AVR_MCU ("attiny2313",           ARCH_AVR25, "__AVR_ATtiny2313__",       1, 0, 0x0060, 1, "tn2313")
@@ -86,6 +86,7 @@ AVR_MCU ("attiny24a",            ARCH_AVR25, "__AVR_ATtiny24A__",        1, 0, 0
 AVR_MCU ("attiny4313",           ARCH_AVR25, "__AVR_ATtiny4313__",       0, 0, 0x0060, 1, "tn4313")
 AVR_MCU ("attiny44",             ARCH_AVR25, "__AVR_ATtiny44__",         0, 0, 0x0060, 1, "tn44")
 AVR_MCU ("attiny44a",            ARCH_AVR25, "__AVR_ATtiny44A__",        0, 0, 0x0060, 1, "tn44a")
+AVR_MCU ("attiny441",			 ARCH_AVR25, "__AVR_ATtiny441__",		 0, 0, 0x0100, 1, "tn441")
 AVR_MCU ("attiny84",             ARCH_AVR25, "__AVR_ATtiny84__",         0, 0, 0x0060, 1, "tn84")
 AVR_MCU ("attiny84a",            ARCH_AVR25, "__AVR_ATtiny84A__",        0, 0, 0x0060, 1, "tn84")
 AVR_MCU ("attiny25",             ARCH_AVR25, "__AVR_ATtiny25__",         1, 0, 0x0060, 1, "tn25")
@@ -101,18 +102,22 @@ AVR_MCU ("attiny43u",            ARCH_AVR25, "__AVR_ATtiny43U__",        0, 0, 0
 AVR_MCU ("attiny87",             ARCH_AVR25, "__AVR_ATtiny87__",         0, 0, 0x0100, 1, "tn87")
 AVR_MCU ("attiny48",             ARCH_AVR25, "__AVR_ATtiny48__",         0, 0, 0x0100, 1, "tn48")
 AVR_MCU ("attiny88",             ARCH_AVR25, "__AVR_ATtiny88__",         0, 0, 0x0100, 1, "tn88")
+AVR_MCU ("attiny828",            ARCH_AVR25, "__AVR_ATtiny828__",        0, 0, 0x0100, 1, "tn828")
+AVR_MCU ("attiny841",            ARCH_AVR25, "__AVR_ATtiny841__",        0, 0, 0x0100, 1, "tn841")
 AVR_MCU ("at86rf401",            ARCH_AVR25, "__AVR_AT86RF401__",        0, 0, 0x0060, 1, "86401")
-/* Classic, > 8K, <= 64K.  */
+/* Classic, > 8K, <= 64K + 2-byte PC + { JMP/CALL }.  */
 AVR_MCU ("avr3",                 ARCH_AVR3, NULL,                        0, 0, 0x0060, 1, "43355")
 AVR_MCU ("at43usb355",           ARCH_AVR3, "__AVR_AT43USB355__",        0, 0, 0x0060, 1, "43355")
 AVR_MCU ("at76c711",             ARCH_AVR3, "__AVR_AT76C711__",          0, 0, 0x0060, 1, "76711")
-/* Classic, == 128K.  */
+/* Classic, == 128K + 2-byte PC + {JMP/CALL, ELPM }.  */
 AVR_MCU ("avr31",                ARCH_AVR31, NULL,                       0, 1, 0x0060, 2, "m103")
 AVR_MCU ("atmega103",            ARCH_AVR31, "__AVR_ATmega103__",        0, 1, 0x0060, 2, "m103")
 AVR_MCU ("at43usb320",           ARCH_AVR31, "__AVR_AT43USB320__",       0, 0, 0x0060, 2, "43320")
-/* Classic + MOVW + JMP/CALL.  */
+/* Classic, >=16K, <=64K + 2-byte PC + MOVW/LPMX + JMP/CALL.  */
 AVR_MCU ("avr35",                ARCH_AVR35, NULL,                       0, 0, 0x0100, 1, "usb162")
 AVR_MCU ("ata5505",              ARCH_AVR35, "__AVR_ATA5505__",          0, 0, 0x0100, 1, "a5505")
+AVR_MCU ("ata6617c",             ARCH_AVR35, "__AVR_ATA6617C__",         0, 0, 0x0100, 1, "a6617c")
+AVR_MCU ("ata664251",            ARCH_AVR35, "__AVR_ATA664251__",        0, 0, 0x0100, 1, "a664251")
 AVR_MCU ("at90usb82",            ARCH_AVR35, "__AVR_AT90USB82__",        0, 0, 0x0100, 1, "usb82")
 AVR_MCU ("at90usb162",           ARCH_AVR35, "__AVR_AT90USB162__",       0, 0, 0x0100, 1, "usb162")
 AVR_MCU ("atmega8u2",            ARCH_AVR35, "__AVR_ATmega8U2__",        0, 0, 0x0100, 1, "m8u2")
@@ -120,10 +125,12 @@ AVR_MCU ("atmega16u2",           ARCH_AVR35, "__AVR_ATmega16U2__",       0, 0, 0
 AVR_MCU ("atmega32u2",           ARCH_AVR35, "__AVR_ATmega32U2__",       0, 0, 0x0100, 1, "m32u2")
 AVR_MCU ("attiny167",            ARCH_AVR35, "__AVR_ATtiny167__",        0, 0, 0x0100, 1, "tn167")
 AVR_MCU ("attiny1634",           ARCH_AVR35, "__AVR_ATtiny1634__",       0, 0, 0x0100, 1, "tn1634")
-/* Enhanced, <= 8K.  */
+/* Enhanced, <= 8K + 2-byte PC + { MOVW/LPMX, MUL }.  */
 AVR_MCU ("avr4",                 ARCH_AVR4, NULL,                        0, 0, 0x0060, 1, "m8")
 AVR_MCU ("ata6285",              ARCH_AVR4, "__AVR_ATA6285__",           0, 0, 0x0100, 1, "a6285")
 AVR_MCU ("ata6286",              ARCH_AVR4, "__AVR_ATA6286__",           0, 0, 0x0100, 1, "a6286")
+AVR_MCU ("ata6289",              ARCH_AVR4, "__AVR_ATA6289__",           0, 0, 0x0100, 1, "a6289")
+AVR_MCU ("ata6612c",             ARCH_AVR4, "__AVR_ATA6612C__",          0, 0, 0x0100, 1, "a6612c")
 AVR_MCU ("atmega8",              ARCH_AVR4, "__AVR_ATmega8__",           0, 0, 0x0060, 1, "m8")
 AVR_MCU ("atmega8a",             ARCH_AVR4, "__AVR_ATmega8A__",          0, 0, 0x0060, 1, "m8a")
 AVR_MCU ("atmega48",             ARCH_AVR4, "__AVR_ATmega48__",          0, 0, 0x0100, 1, "m48")
@@ -143,11 +150,13 @@ AVR_MCU ("at90pwm2b",            ARCH_AVR4, "__AVR_AT90PWM2B__",         0, 0, 0
 AVR_MCU ("at90pwm3",             ARCH_AVR4, "__AVR_AT90PWM3__",          0, 0, 0x0100, 1, "90pwm3")
 AVR_MCU ("at90pwm3b",            ARCH_AVR4, "__AVR_AT90PWM3B__",         0, 0, 0x0100, 1, "90pwm3b")
 AVR_MCU ("at90pwm81",            ARCH_AVR4, "__AVR_AT90PWM81__",         0, 0, 0x0100, 1, "90pwm81")
-/* Enhanced, > 8K, <= 64K.  */
+/* Enhanced, > 8K, <= 64K + 2-byte PC + { MOVW/LPMX, JMP/CALL, MUL }.  */
 AVR_MCU ("avr5",                 ARCH_AVR5, NULL,                        0, 0, 0x0060, 1, "m16")
 AVR_MCU ("ata5790",              ARCH_AVR5, "__AVR_ATA5790__",           0, 0, 0x0100, 1, "a5790")
 AVR_MCU ("ata5790n",             ARCH_AVR5, "__AVR_ATA5790N__",          0, 0, 0x0100, 1, "a5790n")
 AVR_MCU ("ata5795",              ARCH_AVR5, "__AVR_ATA5795__",           0, 0, 0x0100, 1, "a5795")
+AVR_MCU ("ata6613c",             ARCH_AVR5, "__AVR_ATA6613C__",          0, 0, 0x0100, 1, "a6613c")
+AVR_MCU ("ata6614q",             ARCH_AVR5, "__AVR_ATA6614Q__",          0, 0, 0x0100, 1, "a6614q")
 AVR_MCU ("atmega16",             ARCH_AVR5, "__AVR_ATmega16__",          0, 0, 0x0060, 1, "m16")
 AVR_MCU ("atmega16a",            ARCH_AVR5, "__AVR_ATmega16A__",         0, 0, 0x0060, 1, "m16a")
 AVR_MCU ("atmega161",            ARCH_AVR5, "__AVR_ATmega161__",         0, 0, 0x0060, 1, "m161")
@@ -168,15 +177,12 @@ AVR_MCU ("atmega169",            ARCH_AVR5, "__AVR_ATmega169__",         0, 0, 0
 AVR_MCU ("atmega169a",           ARCH_AVR5, "__AVR_ATmega169A__",        0, 0, 0x0100, 1, "m169a")
 AVR_MCU ("atmega169p",           ARCH_AVR5, "__AVR_ATmega169P__",        0, 0, 0x0100, 1, "m169p")
 AVR_MCU ("atmega169pa",          ARCH_AVR5, "__AVR_ATmega169PA__",       0, 0, 0x0100, 1, "m169pa")
-AVR_MCU ("atmega16hva",          ARCH_AVR5, "__AVR_ATmega16HVA__",       0, 0, 0x0100, 1, "m16hva")
 AVR_MCU ("atmega16hvb",          ARCH_AVR5, "__AVR_ATmega16HVB__",       0, 0, 0x0100, 1, "m16hvb")
 AVR_MCU ("atmega16hvbrevb",      ARCH_AVR5, "__AVR_ATmega16HVBREVB__",   0, 0, 0x0100, 1, "m16hvbrevb")
 AVR_MCU ("atmega16m1",           ARCH_AVR5, "__AVR_ATmega16M1__",        0, 0, 0x0100, 1, "m16m1")
 AVR_MCU ("atmega16u4",           ARCH_AVR5, "__AVR_ATmega16U4__",        0, 0, 0x0100, 1, "m16u4")
-AVR_MCU ("atmega26hvg",          ARCH_AVR5, "__AVR_ATmega26HVG__",       0, 0, 0x0100, 1, "m26hvg")
 AVR_MCU ("atmega32a",            ARCH_AVR5, "__AVR_ATmega32A__",         0, 0, 0x0060, 1, "m32a")
 AVR_MCU ("atmega32",             ARCH_AVR5, "__AVR_ATmega32__",          0, 0, 0x0060, 1, "m32")
-AVR_MCU ("atmega32a",            ARCH_AVR5, "__AVR_ATmega32A__",         0, 0, 0x0060, 1, "m32a")
 AVR_MCU ("atmega323",            ARCH_AVR5, "__AVR_ATmega323__",         0, 0, 0x0060, 1, "m323")
 AVR_MCU ("atmega324a",           ARCH_AVR5, "__AVR_ATmega324A__",        0, 0, 0x0100, 1, "m324a")
 AVR_MCU ("atmega324p",           ARCH_AVR5, "__AVR_ATmega324P__",        0, 0, 0x0100, 1, "m324p")
@@ -184,6 +190,7 @@ AVR_MCU ("atmega324pa",          ARCH_AVR5, "__AVR_ATmega324PA__",       0, 0, 0
 AVR_MCU ("atmega325",            ARCH_AVR5, "__AVR_ATmega325__",         0, 0, 0x0100, 1, "m325")
 AVR_MCU ("atmega325a",           ARCH_AVR5, "__AVR_ATmega325A__",        0, 0, 0x0100, 1, "m325a")
 AVR_MCU ("atmega325p",           ARCH_AVR5, "__AVR_ATmega325P__",        0, 0, 0x0100, 1, "m325p")
+AVR_MCU ("atmega325pa",          ARCH_AVR5, "__AVR_ATmega325PA__",       0, 0, 0x0100, 1, "m325pa")
 AVR_MCU ("atmega3250",           ARCH_AVR5, "__AVR_ATmega3250__",        0, 0, 0x0100, 1, "m3250")
 AVR_MCU ("atmega3250a",          ARCH_AVR5, "__AVR_ATmega3250A__",       0, 0, 0x0100, 1, "m3250a")
 AVR_MCU ("atmega3250p",          ARCH_AVR5, "__AVR_ATmega3250P__",       0, 0, 0x0100, 1, "m3250p")
@@ -222,38 +229,27 @@ AVR_MCU ("atmega649p",           ARCH_AVR5, "__AVR_ATmega649P__",        0, 0, 0
 AVR_MCU ("atmega6490",           ARCH_AVR5, "__AVR_ATmega6490__",        0, 0, 0x0100, 1, "m6490")
 AVR_MCU ("atmega16hva",          ARCH_AVR5, "__AVR_ATmega16HVA__",       0, 0, 0x0100, 1, "m16hva")
 AVR_MCU ("atmega16hva2",         ARCH_AVR5, "__AVR_ATmega16HVA2__",      0, 0, 0x0100, 1, "m16hva2")
-AVR_MCU ("atmega16hvb",          ARCH_AVR5, "__AVR_ATmega16HVB__",       0, 0, 0x0100, 1, "m16hvb")
 AVR_MCU ("atmega32hvb",          ARCH_AVR5, "__AVR_ATmega32HVB__",       0, 0, 0x0100, 1, "m32hvb")
 AVR_MCU ("atmega6490a",          ARCH_AVR5, "__AVR_ATmega6490A__",       0, 0, 0x0100, 1, "m6490a")
 AVR_MCU ("atmega6490p",          ARCH_AVR5, "__AVR_ATmega6490P__",       0, 0, 0x0100, 1, "m6490p")
 AVR_MCU ("atmega64c1",           ARCH_AVR5, "__AVR_ATmega64C1__",        0, 0, 0x0100, 1, "m64c1")
 AVR_MCU ("atmega64m1",           ARCH_AVR5, "__AVR_ATmega64M1__",        0, 0, 0x0100, 1, "m64m1")
 AVR_MCU ("atmega64hve",          ARCH_AVR5, "__AVR_ATmega64HVE__",       0, 0, 0x0100, 1, "m64hve")
-AVR_MCU ("atmega64rfa2",         ARCH_AVR5, "__AVR_ATmega64RFA2__",      0, 0, 0x0200, 1, "m64rfa2")
+AVR_MCU ("atmega64hve2",         ARCH_AVR5, "__AVR_ATmega64HVE2__",      0, 0, 0x0100, 1, "m64hve2")
 AVR_MCU ("atmega64rfr2",         ARCH_AVR5, "__AVR_ATmega64RFR2__",      0, 0, 0x0200, 1, "m64rfr2")
-AVR_MCU ("atmega32hvb",          ARCH_AVR5, "__AVR_ATmega32HVB__",       0, 0, 0x0100, 1, "m32hvb")
+AVR_MCU ("atmega644rfr2",        ARCH_AVR5, "__AVR_ATmega644RFR2__",     0, 0, 0x0200, 1, "m644rfr2")
 AVR_MCU ("atmega32hvbrevb",      ARCH_AVR5, "__AVR_ATmega32HVBREVB__",   0, 0, 0x0100, 1, "m32hvbrevb")
-AVR_MCU ("atmega16hva2",         ARCH_AVR5, "__AVR_ATmega16HVA2__",      0, 0, 0x0100, 1, "m16hva2")
-AVR_MCU ("atmega48hvf",          ARCH_AVR5, "__AVR_ATmega48HVF__",       0, 0, 0x0100, 1, "m48hvf")
 AVR_MCU ("at90can32",            ARCH_AVR5, "__AVR_AT90CAN32__",         0, 0, 0x0100, 1, "can32")
 AVR_MCU ("at90can64",            ARCH_AVR5, "__AVR_AT90CAN64__",         0, 0, 0x0100, 1, "can64")
 AVR_MCU ("at90pwm161",           ARCH_AVR5, "__AVR_AT90PWM161__",        0, 0, 0x0100, 1, "90pwm161")
 AVR_MCU ("at90pwm216",           ARCH_AVR5, "__AVR_AT90PWM216__",        0, 0, 0x0100, 1, "90pwm216")
 AVR_MCU ("at90pwm316",           ARCH_AVR5, "__AVR_AT90PWM316__",        0, 0, 0x0100, 1, "90pwm316")
-AVR_MCU ("atmega32c1",           ARCH_AVR5, "__AVR_ATmega32C1__",        0, 0, 0x0100, 1, "m32c1")
-AVR_MCU ("atmega64c1",           ARCH_AVR5, "__AVR_ATmega64C1__",        0, 0, 0x0100, 1, "m64c1")
-AVR_MCU ("atmega16m1",           ARCH_AVR5, "__AVR_ATmega16M1__",        0, 0, 0x0100, 1, "m16m1")
-AVR_MCU ("atmega32m1",           ARCH_AVR5, "__AVR_ATmega32M1__",        0, 0, 0x0100, 1, "m32m1")
-AVR_MCU ("atmega64m1",           ARCH_AVR5, "__AVR_ATmega64M1__",        0, 0, 0x0100, 1, "m64m1")
-AVR_MCU ("atmega16u4",           ARCH_AVR5, "__AVR_ATmega16U4__",        0, 0, 0x0100, 1, "m16u4")
-AVR_MCU ("atmega32u4",           ARCH_AVR5, "__AVR_ATmega32U4__",        0, 0, 0x0100, 1, "m32u4")
-AVR_MCU ("atmega32u6",           ARCH_AVR5, "__AVR_ATmega32U6__",        0, 0, 0x0100, 1, "m32u6")
 AVR_MCU ("at90scr100",           ARCH_AVR5, "__AVR_AT90SCR100__",        0, 0, 0x0100, 1, "90scr100")
 AVR_MCU ("at90usb646",           ARCH_AVR5, "__AVR_AT90USB646__",        0, 0, 0x0100, 1, "usb646")
 AVR_MCU ("at90usb647",           ARCH_AVR5, "__AVR_AT90USB647__",        0, 0, 0x0100, 1, "usb647")
 AVR_MCU ("at94k",                ARCH_AVR5, "__AVR_AT94K__",             0, 0, 0x0060, 1, "at94k")
 AVR_MCU ("m3000",                ARCH_AVR5, "__AVR_M3000__",             0, 0, 0x1000, 1, "m3000")
-/* Enhanced, == 128K.  */
+/* Enhanced, == 128K + 2-byte PC + { MOVW/LPMX, JMP/CALL, MUL, ELPM, ELPMX }.  */
 AVR_MCU ("avr51",                ARCH_AVR51, NULL,                       0, 0, 0x0100, 2, "m128")
 AVR_MCU ("atmega128",            ARCH_AVR51, "__AVR_ATmega128__",        0, 0, 0x0100, 2, "m128")
 AVR_MCU ("atmega128a",           ARCH_AVR51, "__AVR_ATmega128A__",       0, 0, 0x0100, 2, "m128a")
@@ -262,39 +258,45 @@ AVR_MCU ("atmega1281",           ARCH_AVR51, "__AVR_ATmega1281__",       0, 0, 0
 AVR_MCU ("atmega1284",           ARCH_AVR51, "__AVR_ATmega1284__",       0, 0, 0x0100, 2, "m1284")
 AVR_MCU ("atmega1284p",          ARCH_AVR51, "__AVR_ATmega1284P__",      0, 0, 0x0100, 2, "m1284p")
 AVR_MCU ("atmega128rfa1",        ARCH_AVR51, "__AVR_ATmega128RFA1__",    0, 0, 0x0200, 2, "m128rfa1")
+AVR_MCU ("atmega128rfr2",        ARCH_AVR51, "__AVR_ATmega128RFR2__",    0, 0, 0x0200, 2, "m128rfr2")
+AVR_MCU ("atmega1284rfr2",       ARCH_AVR51, "__AVR_ATmega1284RFR2__",   0, 0, 0x0200, 2, "m1284rfr2")
 AVR_MCU ("at90can128",           ARCH_AVR51, "__AVR_AT90CAN128__",       0, 0, 0x0100, 2, "can128")
 AVR_MCU ("at90usb1286",          ARCH_AVR51, "__AVR_AT90USB1286__",      0, 0, 0x0100, 2, "usb1286")
 AVR_MCU ("at90usb1287",          ARCH_AVR51, "__AVR_AT90USB1287__",      0, 0, 0x0100, 2, "usb1287")
-/* 3-Byte PC.  */
+/* Enhanced, == 256K + 3-Byte PC + { MOVW/LPMX, JMP/CALL, MUL, ELPM, ELPMX }.  */
 AVR_MCU ("avr6",                 ARCH_AVR6, NULL,                        0, 0, 0x0200, 4, "m2561")
 AVR_MCU ("atmega2560",           ARCH_AVR6, "__AVR_ATmega2560__",        0, 0, 0x0200, 4, "m2560")
 AVR_MCU ("atmega2561",           ARCH_AVR6, "__AVR_ATmega2561__",        0, 0, 0x0200, 4, "m2561")
+AVR_MCU ("atmega256rfr2",        ARCH_AVR6, "__AVR_ATmega256RFR2__",     0, 0, 0x0200, 4, "m256rfr2")
+AVR_MCU ("atmega2564rfr2",       ARCH_AVR6, "__AVR_ATmega2564RFR2__",    0, 0, 0x0200, 4, "m2564rfr2")
+/* Enhanced, == 20K starts at 0x8000 */
+AVR_MCU ("avr7",                 ARCH_AVR7, NULL,                        0, 0, 0x0200, 1, "a5831")
+AVR_MCU ("ata5831",              ARCH_AVR7, "__AVR_ATA5831__",           0, 0, 0x0200, 1, "a5831")
 /* Xmega, 16K <= Flash < 64K, RAM <= 64K */
 AVR_MCU ("avrxmega2",        ARCH_AVRXMEGA2, NULL,                       0, 0, 0x2000, 1, "x32a4")
+AVR_MCU ("atxmega8e5",       ARCH_AVRXMEGA2, "__AVR_ATxmega8E5__",       0, 0, 0x2000, 1, "x8e5")
 AVR_MCU ("atxmega16a4",      ARCH_AVRXMEGA2, "__AVR_ATxmega16A4__",      0, 0, 0x2000, 1, "x16a4")
+AVR_MCU ("atxmega16a4u",     ARCH_AVRXMEGA2, "__AVR_ATxmega16A4U__",     0, 0, 0x2000, 1, "x16a4u")
+AVR_MCU ("atxmega16c4",      ARCH_AVRXMEGA2, "__AVR_ATxmega16C4__",      0, 0, 0x2000, 1, "x16c4")
 AVR_MCU ("atxmega16d4",      ARCH_AVRXMEGA2, "__AVR_ATxmega16D4__",      0, 0, 0x2000, 1, "x16d4")
+AVR_MCU ("atxmega16e5",      ARCH_AVRXMEGA2, "__AVR_ATxmega16E5__",      0, 0, 0x2000, 1, "x16e5")
 AVR_MCU ("atxmega16x1",      ARCH_AVRXMEGA2, "__AVR_ATxmega16X1__",      0, 0, 0x2000, 1, "x16x1")
 AVR_MCU ("atxmega32a4",      ARCH_AVRXMEGA2, "__AVR_ATxmega32A4__",      0, 0, 0x2000, 1, "x32a4")
-AVR_MCU ("atxmega32d4",      ARCH_AVRXMEGA2, "__AVR_ATxmega32D4__",      0, 0, 0x2000, 1, "x32d4")
-AVR_MCU ("atxmega32x1",      ARCH_AVRXMEGA2, "__AVR_ATxmega32X1__",      0, 0, 0x2000, 1, "x32x1")
-AVR_MCU ("atmxt112sl",       ARCH_AVRXMEGA2, "__AVR_ATMXT112SL__",       0, 0, 0x2000, 1, "mxt112sl")
-AVR_MCU ("atmxt224",         ARCH_AVRXMEGA2, "__AVR_ATMXT224__",         0, 0, 0x2000, 1, "mxt224")
-AVR_MCU ("atmxt224e",        ARCH_AVRXMEGA2, "__AVR_ATMXT224E__",        0, 0, 0x2000, 1, "mxt224e")
-AVR_MCU ("atmxt336s",        ARCH_AVRXMEGA2, "__AVR_ATMXT336S__",        0, 0, 0x2000, 1, "mxt336s")
-AVR_MCU ("atxmega16a4u",     ARCH_AVRXMEGA2, "__AVR_ATxmega16A4U__",     0, 0, 0x2000, 1, "x16a4u")
-AVR_MCU ("atxmega16c4",      ARCH_AVRXMEGA2, "__AVR_ATxmega16C4__",      0, 0, 0x2000, 1, "x16c4")
 AVR_MCU ("atxmega32a4u",     ARCH_AVRXMEGA2, "__AVR_ATxmega32A4U__",     0, 0, 0x2000, 1, "x32a4u")
+AVR_MCU ("atxmega32c3",      ARCH_AVRXMEGA2, "__AVR_ATxmega32C3__",      0, 0, 0x2000, 1, "x32c3")
 AVR_MCU ("atxmega32c4",      ARCH_AVRXMEGA2, "__AVR_ATxmega32C4__",      0, 0, 0x2000, 1, "x32c4")
+AVR_MCU ("atxmega32d3",      ARCH_AVRXMEGA2, "__AVR_ATxmega32D3__",      0, 0, 0x2000, 1, "x32d3")
+AVR_MCU ("atxmega32d4",      ARCH_AVRXMEGA2, "__AVR_ATxmega32D4__",      0, 0, 0x2000, 1, "x32d4")
 AVR_MCU ("atxmega32e5",      ARCH_AVRXMEGA2, "__AVR_ATxmega32E5__",      0, 0, 0x2000, 1, "x32e5")
 /* Xmega, 64K < Flash <= 128K, RAM <= 64K */
 AVR_MCU ("avrxmega4",        ARCH_AVRXMEGA4, NULL,                       0, 0, 0x2000, 2, "x64a4")
 AVR_MCU ("atxmega64a3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64A3__",      0, 0, 0x2000, 2, "x64a3")
-AVR_MCU ("atxmega64d3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64D3__",      0, 0, 0x2000, 2, "x64d3")
 AVR_MCU ("atxmega64a3u",     ARCH_AVRXMEGA4, "__AVR_ATxmega64A3U__",     0, 0, 0x2000, 2, "x64a3u")
 AVR_MCU ("atxmega64a4u",     ARCH_AVRXMEGA4, "__AVR_ATxmega64A4U__",     0, 0, 0x2000, 2, "x64a4u")
 AVR_MCU ("atxmega64b1",      ARCH_AVRXMEGA4, "__AVR_ATxmega64B1__",      0, 0, 0x2000, 2, "x64b1")
 AVR_MCU ("atxmega64b3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64B3__",      0, 0, 0x2000, 2, "x64b3")
 AVR_MCU ("atxmega64c3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64C3__",      0, 0, 0x2000, 2, "x64c3")
+AVR_MCU ("atxmega64d3",      ARCH_AVRXMEGA4, "__AVR_ATxmega64D3__",      0, 0, 0x2000, 2, "x64d3")
 AVR_MCU ("atxmega64d4",      ARCH_AVRXMEGA4, "__AVR_ATxmega64D4__",      0, 0, 0x2000, 2, "x64d4")
 /* Xmega, 64K < Flash <= 128K, RAM > 64K */
 AVR_MCU ("avrxmega5",        ARCH_AVRXMEGA5, NULL,                       0, 0, 0x2000, 2, "x64a1")
@@ -303,31 +305,37 @@ AVR_MCU ("atxmega64a1u",     ARCH_AVRXMEGA5, "__AVR_ATxmega64A1U__",     0, 0, 0
 /* Xmega, 128K < Flash, RAM <= 64K */
 AVR_MCU ("avrxmega6",        ARCH_AVRXMEGA6, NULL,                       0, 0, 0x2000, 6, "x128a3")
 AVR_MCU ("atxmega128a3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128A3__",     0, 0, 0x2000, 3, "x128a3")
-AVR_MCU ("atxmega128d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128D3__",     0, 0, 0x2000, 3, "x128d3")
-AVR_MCU ("atxmega192a3",     ARCH_AVRXMEGA6, "__AVR_ATxmega192A3__",     0, 0, 0x2000, 4, "x192a3")
-AVR_MCU ("atxmega192d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega192D3__",     0, 0, 0x2000, 4, "x192d3")
-AVR_MCU ("atxmega256a3",     ARCH_AVRXMEGA6, "__AVR_ATxmega256A3__",     0, 0, 0x2000, 5, "x256a3")
-AVR_MCU ("atxmega256a3b",    ARCH_AVRXMEGA6, "__AVR_ATxmega256A3B__",    0, 0, 0x2000, 5, "x256a3b")
-AVR_MCU ("atxmega256a3bu",   ARCH_AVRXMEGA6, "__AVR_ATxmega256A3BU__",   0, 0, 0x2000, 5, "x256a3bu")
-AVR_MCU ("atxmega256d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega256D3__",     0, 0, 0x2000, 5, "x256d3")
 AVR_MCU ("atxmega128a3u",    ARCH_AVRXMEGA6, "__AVR_ATxmega128A3U__",    0, 0, 0x2000, 3, "x128a3u")
 AVR_MCU ("atxmega128b1",     ARCH_AVRXMEGA6, "__AVR_ATxmega128B1__",     0, 0, 0x2000, 3, "x128b1")
 AVR_MCU ("atxmega128b3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128B3__",     0, 0, 0x2000, 3, "x128b3")
 AVR_MCU ("atxmega128c3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128C3__",     0, 0, 0x2000, 3, "x128c3")
+AVR_MCU ("atxmega128d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega128D3__",     0, 0, 0x2000, 3, "x128d3")
 AVR_MCU ("atxmega128d4",     ARCH_AVRXMEGA6, "__AVR_ATxmega128D4__",     0, 0, 0x2000, 3, "x128d4")
-AVR_MCU ("atmxt540s",        ARCH_AVRXMEGA6, "__AVR_ATMXT540S__",        0, 0, 0x2000, 2, "mxt540s")
-AVR_MCU ("atmxt540sreva",    ARCH_AVRXMEGA6, "__AVR_ATMXT540SREVA__",    0, 0, 0x2000, 2, "mxt540sreva")
+AVR_MCU ("atxmega192a3",     ARCH_AVRXMEGA6, "__AVR_ATxmega192A3__",     0, 0, 0x2000, 4, "x192a3")
 AVR_MCU ("atxmega192a3u",    ARCH_AVRXMEGA6, "__AVR_ATxmega192A3U__",    0, 0, 0x2000, 4, "x192a3u")
 AVR_MCU ("atxmega192c3",     ARCH_AVRXMEGA6, "__AVR_ATxmega192C3__",     0, 0, 0x2000, 4, "x192c3")
+AVR_MCU ("atxmega192d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega192D3__",     0, 0, 0x2000, 4, "x192d3")
+AVR_MCU ("atxmega256a3",     ARCH_AVRXMEGA6, "__AVR_ATxmega256A3__",     0, 0, 0x2000, 5, "x256a3")
+AVR_MCU ("atxmega256a3b",    ARCH_AVRXMEGA6, "__AVR_ATxmega256A3B__",    0, 0, 0x2000, 5, "x256a3b")
+AVR_MCU ("atxmega256a3bu",   ARCH_AVRXMEGA6, "__AVR_ATxmega256A3BU__",   0, 0, 0x2000, 5, "x256a3bu")
 AVR_MCU ("atxmega256a3u",    ARCH_AVRXMEGA6, "__AVR_ATxmega256A3U__",    0, 0, 0x2000, 5, "x256a3u")
 AVR_MCU ("atxmega256c3",     ARCH_AVRXMEGA6, "__AVR_ATxmega256C3__",     0, 0, 0x2000, 5, "x256c3")
+AVR_MCU ("atxmega256d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega256D3__",     0, 0, 0x2000, 5, "x256d3")
 AVR_MCU ("atxmega384c3",     ARCH_AVRXMEGA6, "__AVR_ATxmega384C3__",     0, 0, 0x2000, 6, "x384c3")
 AVR_MCU ("atxmega384d3",     ARCH_AVRXMEGA6, "__AVR_ATxmega384D3__",     0, 0, 0x2000, 6, "x384d3")
-/* Xmega, 128K < Flash, RAM > 64K RAM.  */
+/* Xmega, >= 128K, <= 256K FLASH, > 64K RAM.  */
 AVR_MCU ("avrxmega7",        ARCH_AVRXMEGA7, NULL,                       0, 0, 0x2000, 3, "x128a1")
 AVR_MCU ("atxmega128a1",     ARCH_AVRXMEGA7, "__AVR_ATxmega128A1__",     0, 0, 0x2000, 3, "x128a1")
 AVR_MCU ("atxmega128a1u",    ARCH_AVRXMEGA7, "__AVR_ATxmega128A1U__",    0, 0, 0x2000, 3, "x128a1u")
 AVR_MCU ("atxmega128a4u",    ARCH_AVRXMEGA7, "__AVR_ATxmega128A4U__",    0, 0, 0x2000, 3, "x128a4u")
+/* Tiny family */
+AVR_MCU ("avrtiny",          ARCH_AVRTINY,   NULL,                       0, 0, 0x0040, 1, "tn10")
+AVR_MCU ("attiny4",          ARCH_AVRTINY,   "__AVR_ATtiny4__",          0, 0, 0x0040, 1, "tn4")
+AVR_MCU ("attiny5",          ARCH_AVRTINY,   "__AVR_ATtiny5__",          0, 0, 0x0040, 1, "tn5")
+AVR_MCU ("attiny9",          ARCH_AVRTINY,   "__AVR_ATtiny9__",          0, 0, 0x0040, 1, "tn9") 
+AVR_MCU ("attiny10",         ARCH_AVRTINY,   "__AVR_ATtiny10__",         0, 0, 0x0040, 1, "tn10")
+AVR_MCU ("attiny20",         ARCH_AVRTINY,   "__AVR_ATtiny20__",         0, 0, 0x0040, 1, "tn20")
+AVR_MCU ("attiny40",         ARCH_AVRTINY,   "__AVR_ATtiny40__",         0, 0, 0x0040, 1, "tn40")
 /* Assembler only.  */
 AVR_MCU ("avr1",                 ARCH_AVR1, NULL,                        0, 0, 0x0060, 1, "s1200")
 AVR_MCU ("at90s1200",            ARCH_AVR1, "__AVR_AT90S1200__",         0, 0, 0x0060, 1, "s1200")
diff --git gcc/config/avr/avr-protos.h gcc/config/avr/avr-protos.h
index 5246d06..f788bc9 100644
--- gcc/config/avr/avr-protos.h
+++ gcc/config/avr/avr-protos.h
@@ -45,6 +45,7 @@ extern void avr_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx, tree);
 
 #ifdef RTX_CODE
 extern int avr_hard_regno_call_part_clobbered (unsigned, enum machine_mode);
+extern bool tiny_valid_direct_memory_access_range(rtx, enum machine_mode);
 extern const char *output_movqi (rtx insn, rtx operands[], int *l);
 extern const char *output_movhi (rtx insn, rtx operands[], int *l);
 extern const char *output_movsisf (rtx insn, rtx operands[], int *l);
@@ -86,7 +87,8 @@ extern int avr_starting_frame_offset (void);
 extern void avr_output_addr_vec_elt (FILE *stream, int value);
 extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);
 extern const char* avr_out_bitop (rtx, rtx*, int*);
-extern const char* avr_out_plus (rtx, rtx*, int* =NULL, int* =NULL);
+extern const char* avr_out_plus (rtx, rtx*, int* =NULL, int* =NULL, bool =true);
+extern const char* avr_out_round (rtx, rtx*, int* =NULL);
 extern const char* avr_out_addto_sp (rtx*, int*);
 extern const char* avr_out_xload (rtx, rtx*, int*);
 extern const char* avr_out_movmem (rtx, rtx*, int*);
diff --git gcc/config/avr/avr-stdint.h gcc/config/avr/avr-stdint.h
index 8e7278f..4137b06 100644
--- gcc/config/avr/avr-stdint.h
+++ gcc/config/avr/avr-stdint.h
@@ -34,11 +34,11 @@ along with GCC; see the file COPYING3.  If not see
 #define SIG_ATOMIC_TYPE "char"
 
 #define INT8_TYPE "signed char"
-#define INT16_TYPE (INT_TYPE_SIZE == 16 ? "short int" : "long int")
+#define INT16_TYPE (INT_TYPE_SIZE == 16 ? "int" : "long int")
 #define INT32_TYPE (INT_TYPE_SIZE == 16 ? "long int" : "long long int")
 #define INT64_TYPE (INT_TYPE_SIZE == 16 ? "long long int" : 0)
 #define UINT8_TYPE "unsigned char"
-#define UINT16_TYPE (INT_TYPE_SIZE == 16 ? "short unsigned int" : "long unsigned int")
+#define UINT16_TYPE (INT_TYPE_SIZE == 16 ? "unsigned int" : "long unsigned int")
 #define UINT32_TYPE (INT_TYPE_SIZE == 16 ? "long unsigned int" : "long long unsigned int")
 #define UINT64_TYPE (INT_TYPE_SIZE == 16 ? "long long unsigned int" : 0)
 
diff --git gcc/config/avr/avr-tables.opt gcc/config/avr/avr-tables.opt
index 1a451bd..79fd83e 100644
--- gcc/config/avr/avr-tables.opt
+++ gcc/config/avr/avr-tables.opt
@@ -66,10 +66,10 @@ EnumValue
 Enum(avr_mcu) String(avr25) Value(13)
 
 EnumValue
-Enum(avr_mcu) String(ata6289) Value(14)
+Enum(avr_mcu) String(ata5272) Value(14)
 
 EnumValue
-Enum(avr_mcu) String(ata5272) Value(15)
+Enum(avr_mcu) String(ata6616c) Value(15)
 
 EnumValue
 Enum(avr_mcu) String(attiny13) Value(16)
@@ -99,589 +99,589 @@ EnumValue
 Enum(avr_mcu) String(attiny44a) Value(24)
 
 EnumValue
-Enum(avr_mcu) String(attiny84) Value(25)
+Enum(avr_mcu) String(attiny441) Value(25)
 
 EnumValue
-Enum(avr_mcu) String(attiny84a) Value(26)
+Enum(avr_mcu) String(attiny84) Value(26)
 
 EnumValue
-Enum(avr_mcu) String(attiny25) Value(27)
+Enum(avr_mcu) String(attiny84a) Value(27)
 
 EnumValue
-Enum(avr_mcu) String(attiny45) Value(28)
+Enum(avr_mcu) String(attiny25) Value(28)
 
 EnumValue
-Enum(avr_mcu) String(attiny85) Value(29)
+Enum(avr_mcu) String(attiny45) Value(29)
 
 EnumValue
-Enum(avr_mcu) String(attiny261) Value(30)
+Enum(avr_mcu) String(attiny85) Value(30)
 
 EnumValue
-Enum(avr_mcu) String(attiny261a) Value(31)
+Enum(avr_mcu) String(attiny261) Value(31)
 
 EnumValue
-Enum(avr_mcu) String(attiny461) Value(32)
+Enum(avr_mcu) String(attiny261a) Value(32)
 
 EnumValue
-Enum(avr_mcu) String(attiny461a) Value(33)
+Enum(avr_mcu) String(attiny461) Value(33)
 
 EnumValue
-Enum(avr_mcu) String(attiny861) Value(34)
+Enum(avr_mcu) String(attiny461a) Value(34)
 
 EnumValue
-Enum(avr_mcu) String(attiny861a) Value(35)
+Enum(avr_mcu) String(attiny861) Value(35)
 
 EnumValue
-Enum(avr_mcu) String(attiny43u) Value(36)
+Enum(avr_mcu) String(attiny861a) Value(36)
 
 EnumValue
-Enum(avr_mcu) String(attiny87) Value(37)
+Enum(avr_mcu) String(attiny43u) Value(37)
 
 EnumValue
-Enum(avr_mcu) String(attiny48) Value(38)
+Enum(avr_mcu) String(attiny87) Value(38)
 
 EnumValue
-Enum(avr_mcu) String(attiny88) Value(39)
+Enum(avr_mcu) String(attiny48) Value(39)
 
 EnumValue
-Enum(avr_mcu) String(at86rf401) Value(40)
+Enum(avr_mcu) String(attiny88) Value(40)
 
 EnumValue
-Enum(avr_mcu) String(avr3) Value(41)
+Enum(avr_mcu) String(attiny828) Value(41)
 
 EnumValue
-Enum(avr_mcu) String(at43usb355) Value(42)
+Enum(avr_mcu) String(attiny841) Value(42)
 
 EnumValue
-Enum(avr_mcu) String(at76c711) Value(43)
+Enum(avr_mcu) String(at86rf401) Value(43)
 
 EnumValue
-Enum(avr_mcu) String(avr31) Value(44)
+Enum(avr_mcu) String(avr3) Value(44)
 
 EnumValue
-Enum(avr_mcu) String(atmega103) Value(45)
+Enum(avr_mcu) String(at43usb355) Value(45)
 
 EnumValue
-Enum(avr_mcu) String(at43usb320) Value(46)
+Enum(avr_mcu) String(at76c711) Value(46)
 
 EnumValue
-Enum(avr_mcu) String(avr35) Value(47)
+Enum(avr_mcu) String(avr31) Value(47)
 
 EnumValue
-Enum(avr_mcu) String(ata5505) Value(48)
+Enum(avr_mcu) String(atmega103) Value(48)
 
 EnumValue
-Enum(avr_mcu) String(at90usb82) Value(49)
+Enum(avr_mcu) String(at43usb320) Value(49)
 
 EnumValue
-Enum(avr_mcu) String(at90usb162) Value(50)
+Enum(avr_mcu) String(avr35) Value(50)
 
 EnumValue
-Enum(avr_mcu) String(atmega8u2) Value(51)
+Enum(avr_mcu) String(ata5505) Value(51)
 
 EnumValue
-Enum(avr_mcu) String(atmega16u2) Value(52)
+Enum(avr_mcu) String(ata6617c) Value(52)
 
 EnumValue
-Enum(avr_mcu) String(atmega32u2) Value(53)
+Enum(avr_mcu) String(ata664251) Value(53)
 
 EnumValue
-Enum(avr_mcu) String(attiny167) Value(54)
+Enum(avr_mcu) String(at90usb82) Value(54)
 
 EnumValue
-Enum(avr_mcu) String(attiny1634) Value(55)
+Enum(avr_mcu) String(at90usb162) Value(55)
 
 EnumValue
-Enum(avr_mcu) String(avr4) Value(56)
+Enum(avr_mcu) String(atmega8u2) Value(56)
 
 EnumValue
-Enum(avr_mcu) String(ata6285) Value(57)
+Enum(avr_mcu) String(atmega16u2) Value(57)
 
 EnumValue
-Enum(avr_mcu) String(ata6286) Value(58)
+Enum(avr_mcu) String(atmega32u2) Value(58)
 
 EnumValue
-Enum(avr_mcu) String(atmega8) Value(59)
+Enum(avr_mcu) String(attiny167) Value(59)
 
 EnumValue
-Enum(avr_mcu) String(atmega8a) Value(60)
+Enum(avr_mcu) String(attiny1634) Value(60)
 
 EnumValue
-Enum(avr_mcu) String(atmega48) Value(61)
+Enum(avr_mcu) String(avr4) Value(61)
 
 EnumValue
-Enum(avr_mcu) String(atmega48a) Value(62)
+Enum(avr_mcu) String(ata6285) Value(62)
 
 EnumValue
-Enum(avr_mcu) String(atmega48p) Value(63)
+Enum(avr_mcu) String(ata6286) Value(63)
 
 EnumValue
-Enum(avr_mcu) String(atmega48pa) Value(64)
+Enum(avr_mcu) String(ata6289) Value(64)
 
 EnumValue
-Enum(avr_mcu) String(atmega88) Value(65)
+Enum(avr_mcu) String(ata6612c) Value(65)
 
 EnumValue
-Enum(avr_mcu) String(atmega88a) Value(66)
+Enum(avr_mcu) String(atmega8) Value(66)
 
 EnumValue
-Enum(avr_mcu) String(atmega88p) Value(67)
+Enum(avr_mcu) String(atmega8a) Value(67)
 
 EnumValue
-Enum(avr_mcu) String(atmega88pa) Value(68)
+Enum(avr_mcu) String(atmega48) Value(68)
 
 EnumValue
-Enum(avr_mcu) String(atmega8515) Value(69)
+Enum(avr_mcu) String(atmega48a) Value(69)
 
 EnumValue
-Enum(avr_mcu) String(atmega8535) Value(70)
+Enum(avr_mcu) String(atmega48p) Value(70)
 
 EnumValue
-Enum(avr_mcu) String(atmega8hva) Value(71)
+Enum(avr_mcu) String(atmega48pa) Value(71)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm1) Value(72)
+Enum(avr_mcu) String(atmega88) Value(72)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm2) Value(73)
+Enum(avr_mcu) String(atmega88a) Value(73)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm2b) Value(74)
+Enum(avr_mcu) String(atmega88p) Value(74)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm3) Value(75)
+Enum(avr_mcu) String(atmega88pa) Value(75)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm3b) Value(76)
+Enum(avr_mcu) String(atmega8515) Value(76)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm81) Value(77)
+Enum(avr_mcu) String(atmega8535) Value(77)
 
 EnumValue
-Enum(avr_mcu) String(avr5) Value(78)
+Enum(avr_mcu) String(atmega8hva) Value(78)
 
 EnumValue
-Enum(avr_mcu) String(ata5790) Value(79)
+Enum(avr_mcu) String(at90pwm1) Value(79)
 
 EnumValue
-Enum(avr_mcu) String(ata5790n) Value(80)
+Enum(avr_mcu) String(at90pwm2) Value(80)
 
 EnumValue
-Enum(avr_mcu) String(ata5795) Value(81)
+Enum(avr_mcu) String(at90pwm2b) Value(81)
 
 EnumValue
-Enum(avr_mcu) String(atmega16) Value(82)
+Enum(avr_mcu) String(at90pwm3) Value(82)
 
 EnumValue
-Enum(avr_mcu) String(atmega16a) Value(83)
+Enum(avr_mcu) String(at90pwm3b) Value(83)
 
 EnumValue
-Enum(avr_mcu) String(atmega161) Value(84)
+Enum(avr_mcu) String(at90pwm81) Value(84)
 
 EnumValue
-Enum(avr_mcu) String(atmega162) Value(85)
+Enum(avr_mcu) String(avr5) Value(85)
 
 EnumValue
-Enum(avr_mcu) String(atmega163) Value(86)
+Enum(avr_mcu) String(ata5790) Value(86)
 
 EnumValue
-Enum(avr_mcu) String(atmega164a) Value(87)
+Enum(avr_mcu) String(ata5790n) Value(87)
 
 EnumValue
-Enum(avr_mcu) String(atmega164p) Value(88)
+Enum(avr_mcu) String(ata5795) Value(88)
 
 EnumValue
-Enum(avr_mcu) String(atmega164pa) Value(89)
+Enum(avr_mcu) String(ata6613c) Value(89)
 
 EnumValue
-Enum(avr_mcu) String(atmega165) Value(90)
+Enum(avr_mcu) String(ata6614q) Value(90)
 
 EnumValue
-Enum(avr_mcu) String(atmega165a) Value(91)
+Enum(avr_mcu) String(atmega16) Value(91)
 
 EnumValue
-Enum(avr_mcu) String(atmega165p) Value(92)
+Enum(avr_mcu) String(atmega16a) Value(92)
 
 EnumValue
-Enum(avr_mcu) String(atmega165pa) Value(93)
+Enum(avr_mcu) String(atmega161) Value(93)
 
 EnumValue
-Enum(avr_mcu) String(atmega168) Value(94)
+Enum(avr_mcu) String(atmega162) Value(94)
 
 EnumValue
-Enum(avr_mcu) String(atmega168a) Value(95)
+Enum(avr_mcu) String(atmega163) Value(95)
 
 EnumValue
-Enum(avr_mcu) String(atmega168p) Value(96)
+Enum(avr_mcu) String(atmega164a) Value(96)
 
 EnumValue
-Enum(avr_mcu) String(atmega168pa) Value(97)
+Enum(avr_mcu) String(atmega164p) Value(97)
 
 EnumValue
-Enum(avr_mcu) String(atmega169) Value(98)
+Enum(avr_mcu) String(atmega164pa) Value(98)
 
 EnumValue
-Enum(avr_mcu) String(atmega169a) Value(99)
+Enum(avr_mcu) String(atmega165) Value(99)
 
 EnumValue
-Enum(avr_mcu) String(atmega169p) Value(100)
+Enum(avr_mcu) String(atmega165a) Value(100)
 
 EnumValue
-Enum(avr_mcu) String(atmega169pa) Value(101)
+Enum(avr_mcu) String(atmega165p) Value(101)
 
 EnumValue
-Enum(avr_mcu) String(atmega16hva) Value(102)
+Enum(avr_mcu) String(atmega165pa) Value(102)
 
 EnumValue
-Enum(avr_mcu) String(atmega16hvb) Value(103)
+Enum(avr_mcu) String(atmega168) Value(103)
 
 EnumValue
-Enum(avr_mcu) String(atmega16hvbrevb) Value(104)
+Enum(avr_mcu) String(atmega168a) Value(104)
 
 EnumValue
-Enum(avr_mcu) String(atmega16m1) Value(105)
+Enum(avr_mcu) String(atmega168p) Value(105)
 
 EnumValue
-Enum(avr_mcu) String(atmega16u4) Value(106)
+Enum(avr_mcu) String(atmega168pa) Value(106)
 
 EnumValue
-Enum(avr_mcu) String(atmega26hvg) Value(107)
+Enum(avr_mcu) String(atmega169) Value(107)
 
 EnumValue
-Enum(avr_mcu) String(atmega32a) Value(108)
+Enum(avr_mcu) String(atmega169a) Value(108)
 
 EnumValue
-Enum(avr_mcu) String(atmega32) Value(109)
+Enum(avr_mcu) String(atmega169p) Value(109)
 
 EnumValue
-Enum(avr_mcu) String(atmega32a) Value(110)
+Enum(avr_mcu) String(atmega169pa) Value(110)
 
 EnumValue
-Enum(avr_mcu) String(atmega323) Value(111)
+Enum(avr_mcu) String(atmega16hvb) Value(111)
 
 EnumValue
-Enum(avr_mcu) String(atmega324a) Value(112)
+Enum(avr_mcu) String(atmega16hvbrevb) Value(112)
 
 EnumValue
-Enum(avr_mcu) String(atmega324p) Value(113)
+Enum(avr_mcu) String(atmega16m1) Value(113)
 
 EnumValue
-Enum(avr_mcu) String(atmega324pa) Value(114)
+Enum(avr_mcu) String(atmega16u4) Value(114)
 
 EnumValue
-Enum(avr_mcu) String(atmega325) Value(115)
+Enum(avr_mcu) String(atmega32a) Value(115)
 
 EnumValue
-Enum(avr_mcu) String(atmega325a) Value(116)
+Enum(avr_mcu) String(atmega32) Value(116)
 
 EnumValue
-Enum(avr_mcu) String(atmega325p) Value(117)
+Enum(avr_mcu) String(atmega323) Value(117)
 
 EnumValue
-Enum(avr_mcu) String(atmega3250) Value(118)
+Enum(avr_mcu) String(atmega324a) Value(118)
 
 EnumValue
-Enum(avr_mcu) String(atmega3250a) Value(119)
+Enum(avr_mcu) String(atmega324p) Value(119)
 
 EnumValue
-Enum(avr_mcu) String(atmega3250p) Value(120)
+Enum(avr_mcu) String(atmega324pa) Value(120)
 
 EnumValue
-Enum(avr_mcu) String(atmega3250pa) Value(121)
+Enum(avr_mcu) String(atmega325) Value(121)
 
 EnumValue
-Enum(avr_mcu) String(atmega328) Value(122)
+Enum(avr_mcu) String(atmega325a) Value(122)
 
 EnumValue
-Enum(avr_mcu) String(atmega328p) Value(123)
+Enum(avr_mcu) String(atmega325p) Value(123)
 
 EnumValue
-Enum(avr_mcu) String(atmega329) Value(124)
+Enum(avr_mcu) String(atmega325pa) Value(124)
 
 EnumValue
-Enum(avr_mcu) String(atmega329a) Value(125)
+Enum(avr_mcu) String(atmega3250) Value(125)
 
 EnumValue
-Enum(avr_mcu) String(atmega329p) Value(126)
+Enum(avr_mcu) String(atmega3250a) Value(126)
 
 EnumValue
-Enum(avr_mcu) String(atmega329pa) Value(127)
+Enum(avr_mcu) String(atmega3250p) Value(127)
 
 EnumValue
-Enum(avr_mcu) String(atmega3290) Value(128)
+Enum(avr_mcu) String(atmega3250pa) Value(128)
 
 EnumValue
-Enum(avr_mcu) String(atmega3290a) Value(129)
+Enum(avr_mcu) String(atmega328) Value(129)
 
 EnumValue
-Enum(avr_mcu) String(atmega3290p) Value(130)
+Enum(avr_mcu) String(atmega328p) Value(130)
 
 EnumValue
-Enum(avr_mcu) String(atmega3290pa) Value(131)
+Enum(avr_mcu) String(atmega329) Value(131)
 
 EnumValue
-Enum(avr_mcu) String(atmega32c1) Value(132)
+Enum(avr_mcu) String(atmega329a) Value(132)
 
 EnumValue
-Enum(avr_mcu) String(atmega32m1) Value(133)
+Enum(avr_mcu) String(atmega329p) Value(133)
 
 EnumValue
-Enum(avr_mcu) String(atmega32u4) Value(134)
+Enum(avr_mcu) String(atmega329pa) Value(134)
 
 EnumValue
-Enum(avr_mcu) String(atmega32u6) Value(135)
+Enum(avr_mcu) String(atmega3290) Value(135)
 
 EnumValue
-Enum(avr_mcu) String(atmega406) Value(136)
+Enum(avr_mcu) String(atmega3290a) Value(136)
 
 EnumValue
-Enum(avr_mcu) String(atmega64) Value(137)
+Enum(avr_mcu) String(atmega3290p) Value(137)
 
 EnumValue
-Enum(avr_mcu) String(atmega64a) Value(138)
+Enum(avr_mcu) String(atmega3290pa) Value(138)
 
 EnumValue
-Enum(avr_mcu) String(atmega640) Value(139)
+Enum(avr_mcu) String(atmega32c1) Value(139)
 
 EnumValue
-Enum(avr_mcu) String(atmega644) Value(140)
+Enum(avr_mcu) String(atmega32m1) Value(140)
 
 EnumValue
-Enum(avr_mcu) String(atmega644a) Value(141)
+Enum(avr_mcu) String(atmega32u4) Value(141)
 
 EnumValue
-Enum(avr_mcu) String(atmega644p) Value(142)
+Enum(avr_mcu) String(atmega32u6) Value(142)
 
 EnumValue
-Enum(avr_mcu) String(atmega644pa) Value(143)
+Enum(avr_mcu) String(atmega406) Value(143)
 
 EnumValue
-Enum(avr_mcu) String(atmega645) Value(144)
+Enum(avr_mcu) String(atmega64) Value(144)
 
 EnumValue
-Enum(avr_mcu) String(atmega645a) Value(145)
+Enum(avr_mcu) String(atmega64a) Value(145)
 
 EnumValue
-Enum(avr_mcu) String(atmega645p) Value(146)
+Enum(avr_mcu) String(atmega640) Value(146)
 
 EnumValue
-Enum(avr_mcu) String(atmega6450) Value(147)
+Enum(avr_mcu) String(atmega644) Value(147)
 
 EnumValue
-Enum(avr_mcu) String(atmega6450a) Value(148)
+Enum(avr_mcu) String(atmega644a) Value(148)
 
 EnumValue
-Enum(avr_mcu) String(atmega6450p) Value(149)
+Enum(avr_mcu) String(atmega644p) Value(149)
 
 EnumValue
-Enum(avr_mcu) String(atmega649) Value(150)
+Enum(avr_mcu) String(atmega644pa) Value(150)
 
 EnumValue
-Enum(avr_mcu) String(atmega649a) Value(151)
+Enum(avr_mcu) String(atmega645) Value(151)
 
 EnumValue
-Enum(avr_mcu) String(atmega649p) Value(152)
+Enum(avr_mcu) String(atmega645a) Value(152)
 
 EnumValue
-Enum(avr_mcu) String(atmega6490) Value(153)
+Enum(avr_mcu) String(atmega645p) Value(153)
 
 EnumValue
-Enum(avr_mcu) String(atmega16hva) Value(154)
+Enum(avr_mcu) String(atmega6450) Value(154)
 
 EnumValue
-Enum(avr_mcu) String(atmega16hva2) Value(155)
+Enum(avr_mcu) String(atmega6450a) Value(155)
 
 EnumValue
-Enum(avr_mcu) String(atmega16hvb) Value(156)
+Enum(avr_mcu) String(atmega6450p) Value(156)
 
 EnumValue
-Enum(avr_mcu) String(atmega32hvb) Value(157)
+Enum(avr_mcu) String(atmega649) Value(157)
 
 EnumValue
-Enum(avr_mcu) String(atmega6490a) Value(158)
+Enum(avr_mcu) String(atmega649a) Value(158)
 
 EnumValue
-Enum(avr_mcu) String(atmega6490p) Value(159)
+Enum(avr_mcu) String(atmega649p) Value(159)
 
 EnumValue
-Enum(avr_mcu) String(atmega64c1) Value(160)
+Enum(avr_mcu) String(atmega6490) Value(160)
 
 EnumValue
-Enum(avr_mcu) String(atmega64m1) Value(161)
+Enum(avr_mcu) String(atmega16hva) Value(161)
 
 EnumValue
-Enum(avr_mcu) String(atmega64hve) Value(162)
+Enum(avr_mcu) String(atmega16hva2) Value(162)
 
 EnumValue
-Enum(avr_mcu) String(atmega64rfa2) Value(163)
+Enum(avr_mcu) String(atmega32hvb) Value(163)
 
 EnumValue
-Enum(avr_mcu) String(atmega64rfr2) Value(164)
+Enum(avr_mcu) String(atmega6490a) Value(164)
 
 EnumValue
-Enum(avr_mcu) String(atmega32hvb) Value(165)
+Enum(avr_mcu) String(atmega6490p) Value(165)
 
 EnumValue
-Enum(avr_mcu) String(atmega32hvbrevb) Value(166)
+Enum(avr_mcu) String(atmega64c1) Value(166)
 
 EnumValue
-Enum(avr_mcu) String(atmega16hva2) Value(167)
+Enum(avr_mcu) String(atmega64m1) Value(167)
 
 EnumValue
-Enum(avr_mcu) String(atmega48hvf) Value(168)
+Enum(avr_mcu) String(atmega64hve) Value(168)
 
 EnumValue
-Enum(avr_mcu) String(at90can32) Value(169)
+Enum(avr_mcu) String(atmega64hve2) Value(169)
 
 EnumValue
-Enum(avr_mcu) String(at90can64) Value(170)
+Enum(avr_mcu) String(atmega64rfr2) Value(170)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm161) Value(171)
+Enum(avr_mcu) String(atmega644rfr2) Value(171)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm216) Value(172)
+Enum(avr_mcu) String(atmega32hvbrevb) Value(172)
 
 EnumValue
-Enum(avr_mcu) String(at90pwm316) Value(173)
+Enum(avr_mcu) String(at90can32) Value(173)
 
 EnumValue
-Enum(avr_mcu) String(atmega32c1) Value(174)
+Enum(avr_mcu) String(at90can64) Value(174)
 
 EnumValue
-Enum(avr_mcu) String(atmega64c1) Value(175)
+Enum(avr_mcu) String(at90pwm161) Value(175)
 
 EnumValue
-Enum(avr_mcu) String(atmega16m1) Value(176)
+Enum(avr_mcu) String(at90pwm216) Value(176)
 
 EnumValue
-Enum(avr_mcu) String(atmega32m1) Value(177)
+Enum(avr_mcu) String(at90pwm316) Value(177)
 
 EnumValue
-Enum(avr_mcu) String(atmega64m1) Value(178)
+Enum(avr_mcu) String(at90scr100) Value(178)
 
 EnumValue
-Enum(avr_mcu) String(atmega16u4) Value(179)
+Enum(avr_mcu) String(at90usb646) Value(179)
 
 EnumValue
-Enum(avr_mcu) String(atmega32u4) Value(180)
+Enum(avr_mcu) String(at90usb647) Value(180)
 
 EnumValue
-Enum(avr_mcu) String(atmega32u6) Value(181)
+Enum(avr_mcu) String(at94k) Value(181)
 
 EnumValue
-Enum(avr_mcu) String(at90scr100) Value(182)
+Enum(avr_mcu) String(m3000) Value(182)
 
 EnumValue
-Enum(avr_mcu) String(at90usb646) Value(183)
+Enum(avr_mcu) String(avr51) Value(183)
 
 EnumValue
-Enum(avr_mcu) String(at90usb647) Value(184)
+Enum(avr_mcu) String(atmega128) Value(184)
 
 EnumValue
-Enum(avr_mcu) String(at94k) Value(185)
+Enum(avr_mcu) String(atmega128a) Value(185)
 
 EnumValue
-Enum(avr_mcu) String(m3000) Value(186)
+Enum(avr_mcu) String(atmega1280) Value(186)
 
 EnumValue
-Enum(avr_mcu) String(avr51) Value(187)
+Enum(avr_mcu) String(atmega1281) Value(187)
 
 EnumValue
-Enum(avr_mcu) String(atmega128) Value(188)
+Enum(avr_mcu) String(atmega1284) Value(188)
 
 EnumValue
-Enum(avr_mcu) String(atmega128a) Value(189)
+Enum(avr_mcu) String(atmega1284p) Value(189)
 
 EnumValue
-Enum(avr_mcu) String(atmega1280) Value(190)
+Enum(avr_mcu) String(atmega128rfa1) Value(190)
 
 EnumValue
-Enum(avr_mcu) String(atmega1281) Value(191)
+Enum(avr_mcu) String(atmega128rfr2) Value(191)
 
 EnumValue
-Enum(avr_mcu) String(atmega1284) Value(192)
+Enum(avr_mcu) String(atmega1284rfr2) Value(192)
 
 EnumValue
-Enum(avr_mcu) String(atmega1284p) Value(193)
+Enum(avr_mcu) String(at90can128) Value(193)
 
 EnumValue
-Enum(avr_mcu) String(atmega128rfa1) Value(194)
+Enum(avr_mcu) String(at90usb1286) Value(194)
 
 EnumValue
-Enum(avr_mcu) String(at90can128) Value(195)
+Enum(avr_mcu) String(at90usb1287) Value(195)
 
 EnumValue
-Enum(avr_mcu) String(at90usb1286) Value(196)
+Enum(avr_mcu) String(avr6) Value(196)
 
 EnumValue
-Enum(avr_mcu) String(at90usb1287) Value(197)
+Enum(avr_mcu) String(atmega2560) Value(197)
 
 EnumValue
-Enum(avr_mcu) String(avr6) Value(198)
+Enum(avr_mcu) String(atmega2561) Value(198)
 
 EnumValue
-Enum(avr_mcu) String(atmega2560) Value(199)
+Enum(avr_mcu) String(atmega256rfr2) Value(199)
 
 EnumValue
-Enum(avr_mcu) String(atmega2561) Value(200)
+Enum(avr_mcu) String(atmega2564rfr2) Value(200)
 
 EnumValue
-Enum(avr_mcu) String(avrxmega2) Value(201)
+Enum(avr_mcu) String(avr7) Value(201)
 
 EnumValue
-Enum(avr_mcu) String(atxmega16a4) Value(202)
+Enum(avr_mcu) String(ata5831) Value(202)
 
 EnumValue
-Enum(avr_mcu) String(atxmega16d4) Value(203)
+Enum(avr_mcu) String(avrxmega2) Value(203)
 
 EnumValue
-Enum(avr_mcu) String(atxmega16x1) Value(204)
+Enum(avr_mcu) String(atxmega8e5) Value(204)
 
 EnumValue
-Enum(avr_mcu) String(atxmega32a4) Value(205)
+Enum(avr_mcu) String(atxmega16a4) Value(205)
 
 EnumValue
-Enum(avr_mcu) String(atxmega32d4) Value(206)
+Enum(avr_mcu) String(atxmega16a4u) Value(206)
 
 EnumValue
-Enum(avr_mcu) String(atxmega32x1) Value(207)
+Enum(avr_mcu) String(atxmega16c4) Value(207)
 
 EnumValue
-Enum(avr_mcu) String(atmxt112sl) Value(208)
+Enum(avr_mcu) String(atxmega16d4) Value(208)
 
 EnumValue
-Enum(avr_mcu) String(atmxt224) Value(209)
+Enum(avr_mcu) String(atxmega16e5) Value(209)
 
 EnumValue
-Enum(avr_mcu) String(atmxt224e) Value(210)
+Enum(avr_mcu) String(atxmega16x1) Value(210)
 
 EnumValue
-Enum(avr_mcu) String(atmxt336s) Value(211)
+Enum(avr_mcu) String(atxmega32a4) Value(211)
 
 EnumValue
-Enum(avr_mcu) String(atxmega16a4u) Value(212)
+Enum(avr_mcu) String(atxmega32a4u) Value(212)
 
 EnumValue
-Enum(avr_mcu) String(atxmega16c4) Value(213)
+Enum(avr_mcu) String(atxmega32c3) Value(213)
 
 EnumValue
-Enum(avr_mcu) String(atxmega32a4u) Value(214)
+Enum(avr_mcu) String(atxmega32c4) Value(214)
 
 EnumValue
-Enum(avr_mcu) String(atxmega32c4) Value(215)
+Enum(avr_mcu) String(atxmega32d3) Value(215)
 
 EnumValue
-Enum(avr_mcu) String(atxmega32e5) Value(216)
+Enum(avr_mcu) String(atxmega32d4) Value(216)
 
 EnumValue
-Enum(avr_mcu) String(avrxmega4) Value(217)
+Enum(avr_mcu) String(atxmega32e5) Value(217)
 
 EnumValue
-Enum(avr_mcu) String(atxmega64a3) Value(218)
+Enum(avr_mcu) String(avrxmega4) Value(218)
 
 EnumValue
-Enum(avr_mcu) String(atxmega64d3) Value(219)
+Enum(avr_mcu) String(atxmega64a3) Value(219)
 
 EnumValue
 Enum(avr_mcu) String(atxmega64a3u) Value(220)
@@ -699,110 +699,128 @@ EnumValue
 Enum(avr_mcu) String(atxmega64c3) Value(224)
 
 EnumValue
-Enum(avr_mcu) String(atxmega64d4) Value(225)
+Enum(avr_mcu) String(atxmega64d3) Value(225)
 
 EnumValue
-Enum(avr_mcu) String(avrxmega5) Value(226)
+Enum(avr_mcu) String(atxmega64d4) Value(226)
 
 EnumValue
-Enum(avr_mcu) String(atxmega64a1) Value(227)
+Enum(avr_mcu) String(avrxmega5) Value(227)
 
 EnumValue
-Enum(avr_mcu) String(atxmega64a1u) Value(228)
+Enum(avr_mcu) String(atxmega64a1) Value(228)
 
 EnumValue
-Enum(avr_mcu) String(avrxmega6) Value(229)
+Enum(avr_mcu) String(atxmega64a1u) Value(229)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128a3) Value(230)
+Enum(avr_mcu) String(avrxmega6) Value(230)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128d3) Value(231)
+Enum(avr_mcu) String(atxmega128a3) Value(231)
 
 EnumValue
-Enum(avr_mcu) String(atxmega192a3) Value(232)
+Enum(avr_mcu) String(atxmega128a3u) Value(232)
 
 EnumValue
-Enum(avr_mcu) String(atxmega192d3) Value(233)
+Enum(avr_mcu) String(atxmega128b1) Value(233)
 
 EnumValue
-Enum(avr_mcu) String(atxmega256a3) Value(234)
+Enum(avr_mcu) String(atxmega128b3) Value(234)
 
 EnumValue
-Enum(avr_mcu) String(atxmega256a3b) Value(235)
+Enum(avr_mcu) String(atxmega128c3) Value(235)
 
 EnumValue
-Enum(avr_mcu) String(atxmega256a3bu) Value(236)
+Enum(avr_mcu) String(atxmega128d3) Value(236)
 
 EnumValue
-Enum(avr_mcu) String(atxmega256d3) Value(237)
+Enum(avr_mcu) String(atxmega128d4) Value(237)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128a3u) Value(238)
+Enum(avr_mcu) String(atxmega192a3) Value(238)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128b1) Value(239)
+Enum(avr_mcu) String(atxmega192a3u) Value(239)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128b3) Value(240)
+Enum(avr_mcu) String(atxmega192c3) Value(240)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128c3) Value(241)
+Enum(avr_mcu) String(atxmega192d3) Value(241)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128d4) Value(242)
+Enum(avr_mcu) String(atxmega256a3) Value(242)
 
 EnumValue
-Enum(avr_mcu) String(atmxt540s) Value(243)
+Enum(avr_mcu) String(atxmega256a3b) Value(243)
 
 EnumValue
-Enum(avr_mcu) String(atmxt540sreva) Value(244)
+Enum(avr_mcu) String(atxmega256a3bu) Value(244)
 
 EnumValue
-Enum(avr_mcu) String(atxmega192a3u) Value(245)
+Enum(avr_mcu) String(atxmega256a3u) Value(245)
 
 EnumValue
-Enum(avr_mcu) String(atxmega192c3) Value(246)
+Enum(avr_mcu) String(atxmega256c3) Value(246)
 
 EnumValue
-Enum(avr_mcu) String(atxmega256a3u) Value(247)
+Enum(avr_mcu) String(atxmega256d3) Value(247)
 
 EnumValue
-Enum(avr_mcu) String(atxmega256c3) Value(248)
+Enum(avr_mcu) String(atxmega384c3) Value(248)
 
 EnumValue
-Enum(avr_mcu) String(atxmega384c3) Value(249)
+Enum(avr_mcu) String(atxmega384d3) Value(249)
 
 EnumValue
-Enum(avr_mcu) String(atxmega384d3) Value(250)
+Enum(avr_mcu) String(avrxmega7) Value(250)
 
 EnumValue
-Enum(avr_mcu) String(avrxmega7) Value(251)
+Enum(avr_mcu) String(atxmega128a1) Value(251)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128a1) Value(252)
+Enum(avr_mcu) String(atxmega128a1u) Value(252)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128a1u) Value(253)
+Enum(avr_mcu) String(atxmega128a4u) Value(253)
 
 EnumValue
-Enum(avr_mcu) String(atxmega128a4u) Value(254)
+Enum(avr_mcu) String(avrtiny) Value(254)
 
 EnumValue
-Enum(avr_mcu) String(avr1) Value(255)
+Enum(avr_mcu) String(attiny4) Value(255)
 
 EnumValue
-Enum(avr_mcu) String(at90s1200) Value(256)
+Enum(avr_mcu) String(attiny5) Value(256)
 
 EnumValue
-Enum(avr_mcu) String(attiny11) Value(257)
+Enum(avr_mcu) String(attiny9) Value(257)
 
 EnumValue
-Enum(avr_mcu) String(attiny12) Value(258)
+Enum(avr_mcu) String(attiny10) Value(258)
 
 EnumValue
-Enum(avr_mcu) String(attiny15) Value(259)
+Enum(avr_mcu) String(attiny20) Value(259)
 
 EnumValue
-Enum(avr_mcu) String(attiny28) Value(260)
+Enum(avr_mcu) String(attiny40) Value(260)
+
+EnumValue
+Enum(avr_mcu) String(avr1) Value(261)
+
+EnumValue
+Enum(avr_mcu) String(at90s1200) Value(262)
+
+EnumValue
+Enum(avr_mcu) String(attiny11) Value(263)
+
+EnumValue
+Enum(avr_mcu) String(attiny12) Value(264)
+
+EnumValue
+Enum(avr_mcu) String(attiny15) Value(265)
+
+EnumValue
+Enum(avr_mcu) String(attiny28) Value(266)
 
diff --git gcc/config/avr/avr.c gcc/config/avr/avr.c
index c916d6b..105c6e9 100644
--- gcc/config/avr/avr.c
+++ gcc/config/avr/avr.c
@@ -77,6 +77,17 @@
   ((SYMBOL_REF_FLAGS (sym) & AVR_SYMBOL_FLAG_PROGMEM)           \
    / SYMBOL_FLAG_MACH_DEP)
 
+#define TINY_ADIW(REG1, REG2, I)                                \
+    "subi " #REG1 ",lo8(-(" #I "))" CR_TAB                        \
+    "sbci " #REG2 ",hi8(-(" #I "))"        
+
+#define TINY_SBIW(REG1, REG2, I)                                \
+    "subi " #REG1 ",lo8((" #I "))" CR_TAB                         \
+    "sbci " #REG2 ",hi8((" #I "))"        
+
+#define AVR_TMP_REGNO (AVR_TINY ? TMP_REGNO_TINY : TMP_REGNO)
+#define AVR_ZERO_REGNO (AVR_TINY ? ZERO_REGNO_TINY : ZERO_REGNO)
+
 /* Known address spaces.  The order must be the same as in the respective
    enum from avr.h (or designated initialized must be used).  */
 const avr_addrspace_t avr_addrspace[ADDR_SPACE_COUNT] =
@@ -145,6 +156,9 @@ static bool avr_rtx_costs (rtx, int, int, int, int*, bool);
 /* Allocate registers from r25 to r8 for parameters for function calls.  */
 #define FIRST_CUM_REG 26
 
+/* Last call saved register */
+#define LAST_CALLEE_SAVED_REG (AVR_TINY ? 19 : 17)
+
 /* Implicit target register of LPM instruction (R0) */
 extern GTY(()) rtx lpm_reg_rtx;
 rtx lpm_reg_rtx;
@@ -324,7 +338,7 @@ avr_option_override (void)
   avr_addr.rampy = 0x3A + avr_current_arch->sfr_offset;
   avr_addr.rampx = 0x39 + avr_current_arch->sfr_offset;
   avr_addr.rampd = 0x38 + avr_current_arch->sfr_offset;
-  avr_addr.ccp = 0x34 + avr_current_arch->sfr_offset;
+  avr_addr.ccp = (AVR_TINY ? 0x3C : 0x34) + avr_current_arch->sfr_offset;
 
   /* SP: Stack Pointer (SP_H:SP_L) */
   avr_addr.sp_l = 0x3D + avr_current_arch->sfr_offset;
@@ -332,6 +346,9 @@ avr_option_override (void)
 
   init_machine_status = avr_init_machine_status;
 
+  if (!global_options_set.x_dwarf_version)
+    dwarf_version = 2;
+
   avr_log_set_avr_log();
 }
 
@@ -356,8 +373,8 @@ avr_init_expanders (void)
     all_regs_rtx[regno] = gen_rtx_REG (QImode, regno);
 
   lpm_reg_rtx  = all_regs_rtx[LPM_REGNO];
-  tmp_reg_rtx  = all_regs_rtx[TMP_REGNO];
-  zero_reg_rtx = all_regs_rtx[ZERO_REGNO];
+  tmp_reg_rtx  = all_regs_rtx[AVR_TMP_REGNO];
+  zero_reg_rtx = all_regs_rtx[AVR_ZERO_REGNO];
 
   lpm_addr_reg_rtx = gen_rtx_REG (HImode, REG_Z);
 
@@ -369,6 +386,11 @@ avr_init_expanders (void)
 
   xstring_empty = gen_rtx_CONST_STRING (VOIDmode, "");
   xstring_e = gen_rtx_CONST_STRING (VOIDmode, "e");
+
+  /* TINY core does not have regs r10-r16, but avr-dimode.md expects them
+     to be present */
+  if (AVR_TINY)
+    avr_have_dimode = false; 
 }
 
 
@@ -514,6 +536,15 @@ avr_interrupt_function_p (tree func)
   return avr_lookup_function_attribute1 (func, "interrupt");
 }
 
+/* Return nonzero if FUNC is an nmi function as specified
+   by the "nmi" attribute.  */
+
+static int
+avr_nmi_function_p (tree func)
+{
+  return avr_lookup_function_attribute1 (func, "nmi");
+}
+
 /* Return nonzero if FUNC is a signal function as specified
    by the "signal" attribute.  */
 
@@ -561,15 +592,22 @@ avr_set_current_function (tree decl)
   cfun->machine->is_naked = avr_naked_function_p (decl);
   cfun->machine->is_signal = avr_signal_function_p (decl);
   cfun->machine->is_interrupt = avr_interrupt_function_p (decl);
+  cfun->machine->is_nmi = avr_nmi_function_p (decl);
   cfun->machine->is_OS_task = avr_OS_task_function_p (decl);
   cfun->machine->is_OS_main = avr_OS_main_function_p (decl);
 
-  isr = cfun->machine->is_interrupt ? "interrupt" : "signal";
+  if (cfun->machine->is_interrupt)
+    isr = "interrupt";
+  else if (cfun->machine->is_nmi)
+    isr = "nmi";
+  else
+    isr = "signal";
 
   /* Too much attributes make no sense as they request conflicting features. */
 
   if (cfun->machine->is_OS_task + cfun->machine->is_OS_main
-      + (cfun->machine->is_signal || cfun->machine->is_interrupt) > 1)
+      + (cfun->machine->is_signal || cfun->machine->is_interrupt 
+          || cfun->machine->is_nmi) > 1)
     error_at (loc, "function attributes %qs, %qs and %qs are mutually"
                " exclusive", "OS_task", "OS_main", isr);
 
@@ -580,11 +618,17 @@ avr_set_current_function (tree decl)
     warning_at (loc, OPT_Wattributes, "function attributes %qs and %qs have"
                 " no effect on %qs function", "OS_task", "OS_main", "naked");
 
-  if (cfun->machine->is_interrupt || cfun->machine->is_signal)
+  if (cfun->machine->is_interrupt || cfun->machine->is_signal 
+          || cfun->machine->is_nmi)
     {
       tree args = TYPE_ARG_TYPES (TREE_TYPE (decl));
       tree ret = TREE_TYPE (TREE_TYPE (decl));
-      const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));
+      const char *name;
+
+      name = DECL_ASSEMBLER_NAME_SET_P (decl)
+        /* Remove the leading '*' added in set_user_assembler_name.  */
+        ? 1 + IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))
+        : IDENTIFIER_POINTER (DECL_NAME (decl));
 
       /* Silently ignore 'signal' if 'interrupt' is present.  AVR-LibC startet
          using this when it switched from SIGNAL and INTERRUPT to ISR.  */
@@ -871,7 +915,7 @@ sequent_regs_live (void)
   int live_seq = 0;
   int cur_seq = 0;
 
-  for (reg = 0; reg < 18; ++reg)
+  for (reg = 0; reg <= LAST_CALLEE_SAVED_REG; ++reg)
     {
       if (fixed_regs[reg])
         {
@@ -983,7 +1027,7 @@ emit_push_sfr (rtx sfr, bool frame_related_p, bool clr_p)
     RTX_FRAME_RELATED_P (insn) = 1;
 
   /* PUSH __tmp_reg__ */
-  emit_push_byte (TMP_REGNO, frame_related_p);
+  emit_push_byte (AVR_TMP_REGNO, frame_related_p);
 
   if (clr_p)
     {
@@ -1009,7 +1053,8 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)
                    && live_seq
                    && !isr_p
                    && !cfun->machine->is_OS_task
-                   && !cfun->machine->is_OS_main);
+                   && !cfun->machine->is_OS_main
+                   && !AVR_TINY);
 
   if (minimize
       && (frame_pointer_needed
@@ -1046,11 +1091,11 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)
       /* Note that live_seq always contains r28+r29, but the other
          registers to be saved are all below 18.  */
 
-      first_reg = 18 - (live_seq - 2);
+      first_reg = (LAST_CALLEE_SAVED_REG + 1) - (live_seq - 2);
 
       for (reg = 29, offset = -live_seq + 1;
            reg >= first_reg;
-           reg = (reg == 28 ? 17 : reg - 1), ++offset)
+           reg = (reg == 28 ? LAST_CALLEE_SAVED_REG : reg - 1), ++offset)
         {
           rtx m, r;
 
@@ -1112,7 +1157,7 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)
               leaf function and thus X has already been saved.  */
 
           int irq_state = -1;
-          HOST_WIDE_INT size_cfa = size;
+          HOST_WIDE_INT size_cfa = size, neg_size;
           rtx fp_plus_insns, fp, my_fp;
 
           gcc_assert (frame_pointer_needed
@@ -1151,6 +1196,7 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)
             }
 
           size = trunc_int_for_mode (size, GET_MODE (my_fp));
+          neg_size = trunc_int_for_mode (-size, GET_MODE (my_fp));
 
           /************  Method 1: Adjust frame pointer  ************/
 
@@ -1171,7 +1217,8 @@ avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)
             }
 
           insn = emit_move_insn (my_fp, plus_constant (GET_MODE (my_fp),
-                                                       my_fp, -size));
+                                                       my_fp, neg_size));
+
           if (frame_pointer_needed)
             {
               RTX_FRAME_RELATED_P (insn) = 1;
@@ -1287,10 +1334,10 @@ avr_expand_prologue (void)
         emit_insn (gen_enable_interrupt ());
 
       /* Push zero reg.  */
-      emit_push_byte (ZERO_REGNO, true);
+      emit_push_byte (AVR_ZERO_REGNO, true);
 
       /* Push tmp reg.  */
-      emit_push_byte (TMP_REGNO, true);
+      emit_push_byte (AVR_TMP_REGNO, true);
 
       /* Push SREG.  */
       /* ??? There's no dwarf2 column reserved for SREG.  */
@@ -1432,7 +1479,8 @@ avr_expand_epilogue (bool sibcall_p)
               && live_seq
               && !isr_p
               && !cfun->machine->is_OS_task
-              && !cfun->machine->is_OS_main);
+              && !cfun->machine->is_OS_main
+              && !AVR_TINY);
 
   if (minimize
       && (live_seq > 4
@@ -1590,14 +1638,14 @@ avr_expand_epilogue (bool sibcall_p)
 
       /* Restore SREG using tmp_reg as scratch.  */
 
-      emit_pop_byte (TMP_REGNO);
+      emit_pop_byte (AVR_TMP_REGNO);
       emit_move_insn (sreg_rtx, tmp_reg_rtx);
 
       /* Restore tmp REG.  */
-      emit_pop_byte (TMP_REGNO);
+      emit_pop_byte (AVR_TMP_REGNO);
 
       /* Restore zero REG.  */
-      emit_pop_byte (ZERO_REGNO);
+      emit_pop_byte (AVR_ZERO_REGNO);
     }
 
   if (!sibcall_p)
@@ -2079,10 +2127,14 @@ avr_print_operand_punct_valid_p (unsigned char code)
 static void
 avr_print_operand (FILE *file, rtx x, int code)
 {
-  int abcd = 0;
+  int abcd = 0, ef = 0, ij = 0;
 
   if (code >= 'A' && code <= 'D')
     abcd = code - 'A';
+  else if (code == 'E' || code == 'F')
+    ef = code - 'E';
+  else if (code == 'I' || code == 'J')
+    ij = code - 'I';
 
   if (code == '~')
     {
@@ -2119,6 +2171,16 @@ avr_print_operand (FILE *file, rtx x, int code)
       else
         fatal_insn ("operands to %T/%t must be reg + const_int:", x);
     }
+  else if (code == 'E' || code == 'F')
+    {
+      rtx op = XEXP(x, 0);
+      fprintf (file, reg_names[REGNO (op) + ef]);
+    }
+  else if (code == 'I' || code == 'J')
+    {
+      rtx op = XEXP(XEXP(x, 0), 0);
+      fprintf (file, reg_names[REGNO (op) + ij]);
+    }
   else if (REG_P (x))
     {
       if (x == zero_reg_rtx)
@@ -2145,7 +2207,7 @@ avr_print_operand (FILE *file, rtx x, int code)
             fprintf (file, "__RAMPX__");
           else if (AVR_HAVE_RAMPD && ival == avr_addr.rampd)
             fprintf (file, "__RAMPD__");
-          else if (AVR_XMEGA && ival == avr_addr.ccp)
+          else if ((AVR_XMEGA || AVR_TINY) && ival == avr_addr.ccp)
             fprintf (file, "__CCP__");
           else if (ival == avr_addr.sreg)   fprintf (file, "__SREG__");
           else if (ival == avr_addr.sp_l)   fprintf (file, "__SP_L__");
@@ -2188,6 +2250,13 @@ avr_print_operand (FILE *file, rtx x, int code)
 
           avr_print_operand (file, XEXP (addr, 1), 0);
         }
+      else if (code == 'b')
+        {
+          if (GET_CODE (addr) != PLUS)
+               fatal_insn ("bad address, not (reg+disp):", addr);
+
+          avr_print_operand_address (file, XEXP (addr, 0));
+        }
       else if (code == 'p' || code == 'r')
         {
           if (GET_CODE (addr) != POST_INC && GET_CODE (addr) != PRE_DEC)
@@ -2535,7 +2604,7 @@ avr_simplify_comparison_p (enum machine_mode mode, RTX_CODE op, rtx x)
 int
 avr_function_arg_regno_p(int r)
 {
-  return (r >= 8 && r <= 25);
+  return (AVR_TINY ? r >= 20 && r <= 25 : r >= 8 && r <= 25);
 }
 
 
@@ -2547,7 +2616,7 @@ void
 avr_init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, rtx libname,
                           tree fndecl ATTRIBUTE_UNUSED)
 {
-  cum->nregs = 18;
+  cum->nregs = AVR_TINY ? 6 : 18;
   cum->regno = FIRST_CUM_REG;
   if (!libname && stdarg_p (fntype))
     cum->nregs = 0;
@@ -3072,14 +3141,10 @@ avr_out_xload (rtx insn ATTRIBUTE_UNUSED, rtx *op, int *plen)
   xop[2] = lpm_addr_reg_rtx;
   xop[3] = AVR_HAVE_LPMX ? op[0] : lpm_reg_rtx;
 
-  if (plen)
-    *plen = 0;
+  avr_asm_len (AVR_HAVE_LPMX ? "lpm %3,%a2" : "lpm", xop, plen, -1);
 
   avr_asm_len ("sbrc %1,7" CR_TAB
-               "ld %3,%a2" CR_TAB
-               "sbrs %1,7", xop, plen, 3);
-
-  avr_asm_len (AVR_HAVE_LPMX ? "lpm %3,%a2" : "lpm", xop, plen, 1);
+               "ld %3,%a2", xop, plen, 2);
 
   if (REGNO (xop[0]) != REGNO (xop[3]))
     avr_asm_len ("mov %0,%3", xop, plen, 1);
@@ -3087,6 +3152,35 @@ avr_out_xload (rtx insn ATTRIBUTE_UNUSED, rtx *op, int *plen)
   return "";
 }
 
+/*
+AVRTC-579
+if operand is symbol or constant expression with value > 0xbf
+  return false, otherwise true
+This check is used to avoid lds/sts instruction with invalid memory
+access range (valid range 0x40..0xbf). For io operand range 0x0..0x3f,
+in/out instruction will be generated.
+*/
+bool tiny_valid_direct_memory_access_range(rtx op, enum machine_mode mode)
+{
+  rtx x;
+
+  if (!AVR_TINY)
+    return true;
+
+  x = XEXP(op,0);
+
+  if (MEM_P(op) && x && (GET_CODE(x) == SYMBOL_REF))
+  {
+    return false;
+  }
+  if (MEM_P(op) && x && (CONSTANT_ADDRESS_P (x)) &&
+     !(IN_RANGE (INTVAL (x), 0, 0xC0 - GET_MODE_SIZE (mode))))
+  {
+    return false;
+  }
+
+  return true;
+}
 
 const char*
 output_movqi (rtx insn, rtx operands[], int *plen)
@@ -3215,6 +3309,24 @@ output_movhi (rtx insn, rtx xop[], int *plen)
   return "";
 }
 
+/* Same as out_movqi_r_mr, but TINY does not have ADIW or SBIW */
+static const char*
+avr_out_movqi_r_mr_reg_disp_tiny (rtx insn, rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx x = XEXP (src, 0);
+
+  avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+          "ld %0,%b1" , op, plen, -3);
+
+  if (!reg_overlap_mentioned_p (dest, XEXP (x,0))
+          && !reg_unused_after (insn, XEXP (x,0)))
+      avr_asm_len (TINY_SBIW (%I1, %J1, %o1), op, plen, 2);
+
+  return "";
+}
+
 static const char*
 out_movqi_r_mr (rtx insn, rtx op[], int *plen)
 {
@@ -3224,11 +3336,13 @@ out_movqi_r_mr (rtx insn, rtx op[], int *plen)
 
   if (CONSTANT_ADDRESS_P (x))
     {
+      int n_words = AVR_TINY ? 1 : 2;
       return optimize > 0 && io_address_operand (x, QImode)
         ? avr_asm_len ("in %0,%i1", op, plen, -1)
-        : avr_asm_len ("lds %0,%m1", op, plen, -2);
+        : avr_asm_len ("lds %0,%m1", op, plen, -n_words);
     }
-  else if (GET_CODE (x) == PLUS
+
+  if (GET_CODE (x) == PLUS
            && REG_P (XEXP (x, 0))
            && CONST_INT_P (XEXP (x, 1)))
     {
@@ -3236,6 +3350,9 @@ out_movqi_r_mr (rtx insn, rtx op[], int *plen)
 
       int disp = INTVAL (XEXP (x, 1));
 
+      if (AVR_TINY)
+        return avr_out_movqi_r_mr_reg_disp_tiny (insn, op, plen);
+
       if (disp - GET_MODE_SIZE (GET_MODE (src)) >= 63)
         {
           if (REGNO (XEXP (x, 0)) != REG_Y)
@@ -3275,6 +3392,82 @@ out_movqi_r_mr (rtx insn, rtx op[], int *plen)
   return avr_asm_len ("ld %0,%1", op, plen, -1);
 }
 
+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
+static const char*
+avr_out_movhi_r_mr_reg_no_disp_tiny (rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (base);
+
+  if (reg_dest == reg_base)         /* R = (R) */
+      return avr_asm_len ("ld __tmp_reg__,%1+" CR_TAB
+              "ld %B0,%1"          CR_TAB
+              "mov %A0,__tmp_reg__", op, plen, -3);
+
+  return avr_asm_len ("ld %A0,%1"             CR_TAB                        
+          TINY_ADIW (%E1, %F1, 1) CR_TAB                       
+          "ld %B0,%1"             CR_TAB                        
+          TINY_SBIW (%E1, %F1, 1), op, plen, -6);
+
+}
+
+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
+static const char*
+avr_out_movhi_r_mr_reg_disp_tiny (rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (XEXP (base, 0));
+
+  if (reg_base == reg_dest)
+  {
+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+              "ld __tmp_reg__,%b1+"    CR_TAB
+              "ld %B0,%b1"             CR_TAB 
+              "mov %A0,__tmp_reg__", op, plen, -5);
+  }
+  else
+  {
+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+              "ld %A0,%b1+"             CR_TAB
+              "ld %B0,%b1"              CR_TAB
+              TINY_SBIW (%I1, %J1, %o1+1), op, plen, -6);
+  }
+} 
+
+/* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */
+static const char*
+avr_out_movhi_r_mr_pre_dec_tiny (rtx insn, rtx op[], int *plen)
+{
+  int mem_volatile_p = 0;
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+
+  /* "volatile" forces reading low byte first, even if less efficient,
+     for correct operation with 16-bit I/O registers.  */
+  mem_volatile_p = MEM_VOLATILE_P (src);
+
+  if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))
+      fatal_insn ("incorrect insn:", insn);
+
+  if (!mem_volatile_p)
+      return avr_asm_len ("ld %B0,%1" CR_TAB
+              "ld %A0,%1", op, plen, -2);
+
+  return avr_asm_len (TINY_SBIW (%I1, %J1, 2)  CR_TAB
+          "ld %A0,%p1+"   CR_TAB
+          "ld %B0,%p1"    CR_TAB
+          TINY_SBIW (%I1, %J1, 1), op, plen, -6);
+}
+
 static const char*
 out_movhi_r_mr (rtx insn, rtx op[], int *plen)
 {
@@ -3289,6 +3482,9 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
 
   if (reg_base > 0)
     {
+      if (AVR_TINY)
+        return avr_out_movhi_r_mr_reg_no_disp_tiny (op, plen);
+
       if (reg_dest == reg_base)         /* R = (R) */
         return avr_asm_len ("ld __tmp_reg__,%1+" CR_TAB
                             "ld %B0,%1"          CR_TAB
@@ -3311,6 +3507,9 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
       int disp = INTVAL (XEXP (base, 1));
       int reg_base = true_regnum (XEXP (base, 0));
 
+      if (AVR_TINY)
+        return avr_out_movhi_r_mr_reg_disp_tiny (op, plen);
+
       if (disp > MAX_LD_OFFSET (GET_MODE (src)))
         {
           if (REGNO (XEXP (base, 0)) != REG_Y)
@@ -3322,7 +3521,7 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
                            "ldd %B0,Y+63"    CR_TAB
                            "sbiw r28,%o1-62", op, plen, -4)
 
-            : avr_asm_len ("subi r28,lo8(-%o1)" CR_TAB
+              : avr_asm_len ("subi r28,lo8(-%o1)" CR_TAB
                            "sbci r29,hi8(-%o1)" CR_TAB
                            "ld %A0,Y"           CR_TAB
                            "ldd %B0,Y+1"        CR_TAB
@@ -3356,6 +3555,9 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
     }
   else if (GET_CODE (base) == PRE_DEC) /* (--R) */
     {
+      if (AVR_TINY)
+          return avr_out_movhi_r_mr_pre_dec_tiny (insn, op, plen);
+
       if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))
         fatal_insn ("incorrect insn:", insn);
 
@@ -3383,12 +3585,13 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
     }
   else if (CONSTANT_ADDRESS_P (base))
     {
+      int n_words = AVR_TINY ? 2 : 4;
       return optimize > 0 && io_address_operand (base, HImode)
         ? avr_asm_len ("in %A0,%i1" CR_TAB
                        "in %B0,%i1+1", op, plen, -2)
 
         : avr_asm_len ("lds %A0,%m1" CR_TAB
-                       "lds %B0,%m1+1", op, plen, -4);
+                       "lds %B0,%m1+1", op, plen, -n_words);
     }
 
   fatal_insn ("unknown move insn:",insn);
@@ -3396,6 +3599,99 @@ out_movhi_r_mr (rtx insn, rtx op[], int *plen)
 }
 
 static const char*
+avr_out_movsi_r_mr_reg_no_disp_tiny (rtx insn, rtx op[], int *l)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (base);
+
+  if (reg_dest == reg_base)
+    {
+	  /* "ld r26,-X" is undefined */
+      return *l=9, (TINY_ADIW (%E1, %F1, 3) CR_TAB
+                    "ld %D0,%1"             CR_TAB
+                    "ld %C0,-%1"            CR_TAB
+                    "ld __tmp_reg__,-%1"   CR_TAB
+                    TINY_SBIW (%E1, %F1, 1) CR_TAB
+                    "ld %A0,%1"             CR_TAB
+                    "mov %B0,__tmp_reg__");
+    }
+  else if (reg_dest == reg_base - 2)
+    {
+      return *l=5, ("ld %A0,%1+"            CR_TAB
+                    "ld %B0,%1+"            CR_TAB
+                    "ld __tmp_reg__,%1+"   CR_TAB
+                    "ld %D0,%1"            CR_TAB
+                    "mov %C0,__tmp_reg__");
+    }
+  else if (reg_unused_after (insn, base))
+    {
+      return *l=4, ("ld %A0,%1+"    CR_TAB
+                    "ld %B0,%1+"    CR_TAB 
+                    "ld %C0,%1+"    CR_TAB
+                    "ld %D0,%1");
+    }
+  else
+    {
+      return *l=6, ("ld %A0,%1+"    CR_TAB
+                    "ld %B0,%1+"    CR_TAB 
+                    "ld %C0,%1+"    CR_TAB
+                    "ld %D0,%1"     CR_TAB
+                    TINY_SBIW (%E1, %F1, 3));
+    }
+}
+
+static const char*
+avr_out_movsi_r_mr_reg_disp_tiny (rtx insn, rtx op[], int *l)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (XEXP (base, 0));
+
+  if (reg_dest == reg_base)
+    {
+	  /* "ld r26,-X" is undefined */
+      return *l=9, (TINY_ADIW (%I1, %J1, %o1+3) CR_TAB
+                    "ld %D0,%b1"                 CR_TAB
+                    "ld %C0,-%b1"                CR_TAB
+                    "ld __tmp_reg__,-%b1"        CR_TAB
+                    TINY_SBIW (%I1, %J1, 1)     CR_TAB
+                    "ld %A0,%b1"                 CR_TAB
+                    "mov %B0,__tmp_reg__");
+    }
+  else if (reg_dest == reg_base - 2)
+    {
+      return *l=7, (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+                    "ld %A0,%b1+"              CR_TAB
+                    "ld %B0,%b1+"              CR_TAB
+                    "ld __tmp_reg__,%b1+"      CR_TAB
+                    "ld %D0,%b1"               CR_TAB
+                    "mov %C0,__tmp_reg__");
+    }
+  else if (reg_unused_after (insn, XEXP (base, 0)))
+    {
+      return *l=6, (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+                    "ld %A0,%b1+"              CR_TAB
+                    "ld %B0,%b1+"              CR_TAB 
+                    "ld %C0,%b1+"              CR_TAB
+                    "ld %D0,%b1");
+    }
+  else
+    {
+      return *l=8, (TINY_ADIW (%I1, %J1, %o1) CR_TAB
+                    "ld %A0,%b1+"              CR_TAB
+                    "ld %B0,%b1+"              CR_TAB 
+                    "ld %C0,%b1+"              CR_TAB
+                    "ld %D0,%b1"               CR_TAB
+                    TINY_SBIW (%I1, %J1, %o1+3));
+    }
+}
+
+static const char*
 out_movsi_r_mr (rtx insn, rtx op[], int *l)
 {
   rtx dest = op[0];
@@ -3410,6 +3706,9 @@ out_movsi_r_mr (rtx insn, rtx op[], int *l)
 
   if (reg_base > 0)
     {
+      if (AVR_TINY)
+        return avr_out_movsi_r_mr_reg_no_disp_tiny (insn, op, l);
+
       if (reg_base == REG_X)        /* (R26) */
         {
           if (reg_dest == REG_X)
@@ -3464,6 +3763,9 @@ out_movsi_r_mr (rtx insn, rtx op[], int *l)
     {
       int disp = INTVAL (XEXP (base, 1));
 
+      if (AVR_TINY)
+        return avr_out_movsi_r_mr_reg_disp_tiny (insn, op, l);
+
       if (disp > MAX_LD_OFFSET (GET_MODE (src)))
 	{
 	  if (REGNO (XEXP (base, 0)) != REG_Y)
@@ -3547,16 +3849,134 @@ out_movsi_r_mr (rtx insn, rtx op[], int *l)
 		  "ld %C0,%1" CR_TAB
 		  "ld %D0,%1");
   else if (CONSTANT_ADDRESS_P (base))
-    return *l=8, ("lds %A0,%m1"   CR_TAB
+    {
+      if (io_address_operand (base, SImode))
+        {
+          *l = 4;
+          return ("in %A0,%i1"   CR_TAB
+                  "in %B0,%i1+1" CR_TAB
+                  "in %C0,%i1+2" CR_TAB
+                  "in %D0,%i1+3");
+        }
+      else
+        {
+          *l = AVR_TINY ? 4 : 8;
+          return ("lds %A0,%m1"   CR_TAB
                   "lds %B0,%m1+1" CR_TAB
                   "lds %C0,%m1+2" CR_TAB
                   "lds %D0,%m1+3");
+        }
+    }
 
   fatal_insn ("unknown move insn:",insn);
   return "";
 }
 
 static const char*
+avr_out_movsi_mr_r_reg_no_disp_tiny (rtx insn, rtx op[], int *l)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = true_regnum (base);
+  int reg_src = true_regnum (src);
+  
+  if (reg_base == reg_src)
+    {
+	  /* "ld r26,-X" is undefined */
+      if (reg_unused_after (insn, base))
+        { 
+          return *l=7, ("mov __tmp_reg__, %B1"  CR_TAB
+                        "st %0,%A1"             CR_TAB
+                        TINY_ADIW (%E0, %F0, 1) CR_TAB
+                        "st %0+,__tmp_reg__"    CR_TAB
+                        "st %0+,%C1"            CR_TAB
+                        "st %0+,%D1");
+        }
+      else
+        {
+          return *l=9, ("mov __tmp_reg__, %B1"  CR_TAB
+                        "st %0,%A1"             CR_TAB
+                        TINY_ADIW (%E0, %F0, 1) CR_TAB
+                        "st %0+,__tmp_reg__"    CR_TAB
+                        "st %0+,%C1"            CR_TAB
+                        "st %0+,%D1"            CR_TAB
+                        TINY_SBIW (%E0, %F0, 3));
+        }
+    }
+    else if (reg_base == reg_src + 2)
+      {
+        if (reg_unused_after (insn, base))
+          return *l=7, ("mov __zero_reg__,%C1" CR_TAB
+                        "mov __tmp_reg__,%D1"  CR_TAB
+                        "st %0+,%A1"           CR_TAB
+                        "st %0+,%B1"           CR_TAB
+                        "st %0+,__zero_reg__"  CR_TAB
+                        "st %0,__tmp_reg__"    CR_TAB
+                        "clr __zero_reg__");
+        else
+          return *l=9, ("mov __zero_reg__,%C1" CR_TAB
+                        "mov __tmp_reg__,%D1"  CR_TAB
+                        "st %0+,%A1"           CR_TAB
+                        "st %0+,%B1"           CR_TAB
+                        "st %0+,__zero_reg__"  CR_TAB
+                        "st %0,__tmp_reg__"    CR_TAB
+                        "clr __zero_reg__"     CR_TAB
+                        TINY_SBIW (%E0, %F0, 3));
+      }
+
+    return *l=6, ("st %0+,%A1" CR_TAB
+                  "st %0+,%B1" CR_TAB
+                  "st %0+,%C1" CR_TAB
+                  "st %0,%D1"  CR_TAB
+                  TINY_SBIW (%E0, %F0, 3));
+}
+
+static const char*
+avr_out_movsi_mr_r_reg_disp_tiny (rtx op[], int *l)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = REGNO (XEXP (base, 0));
+  int reg_src =true_regnum (src);
+
+  if (reg_base == reg_src)
+    {
+	  *l = 11;
+	  return ("mov __tmp_reg__,%A2"        CR_TAB
+		      "mov __zero_reg__,%B2"       CR_TAB
+              TINY_ADIW (%I0, %J0, %o0)    CR_TAB
+		      "st %b0+,__tmp_reg__"        CR_TAB
+		      "st %b0+,__zero_reg__"       CR_TAB
+		      "st %b0+,%C2"                CR_TAB
+		      "st %b0,%D2"                 CR_TAB
+		      "clr __zero_reg__"           CR_TAB
+		      TINY_SBIW (%I0, %J0, %o0+3));
+	 }
+  else if (reg_src == reg_base - 2)
+    {
+	  *l = 11;
+	  return ("mov __tmp_reg__,%C2"         CR_TAB
+		      "mov __zero_reg__,%D2"        CR_TAB
+		      TINY_ADIW (%I0, %J0, %o0)     CR_TAB
+		      "st %b0+,%A0"                 CR_TAB
+		      "st %b0+,%B0"                 CR_TAB
+		      "st %b0+,__tmp_reg__"         CR_TAB
+		      "st %b0,__zero_reg__"         CR_TAB
+		      "clr __zero_reg__"            CR_TAB
+		      TINY_SBIW (%I0, %J0, %o0+3));
+	    }
+  *l = 8;
+  return (TINY_ADIW (%I0, %J0, %o0)     CR_TAB
+		  "st %b0+,%A1"                 CR_TAB
+		  "st %b0+,%B1"                 CR_TAB
+		  "st %b0+,%C1"                 CR_TAB
+		  "st %b0,%D1"                  CR_TAB
+		  TINY_SBIW (%I0, %J0, %o0+3));
+}
+
+static const char*
 out_movsi_mr_r (rtx insn, rtx op[], int *l)
 {
   rtx dest = op[0];
@@ -3570,12 +3990,29 @@ out_movsi_mr_r (rtx insn, rtx op[], int *l)
     l = &tmp;
 
   if (CONSTANT_ADDRESS_P (base))
-    return *l=8,("sts %m0,%A1" CR_TAB
-                 "sts %m0+1,%B1" CR_TAB
-                 "sts %m0+2,%C1" CR_TAB
-                 "sts %m0+3,%D1");
+    {
+      if (io_address_operand (base, SImode))
+        {
+          return *l=4,("out %i0, %A1"  CR_TAB
+                       "out %i0+1,%B1" CR_TAB
+                       "out %i0+2,%C1" CR_TAB
+                       "out %i0+3,%D1");
+        }
+      else
+        {
+          *l = AVR_TINY ? 4 : 8;
+          return ("sts %m0,%A1"   CR_TAB
+                  "sts %m0+1,%B1" CR_TAB
+                  "sts %m0+2,%C1" CR_TAB
+                  "sts %m0+3,%D1");
+        }
+    }
+
   if (reg_base > 0)                 /* (r) */
     {
+      if (AVR_TINY)
+        return avr_out_movsi_mr_r_reg_no_disp_tiny (insn, op, l);
+
       if (reg_base == REG_X)                /* (R26) */
         {
           if (reg_src == REG_X)
@@ -3632,6 +4069,10 @@ out_movsi_mr_r (rtx insn, rtx op[], int *l)
   else if (GET_CODE (base) == PLUS) /* (R + i) */
     {
       int disp = INTVAL (XEXP (base, 1));
+
+      if (AVR_TINY)
+        return avr_out_movsi_mr_r_reg_disp_tiny (op, l);
+
       reg_base = REGNO (XEXP (base, 0));
       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))
 	{
@@ -3792,6 +4233,73 @@ output_movsisf (rtx insn, rtx operands[], int *l)
 /* Handle loads of 24-bit types from memory to register.  */
 
 static const char*
+avr_out_load_psi_reg_no_disp_tiny (rtx insn, rtx *op, int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (base);
+
+  if (reg_base == reg_dest)
+    {
+      return avr_asm_len (TINY_ADIW (%E1, %F1, 2)   CR_TAB
+                          "ld %C0,%1"               CR_TAB
+                          "ld __tmp_reg__,-%1"     CR_TAB
+                          TINY_SBIW (%E1, %F1, 1)   CR_TAB
+                          "ld %A0,%1"              CR_TAB
+                          "mov %B0,__tmp_reg__", op, plen, -8);
+    }
+  else
+    {
+      return avr_asm_len ("ld %A0,%1+"  CR_TAB
+                          "ld %B0,%1+"  CR_TAB
+                          "ld %C0,%1", op, plen, -3);
+
+      if (reg_dest != reg_base - 2 &&
+          !reg_unused_after (insn, base))
+        {
+          avr_asm_len (TINY_SBIW (%E1, %F1, 2), op, plen, 2);
+        }
+      return "";
+    }
+}
+
+static const char*
+avr_out_load_psi_reg_disp_tiny (rtx insn, rtx *op, int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (src, 0);
+  int reg_dest = true_regnum (dest);
+  int reg_base = true_regnum (base);
+
+  reg_base = true_regnum (XEXP (base, 0));
+  if (reg_base == reg_dest)
+    {
+      return avr_asm_len (TINY_ADIW (%I1, %J1, %o1+2) CR_TAB
+                          "ld %C0,%b1"                CR_TAB
+                          "ld __tmp_reg__,-%b1"       CR_TAB
+                          TINY_SBIW (%I1, %J1, 1)     CR_TAB
+                          "ld %A0,%b1"                CR_TAB
+                          "mov %B0,__tmp_reg__", op, plen, -8);
+   }
+  else
+    {
+      avr_asm_len (TINY_ADIW (%I1, %J1, %o1)   CR_TAB
+                          "ld %A0,%b1+"              CR_TAB
+                          "ld %B0,%b1+"              CR_TAB  
+                          "ld %C0,%b1", op, plen, -5);
+
+      if (reg_dest != (reg_base - 2)
+          && !reg_unused_after (insn, XEXP (base, 0)))
+          avr_asm_len (TINY_SBIW (%I1, %J1, %o1+2), op, plen, 2);
+      
+      return "";
+    }
+}
+
+static const char*
 avr_out_load_psi (rtx insn, rtx *op, int *plen)
 {
   rtx dest = op[0];
@@ -3802,6 +4310,9 @@ avr_out_load_psi (rtx insn, rtx *op, int *plen)
 
   if (reg_base > 0)
     {
+      if (AVR_TINY)
+        return avr_out_load_psi_reg_no_disp_tiny (insn, op, plen);
+
       if (reg_base == REG_X)        /* (R26) */
         {
           if (reg_dest == REG_X)
@@ -3844,6 +4355,9 @@ avr_out_load_psi (rtx insn, rtx *op, int *plen)
     {
       int disp = INTVAL (XEXP (base, 1));
 
+      if (AVR_TINY)
+        return avr_out_load_psi_reg_disp_tiny (insn, op, plen);
+
       if (disp > MAX_LD_OFFSET (GET_MODE (src)))
         {
           if (REGNO (XEXP (base, 0)) != REG_Y)
@@ -3912,14 +4426,94 @@ avr_out_load_psi (rtx insn, rtx *op, int *plen)
                         "ld %C0,%1", op, plen, -3);
 
   else if (CONSTANT_ADDRESS_P (base))
-    return avr_asm_len ("lds %A0,%m1" CR_TAB
-                        "lds %B0,%m1+1" CR_TAB
-                        "lds %C0,%m1+2", op, plen , -6);
+    {
+      int n_words = AVR_TINY ? 3 : 6;
+      return avr_asm_len ("lds %A0,%m1" CR_TAB
+                          "lds %B0,%m1+1" CR_TAB
+                          "lds %C0,%m1+2", op, plen , -n_words);
+    }
 
   fatal_insn ("unknown move insn:",insn);
   return "";
 }
 
+
+static const char*
+avr_out_store_psi_reg_no_disp_tiny (rtx insn, rtx *op, int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = true_regnum (base);
+  int reg_src = true_regnum (src);
+
+  if (reg_base == reg_src)
+    {
+      avr_asm_len ("st %0,%A1"              CR_TAB
+                   "mov __tmp_reg__,%B1"    CR_TAB
+                   TINY_ADIW (%E0, %F0, 1)  CR_TAB /* st X+, r27 is undefined */
+                   "st %0+,__tmp_reg__"     CR_TAB
+                   "st %0,%C1", op, plen, -6);
+
+    }
+  else if (reg_src == reg_base - 2)
+    {
+      avr_asm_len ("st %0,%A1"              CR_TAB
+                   "mov __tmp_reg__,%C1"    CR_TAB
+                   TINY_ADIW (%E0, %F0, 1)  CR_TAB
+                   "st %0+,%B1"             CR_TAB
+                   "st %0,__tmp_reg__", op, plen, 6);
+    }
+  else
+    {
+      avr_asm_len ("st %0+,%A1"  CR_TAB
+                   "st %0+,%B1" CR_TAB
+                   "st %0,%C1", op, plen, -3);
+    }
+
+  if (!reg_unused_after (insn, base))
+    avr_asm_len (TINY_SBIW (%E0, %F0, 2), op, plen, 2);
+
+  return "";
+}
+
+static const char*
+avr_out_store_psi_reg_disp_tiny (rtx *op, int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = REGNO (XEXP (base, 0));
+  int reg_src = true_regnum (src);
+
+  if (reg_src == reg_base)
+    {
+      return avr_asm_len ("mov __tmp_reg__,%A1"          CR_TAB
+                          "mov __zero_reg__,%B1"         CR_TAB
+                          TINY_ADIW (%I0, %J0, %o0)      CR_TAB
+                          "st %b0+,__tmp_reg__"          CR_TAB
+                          "st %b0+,__zero_reg__"         CR_TAB
+                          "st %b0,%C1"                   CR_TAB
+                          "clr __zero_reg__"             CR_TAB
+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -10);
+    }
+  else if (reg_src == reg_base - 2)
+    {
+      return avr_asm_len ("mov __tmp_reg__,%C1"          CR_TAB  
+                          TINY_ADIW (%I0, %J0, %o0)      CR_TAB
+                          "st %b0+,%A1"                  CR_TAB
+                          "st %b0+,%B1"                  CR_TAB
+                          "st %b0,__tmp_reg__"           CR_TAB
+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -8);
+    }
+
+  return avr_asm_len (TINY_ADIW (%I0, %J0, %o0)      CR_TAB
+                          "st %b0+,%A1"                  CR_TAB
+                          "st %b0+,%B1"                  CR_TAB
+                          "st %b0,%C1"                   CR_TAB
+                          TINY_SBIW (%I0, %J0, %o0+2), op, plen, -7);
+}
+
 /* Handle store of 24-bit type from register or zero to memory.  */
 
 static const char*
@@ -3931,12 +4525,18 @@ avr_out_store_psi (rtx insn, rtx *op, int *plen)
   int reg_base = true_regnum (base);
 
   if (CONSTANT_ADDRESS_P (base))
-    return avr_asm_len ("sts %m0,%A1"   CR_TAB
-                        "sts %m0+1,%B1" CR_TAB
-                        "sts %m0+2,%C1", op, plen, -6);
+    {
+      int n_words = AVR_TINY ? 3 : 6;
+      return avr_asm_len ("sts %m0,%A1"   CR_TAB
+                          "sts %m0+1,%B1" CR_TAB
+                          "sts %m0+2,%C1", op, plen, -n_words);
+    }
 
   if (reg_base > 0)                 /* (r) */
     {
+      if (AVR_TINY)
+        return avr_out_store_psi_reg_no_disp_tiny (insn, op, plen);
+
       if (reg_base == REG_X)        /* (R26) */
         {
           gcc_assert (!reg_overlap_mentioned_p (base, src));
@@ -3958,6 +4558,10 @@ avr_out_store_psi (rtx insn, rtx *op, int *plen)
   else if (GET_CODE (base) == PLUS) /* (R + i) */
     {
       int disp = INTVAL (XEXP (base, 1));
+
+      if (AVR_TINY)
+        return avr_out_store_psi_reg_disp_tiny (op, plen);
+
       reg_base = REGNO (XEXP (base, 0));
 
       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))
@@ -4074,6 +4678,30 @@ avr_out_movpsi (rtx insn, rtx *op, int *plen)
   return "";
 }
 
+static const char*
+avr_out_movqi_mr_r_reg_disp_tiny (rtx insn, rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx x = XEXP (dest, 0);
+
+  if (reg_overlap_mentioned_p (src, XEXP (x, 0)))
+    {
+      avr_asm_len ("mov __tmp_reg__,%1"      CR_TAB
+                   TINY_ADIW (%I0, %J0, %o0) CR_TAB
+                   "st %b0,__tmp_reg__", op, plen, -4);
+    }
+    else
+    {
+      avr_asm_len (TINY_ADIW (%I0, %J0, %o0) CR_TAB
+          "st %b0,%1" , op, plen, -3);
+    }
+
+  if (!reg_unused_after (insn, XEXP (x,0)))
+      avr_asm_len (TINY_SBIW (%I0, %J0, %o0), op, plen, 2);
+
+  return "";
+}
 
 static const char*
 out_movqi_mr_r (rtx insn, rtx op[], int *plen)
@@ -4084,9 +4712,10 @@ out_movqi_mr_r (rtx insn, rtx op[], int *plen)
 
   if (CONSTANT_ADDRESS_P (x))
     {
+      int n_words = AVR_TINY ? 1 : 2;
       return optimize > 0 && io_address_operand (x, QImode)
         ? avr_asm_len ("out %i0,%1", op, plen, -1)
-        : avr_asm_len ("sts %m0,%1", op, plen, -2);
+        : avr_asm_len ("sts %m0,%1", op, plen, -n_words);
     }
   else if (GET_CODE (x) == PLUS
            && REG_P (XEXP (x, 0))
@@ -4096,6 +4725,9 @@ out_movqi_mr_r (rtx insn, rtx op[], int *plen)
 
       int disp = INTVAL (XEXP (x, 1));
 
+      if (AVR_TINY)
+        return avr_out_movqi_mr_r_reg_disp_tiny (insn, op, plen);
+
       if (disp - GET_MODE_SIZE (GET_MODE (dest)) >= 63)
         {
           if (REGNO (XEXP (x, 0)) != REG_Y)
@@ -4156,12 +4788,15 @@ avr_out_movhi_mr_r_xmega (rtx insn, rtx op[], int *plen)
   int mem_volatile_p = MEM_VOLATILE_P (dest);
 
   if (CONSTANT_ADDRESS_P (base))
-    return optimize > 0 && io_address_operand (base, HImode)
-      ? avr_asm_len ("out %i0,%A1" CR_TAB
-                     "out %i0+1,%B1", op, plen, -2)
+    {
+      int n_words = AVR_TINY ? 2 : 4;
+      return optimize > 0 && io_address_operand (base, HImode)
+        ? avr_asm_len ("out %i0,%A1" CR_TAB
+                       "out %i0+1,%B1", op, plen, -2)
 
-      : avr_asm_len ("sts %m0,%A1" CR_TAB
-                     "sts %m0+1,%B1", op, plen, -4);
+        : avr_asm_len ("sts %m0,%A1" CR_TAB
+                       "sts %m0+1,%B1", op, plen, -n_words);
+    }
 
   if (reg_base > 0)
     {
@@ -4250,6 +4885,72 @@ avr_out_movhi_mr_r_xmega (rtx insn, rtx op[], int *plen)
   return "";
 }
 
+static const char*
+avr_out_movhi_mr_r_reg_no_disp_tiny (rtx insn, rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = true_regnum (base);
+  int reg_src = true_regnum (src);
+  int mem_volatile_p = MEM_VOLATILE_P (dest);
+
+  if (reg_base == reg_src)
+    {
+      return !mem_volatile_p && reg_unused_after (insn, src)
+        ? avr_asm_len ("mov __tmp_reg__,%B1"   CR_TAB
+                       "st %0,%A1"             CR_TAB
+                       TINY_ADIW (%E0, %F0, 1) CR_TAB
+                       "st %0,__tmp_reg__", op, plen, -5)
+        : avr_asm_len ("mov __tmp_reg__,%B1"   CR_TAB
+                       TINY_ADIW (%E0, %F0, 1) CR_TAB
+                       "st %0,__tmp_reg__"      CR_TAB
+                       TINY_SBIW (%E0, %F0, 1) CR_TAB
+                       "st %0, %A1", op, plen, -7);
+    }
+
+  return !mem_volatile_p && reg_unused_after (insn, base)
+      ? avr_asm_len ("st %0+,%A1" CR_TAB
+                     "st %0,%B1", op, plen, -2)
+      : avr_asm_len (TINY_ADIW (%E0, %F0, 1) CR_TAB
+                     "st %0,%B1"             CR_TAB
+                     "st -%0,%A1", op, plen, -4);
+}
+
+static const char*
+avr_out_movhi_mr_r_reg_disp_tiny (rtx op[], int *plen)
+{
+  rtx dest = op[0];
+  rtx src = op[1];
+  rtx base = XEXP (dest, 0);
+  int reg_base = REGNO (XEXP (base, 0));
+  int reg_src = true_regnum (src);
+
+  return reg_src == reg_base
+        ? avr_asm_len ("mov __tmp_reg__,%A1"          CR_TAB
+                       "mov __zero_reg__,%B1"         CR_TAB
+                       TINY_ADIW (%I0, %J0, %o0+1)    CR_TAB
+                       "st %b0,__zero_reg__"          CR_TAB
+                       "st -%b0,__tmp_reg__"          CR_TAB
+                       "clr __zero_reg__"             CR_TAB
+                       TINY_SBIW (%I0, %J0, %o0), op, plen, -9) 
+
+        : avr_asm_len (TINY_ADIW (%I0, %J0, %o0+1) CR_TAB
+                       "st %b0,%B1"                CR_TAB
+                       "st -%b0,%A1"               CR_TAB
+                       TINY_SBIW (%I0, %J0, %o0), op, plen, -6);
+}
+
+static const char*
+avr_out_movhi_mr_r_post_inc_tiny (rtx op[], int *plen)
+{
+  rtx dest = op[0];
+
+  return avr_asm_len (TINY_ADIW (%I0, %J0, 1)  CR_TAB
+                      "st %p0,%B1"    CR_TAB
+                      "st -%p0,%A1"   CR_TAB
+                      TINY_ADIW (%I0, %J0, 2), op, plen, -6);
+}
 
 static const char*
 out_movhi_mr_r (rtx insn, rtx op[], int *plen)
@@ -4271,15 +4972,21 @@ out_movhi_mr_r (rtx insn, rtx op[], int *plen)
   mem_volatile_p = MEM_VOLATILE_P (dest);
 
   if (CONSTANT_ADDRESS_P (base))
-    return optimize > 0 && io_address_operand (base, HImode)
-      ? avr_asm_len ("out %i0+1,%B1" CR_TAB
-                     "out %i0,%A1", op, plen, -2)
+    {
+      int n_words = AVR_TINY ? 2 : 4;
+      return optimize > 0 && io_address_operand (base, HImode)
+        ? avr_asm_len ("out %i0+1,%B1" CR_TAB
+                       "out %i0,%A1", op, plen, -2)
 
-      : avr_asm_len ("sts %m0+1,%B1" CR_TAB
-                     "sts %m0,%A1", op, plen, -4);
+        : avr_asm_len ("sts %m0+1,%B1" CR_TAB
+                       "sts %m0,%A1", op, plen, -n_words);
+    }
 
   if (reg_base > 0)
     {
+      if (AVR_TINY)
+        return avr_out_movhi_mr_r_reg_no_disp_tiny (insn, op, plen);
+
       if (reg_base != REG_X)
         return avr_asm_len ("std %0+1,%B1" CR_TAB
                             "st %0,%A1", op, plen, -2);
@@ -4308,6 +5015,10 @@ out_movhi_mr_r (rtx insn, rtx op[], int *plen)
   else if (GET_CODE (base) == PLUS)
     {
       int disp = INTVAL (XEXP (base, 1));
+
+      if (AVR_TINY)
+        return avr_out_movhi_mr_r_reg_disp_tiny (op, plen);
+
       reg_base = REGNO (XEXP (base, 0));
       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))
         {
@@ -4357,6 +5068,9 @@ out_movhi_mr_r (rtx insn, rtx op[], int *plen)
         return avr_asm_len ("st %0,%A1"  CR_TAB
                             "st %0,%B1", op, plen, -2);
 
+      if (AVR_TINY)
+        return avr_out_movhi_mr_r_post_inc_tiny (op, plen);
+
       return REGNO (XEXP (base, 0)) == REG_X
         ? avr_asm_len ("adiw r26,1"  CR_TAB
                        "st X,%B1"    CR_TAB
@@ -4539,7 +5253,11 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)
               && (val8 == 0
                   || reg_unused_after (insn, xreg)))
             {
-              avr_asm_len ("sbiw %0,%1", xop, plen, 1);
+              if (AVR_TINY)
+                avr_asm_len (TINY_SBIW (%A0, %B0, %1), xop, plen, 2);
+              else
+                avr_asm_len ("sbiw %0,%1", xop, plen, 1);
+
               i++;
               continue;
             }
@@ -4549,7 +5267,9 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)
               && compare_eq_p (insn)
               && reg_unused_after (insn, xreg))
             {
-              return avr_asm_len ("adiw %0,%n1", xop, plen, 1);
+              return AVR_TINY
+                  ? avr_asm_len (TINY_ADIW (%A0, %B0, %n1), xop, plen, 2)
+                  : avr_asm_len ("adiw %0,%n1", xop, plen, 1);
             }
         }
 
@@ -6225,11 +6945,14 @@ lshrsi3_out (rtx insn, rtx operands[], int *len)
    the subtrahend in the original insn, provided it is a compile time constant.
    In all other cases, SIGN is 0.
 
-   Return "".  */
+   If OUT_LABEL is true, print the final 0: label which is needed for
+   saturated addition / subtraction.  The only case where OUT_LABEL = false
+   is useful is for saturated addition / subtraction performed during
+   fixed-point rounding, cf. `avr_out_round'.  */
 
 static void
 avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,
-                enum rtx_code code_sat = UNKNOWN, int sign = 0)
+                enum rtx_code code_sat, int sign, bool out_label)
 {
   /* MODE of the operation.  */
   enum machine_mode mode = GET_MODE (xop[0]);
@@ -6668,7 +7391,8 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,
                      "mov %r0+5,%0", xop, plen, 4);
     }
 
-  avr_asm_len ("0:", op, plen, 0);
+  if (out_label)
+    avr_asm_len ("0:", op, plen, 0);
 }
 
 
@@ -6706,8 +7430,8 @@ avr_out_plus_symbol (rtx *xop, enum rtx_code code, int *plen, int *pcc)
 
 /* Prepare operands of addition/subtraction to be used with avr_out_plus_1.
 
-   INSN is a single_set insn with a binary operation as SET_SRC that is
-   one of:  PLUS, SS_PLUS, US_PLUS, MINUS, SS_MINUS, US_MINUS.
+   INSN is a single_set insn or an insn pattern with a binary operation as
+   SET_SRC that is one of: PLUS, SS_PLUS, US_PLUS, MINUS, SS_MINUS, US_MINUS.
 
    XOP are the operands of INSN.  In the case of 64-bit operations with
    constant XOP[] has just one element:  The summand/subtrahend in XOP[0].
@@ -6722,19 +7446,22 @@ avr_out_plus_symbol (rtx *xop, enum rtx_code code, int *plen, int *pcc)
 
    PLEN and PCC default to NULL.
 
+   OUT_LABEL defaults to TRUE.  For a description, see AVR_OUT_PLUS_1.
+
    Return ""  */
 
 const char*
-avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)
+avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc, bool out_label)
 {
   int cc_plus, cc_minus, cc_dummy;
   int len_plus, len_minus;
   rtx op[4];
-  rtx xdest = SET_DEST (single_set (insn));
+  rtx xpattern = INSN_P (insn) ? single_set (insn) : insn;
+  rtx xdest = SET_DEST (xpattern);
   enum machine_mode mode = GET_MODE (xdest);
   enum machine_mode imode = int_mode_for_mode (mode);
   int n_bytes = GET_MODE_SIZE (mode);
-  enum rtx_code code_sat = GET_CODE (SET_SRC (single_set (insn)));
+  enum rtx_code code_sat = GET_CODE (SET_SRC (xpattern));
   enum rtx_code code
     = (PLUS == code_sat || SS_PLUS == code_sat || US_PLUS == code_sat
        ? PLUS : MINUS);
@@ -6749,7 +7476,7 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)
 
   if (n_bytes <= 4 && REG_P (xop[2]))
     {
-      avr_out_plus_1 (xop, plen, code, pcc, code_sat);
+      avr_out_plus_1 (xop, plen, code, pcc, code_sat, 0, out_label);
       return "";
     }
 
@@ -6776,7 +7503,8 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)
   /* Saturations and 64-bit operations don't have a clobber operand.
      For the other cases, the caller will provide a proper XOP[3].  */
 
-  op[3] = PARALLEL == GET_CODE (PATTERN (insn)) ? xop[3] : NULL_RTX;
+  xpattern = INSN_P (insn) ? PATTERN (insn) : insn;
+  op[3] = PARALLEL == GET_CODE (xpattern) ? xop[3] : NULL_RTX;
 
   /* Saturation will need the sign of the original operand.  */
 
@@ -6791,8 +7519,8 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)
 
   /* Work out the shortest sequence.  */
 
-  avr_out_plus_1 (op, &len_minus, MINUS, &cc_plus, code_sat, sign);
-  avr_out_plus_1 (op, &len_plus, PLUS, &cc_minus, code_sat, sign);
+  avr_out_plus_1 (op, &len_minus, MINUS, &cc_plus, code_sat, sign, out_label);
+  avr_out_plus_1 (op, &len_plus, PLUS, &cc_minus, code_sat, sign, out_label);
 
   if (plen)
     {
@@ -6800,9 +7528,9 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)
       *pcc  = (len_minus <= len_plus) ? cc_minus : cc_plus;
     }
   else if (len_minus <= len_plus)
-    avr_out_plus_1 (op, NULL, MINUS, pcc, code_sat, sign);
+    avr_out_plus_1 (op, NULL, MINUS, pcc, code_sat, sign, out_label);
   else
-    avr_out_plus_1 (op, NULL, PLUS, pcc, code_sat, sign);
+    avr_out_plus_1 (op, NULL, PLUS, pcc, code_sat, sign, out_label);
 
   return "";
 }
@@ -6816,13 +7544,15 @@ avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)
    and return "".  If PLEN == NULL, print assembler instructions to perform the
    operation; otherwise, set *PLEN to the length of the instruction sequence
    (in words) printed with PLEN == NULL.  XOP[3] is either an 8-bit clobber
-   register or SCRATCH if no clobber register is needed for the operation.  */
+   register or SCRATCH if no clobber register is needed for the operation.
+   INSN is an INSN_P or a pattern of an insn.  */
 
 const char*
 avr_out_bitop (rtx insn, rtx *xop, int *plen)
 {
   /* CODE and MODE of the operation.  */
-  enum rtx_code code = GET_CODE (SET_SRC (single_set (insn)));
+  rtx xpattern = INSN_P (insn) ? single_set (insn) : insn;
+  enum rtx_code code = GET_CODE (SET_SRC (xpattern));
   enum machine_mode mode = GET_MODE (xop[0]);
 
   /* Number of bytes to operate on.  */
@@ -7017,7 +7747,9 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
   RTX_CODE shift = UNKNOWN;
   bool sign_in_carry = false;
   bool msb_in_carry = false;
+  bool lsb_in_tmp_reg = false;
   bool lsb_in_carry = false;
+  bool frac_rounded = false;
   const char *code_ashift = "lsl %0";
 
 
@@ -7025,6 +7757,7 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
   /* Shorthand used below.  */                                          \
   ((sign_bytes                                                          \
     && IN_RANGE (RR, dest.regno_msb - sign_bytes + 1, dest.regno_msb))  \
+   || (offset && IN_RANGE (RR, dest.regno, dest.regno_msb))		\
    || (reg_unused_after (insn, all_regs_rtx[RR])                        \
        && !IN_RANGE (RR, dest.regno, dest.regno_msb)))
 
@@ -7099,13 +7832,119 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
   else
     gcc_unreachable();
 
+  /* If we need to round the fraction part, we might need to save/round it
+     before clobbering any of it in Step 1.  Also, we might to want to do
+     the rounding now to make use of LD_REGS.  */
+  if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))
+      && SCALAR_ACCUM_MODE_P (GET_MODE (xop[1]))
+      && !TARGET_FRACT_CONV_TRUNC)
+    {
+      bool overlap
+	= (src.regno <=
+	   (offset ? dest.regno_msb - sign_bytes : dest.regno + zero_bytes - 1)
+	   && dest.regno - offset -1 >= dest.regno);
+      unsigned s0 = dest.regno - offset -1;
+      bool use_src = true;
+      unsigned sn;
+      unsigned copied_msb = src.regno_msb;
+      bool have_carry = false;
+
+      if (src.ibyte > dest.ibyte)
+	copied_msb -= src.ibyte - dest.ibyte;
+
+      for (sn = s0; sn <= copied_msb; sn++)
+	if (!IN_RANGE (sn, dest.regno, dest.regno_msb)
+	    && !reg_unused_after (insn, all_regs_rtx[sn]))
+	  use_src = false;
+      if (use_src && TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0))
+	{
+	  avr_asm_len ("tst %0" CR_TAB "brpl 0f",
+		       &all_regs_rtx[src.regno_msb], plen, 2);
+	  sn = src.regno;
+	  if (sn < s0)
+	    {
+	      if (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], sn))
+		avr_asm_len ("cpi %0,1", &all_regs_rtx[sn], plen, 1);
+	      else
+		avr_asm_len ("sec" CR_TAB "cpc %0,__zero_reg__",
+			     &all_regs_rtx[sn], plen, 2);
+	      have_carry = true;
+	    }
+	  while (++sn < s0)
+	    avr_asm_len ("cpc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
+	  avr_asm_len (have_carry ? "sbci %0,128" : "subi %0,129",
+		       &all_regs_rtx[s0], plen, 1);
+	  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)
+	    avr_asm_len ("sbci %0,255", &all_regs_rtx[sn], plen, 1);
+	  avr_asm_len ("\n0:", NULL, plen, 0);
+	  frac_rounded = true;
+	}
+      else if (use_src && overlap)
+	{
+	  avr_asm_len ("clr __tmp_reg__" CR_TAB
+		       "sbrc %1,0" CR_TAB "dec __tmp_reg__", xop, plen, 1);
+	  sn = src.regno;
+	  if (sn < s0)
+	    {
+	      avr_asm_len ("add %0,__tmp_reg__", &all_regs_rtx[sn], plen, 1);
+	      have_carry = true;
+	    }
+	  while (++sn < s0)
+	    avr_asm_len ("adc %0,__tmp_reg__", &all_regs_rtx[sn], plen, 1);
+	  if (have_carry)
+	    avr_asm_len ("clt" CR_TAB "bld __tmp_reg__,7" CR_TAB
+			 "adc %0,__tmp_reg__",
+			 &all_regs_rtx[s0], plen, 1);
+	  else
+	    avr_asm_len ("lsr __tmp_reg" CR_TAB "add %0,__tmp_reg__",
+			 &all_regs_rtx[s0], plen, 2);
+	  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)
+	    avr_asm_len ("adc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
+	  frac_rounded = true;
+	}
+      else if (overlap)
+	{
+	  bool use_src
+	    = (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0)
+	       && (IN_RANGE (s0, dest.regno, dest.regno_msb)
+		   || reg_unused_after (insn, all_regs_rtx[s0])));
+	  xop[2] = all_regs_rtx[s0];
+	  unsigned sn = src.regno;
+	  if (!use_src || sn == s0)
+	    avr_asm_len ("mov __tmp_reg__,%2", xop, plen, 1);
+	  /* We need to consider to-be-discarded bits
+	     if the value is negative.  */
+	  if (sn < s0)
+	    {
+	      avr_asm_len ("tst %0" CR_TAB "brpl 0f",
+			   &all_regs_rtx[src.regno_msb], plen, 2);
+	      /* Test to-be-discarded bytes for any nozero bits.
+		 ??? Could use OR or SBIW to test two registers at once.  */
+	      if (sn < s0)
+		avr_asm_len ("cp %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
+	      while (++sn < s0)
+		avr_asm_len ("cpc %0,__zero_reg__", &all_regs_rtx[sn], plen, 1);
+	      /* Set bit 0 in __tmp_reg__ if any of the lower bits was set.  */
+	      if (use_src)
+		avr_asm_len ("breq 0f" CR_TAB
+			     "ori %2,1" "\n0:\t" "mov __tmp_reg__,%2",
+			     xop, plen, 3);
+	      else
+		avr_asm_len ("breq 0f" CR_TAB
+			     "set" CR_TAB "bld __tmp_reg__,0\n0:",
+			     xop, plen, 3);
+	    }
+	  lsb_in_tmp_reg = true;
+	}
+    }
+
   /* Step 1:  Clear bytes at the low end and copy payload bits from source
      ======   to destination.  */
 
   int step = offset < 0 ? 1 : -1;
   unsigned d0 = offset < 0 ? dest.regno : dest.regno_msb;
 
-  // We leared at least that number of registers.
+  // We cleared at least that number of registers.
   int clr_n = 0;
 
   for (; d0 >= dest.regno && d0 <= dest.regno_msb; d0 += step)
@@ -7195,6 +8034,7 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
           unsigned src_lsb = dest.regno - offset -1;
 
           if (shift == ASHIFT && src.fbyte > dest.fbyte && !lsb_in_carry
+	      && !lsb_in_tmp_reg
               && (d0 == src_lsb || d0 + stepw == src_lsb))
             {
               /* We are going to override the new LSB; store it into carry.  */
@@ -7216,7 +8056,91 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
     {
       unsigned s0 = dest.regno - offset -1;
 
-      if (MAY_CLOBBER (s0))
+      /* n1169 4.1.4 says:
+	 "Conversions from a fixed-point to an integer type round toward zero."
+	 Hence, converting a fract type to integer only gives a non-zero result
+	 for -1.  */
+      if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))
+	  && SCALAR_FRACT_MODE_P (GET_MODE (xop[1]))
+	  && !TARGET_FRACT_CONV_TRUNC)
+	{
+	  gcc_assert (s0 == src.regno_msb);
+	  /* Check if the input is -1.  We do that by checking if negating
+	     the input causes an integer overflow.  */
+	  unsigned sn = src.regno;
+	  avr_asm_len ("cp __zero_reg__,%0", &all_regs_rtx[sn++], plen, 1);
+	  while (sn <= s0)
+	    avr_asm_len ("cpc __zero_reg__,%0", &all_regs_rtx[sn++], plen, 1);
+
+	  /* Overflow goes with set carry.  Clear carry otherwise.  */
+	  avr_asm_len ("brvs 0f" CR_TAB "clc\n0:", NULL, plen, 2);
+	}
+      /* Likewise, when converting from accumulator types to integer, we
+	 need to round up negative values.  */
+      else if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))
+	       && SCALAR_ACCUM_MODE_P (GET_MODE (xop[1]))
+	       && !TARGET_FRACT_CONV_TRUNC
+	       && !frac_rounded)
+	{
+	  bool have_carry = false;
+
+	  xop[2] = all_regs_rtx[s0];
+	  if (!lsb_in_tmp_reg && !MAY_CLOBBER (s0))
+	    avr_asm_len ("mov __tmp_reg__,%2", xop, plen, 1);
+	  avr_asm_len ("tst %0" CR_TAB "brpl 0f",
+		       &all_regs_rtx[src.regno_msb], plen, 2);
+	  if (!lsb_in_tmp_reg)
+	    {
+	      unsigned sn = src.regno;
+	      if (sn < s0)
+		{
+		  avr_asm_len ("cp __zero_reg__,%0", &all_regs_rtx[sn],
+			       plen, 1);
+		  have_carry = true;
+		}
+	      while (++sn < s0)
+		avr_asm_len ("cpc __zero_reg__,%0", &all_regs_rtx[sn], plen, 1);
+	      lsb_in_tmp_reg = !MAY_CLOBBER (s0);
+	    }
+	  /* Add in C and the rounding value 127.  */
+	  /* If the destination msb is a sign byte, and in LD_REGS,
+	     grab it as a temporary.  */
+	  if (sign_bytes
+	      && TEST_HARD_REG_BIT (reg_class_contents[LD_REGS],
+				    dest.regno_msb))
+	    {
+	      xop[3] = all_regs_rtx[dest.regno_msb];
+	      avr_asm_len ("ldi %3,127", xop, plen, 1);
+	      avr_asm_len ((have_carry && lsb_in_tmp_reg ? "adc __tmp_reg__,%3"
+			   : have_carry ? "adc %2,%3"
+			   : lsb_in_tmp_reg ? "add __tmp_reg__,%3"
+			   : "add %2,%3"),
+			   xop, plen, 1);
+	    }
+	  else
+	    {
+	      /* Fall back to use __zero_reg__ as a temporary.  */
+	      avr_asm_len ("dec __zero_reg__", NULL, plen, 1);
+	      if (have_carry)
+		avr_asm_len ("clt" CR_TAB "bld __zero_reg__,7", NULL, plen, 2);
+	      else
+		avr_asm_len ("lsr __zero_reg__", NULL, plen, 1);
+	      avr_asm_len ((have_carry && lsb_in_tmp_reg
+			   ? "adc __tmp_reg__,__zero_reg__"
+			   : have_carry ? "adc %2,__zero_reg__"
+			   : lsb_in_tmp_reg ? "add __tmp_reg__,__zero_reg__"
+			   : "add %2,__zero_reg__"),
+			   xop, plen, 1);
+	      avr_asm_len ("eor __zero_reg__,__zero_reg__", NULL, plen, 1);
+	    }
+	  for (d0 = dest.regno + zero_bytes;
+	       d0 <= dest.regno_msb - sign_bytes; d0++)
+	    avr_asm_len ("adc %0,__zero_reg__", &all_regs_rtx[d0], plen, 1);
+	  avr_asm_len (lsb_in_tmp_reg
+		       ? "\n0:\t" "lsl __tmp_reg__" : "\n0:\t" "lsl %2",
+		       xop, plen, 1);
+	}
+      else if (MAY_CLOBBER (s0))
         avr_asm_len ("lsl %0", &all_regs_rtx[s0], plen, 1);
       else
         avr_asm_len ("mov __tmp_reg__,%0" CR_TAB
@@ -7325,6 +8249,67 @@ avr_out_fract (rtx insn, rtx operands[], bool intsigned, int *plen)
 }
 
 
+/* Output fixed-point rounding.  XOP[0] = XOP[1] is the operand to round.
+   XOP[2] is the rounding point, a CONST_INT.  The function prints the
+   instruction sequence if PLEN = NULL and computes the length in words
+   of the sequence if PLEN != NULL.  Most of this function deals with
+   preparing operands for calls to `avr_out_plus' and `avr_out_bitop'.  */
+
+const char*
+avr_out_round (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)
+{
+  enum machine_mode mode = GET_MODE (xop[0]);
+  enum machine_mode imode = int_mode_for_mode (mode);
+  // The smallest fractional bit not cleared by the rounding is 2^(-RP).
+  int fbit = (int) GET_MODE_FBIT (mode);
+  double_int i_add = double_int_zero.set_bit (fbit-1 - INTVAL (xop[2]));
+  // Lengths of PLUS and AND parts.
+  int len_add = 0, *plen_add = plen ? &len_add : NULL;
+  int len_and = 0, *plen_and = plen ? &len_and : NULL;
+
+  // Add-Saturate  1/2 * 2^(-RP).  Don't print the label "0:" when printing
+  // the saturated addition so that we can emit the "rjmp 1f" before the
+  // "0:" below.
+
+  rtx xadd = const_fixed_from_double_int (i_add, mode);
+  rtx xpattern, xsrc, op[4];
+
+  xsrc = SIGNED_FIXED_POINT_MODE_P (mode)
+    ? gen_rtx_SS_PLUS (mode, xop[1], xadd)
+    : gen_rtx_US_PLUS (mode, xop[1], xadd);
+  xpattern = gen_rtx_SET (VOIDmode, xop[0], xsrc);
+
+  op[0] = xop[0];
+  op[1] = xop[1];
+  op[2] = xadd;
+  avr_out_plus (xpattern, op, plen_add, NULL, false /* Don't print "0:" */);
+
+  avr_asm_len ("rjmp 1f" CR_TAB
+               "0:", NULL, plen_add, 1);
+
+  // Keep  all bits from RP and higher:   ... 2^(-RP)
+  // Clear all bits from RP+1 and lower:              2^(-RP-1) ...
+  // Rounding point                           ^^^^^^^
+  // Added above                                      ^^^^^^^^^
+  rtx xreg = simplify_gen_subreg (imode, xop[0], mode, 0);
+  rtx xmask = immed_double_int_const (-i_add - i_add, imode);
+
+  xpattern = gen_rtx_SET (VOIDmode, xreg, gen_rtx_AND (imode, xreg, xmask));
+
+  op[0] = xreg;
+  op[1] = xreg;
+  op[2] = xmask;
+  op[3] = gen_rtx_SCRATCH (QImode);
+  avr_out_bitop (xpattern, op, plen_and);
+  avr_asm_len ("1:", NULL, plen, 0);
+
+  if (plen)
+    *plen = len_add + len_and;
+
+  return "";
+}
+
+
 /* Create RTL split patterns for byte sized rotate expressions.  This
   produces a series of move instructions and considers overlap situations.
   Overlapping non-HImode operands need a scratch register.  */
@@ -7533,6 +8518,7 @@ avr_adjust_insn_length (rtx insn, int len)
 
     case ADJUST_LEN_SFRACT: avr_out_fract (insn, op, true, &len); break;
     case ADJUST_LEN_UFRACT: avr_out_fract (insn, op, false, &len); break;
+    case ADJUST_LEN_ROUND: avr_out_round (insn, op, &len); break;
 
     case ADJUST_LEN_TSTHI: avr_out_tsthi (insn, op, &len); break;
     case ADJUST_LEN_TSTPSI: avr_out_tstpsi (insn, op, &len); break;
@@ -7743,7 +8729,8 @@ avr_assemble_integer (rtx x, unsigned int size, int aligned_p)
 static bool
 avr_class_likely_spilled_p (reg_class_t c)
 {
-  return (c != ALL_REGS && c != ADDW_REGS);
+  return (c != ALL_REGS &&
+           (AVR_TINY ? 1 : c != ADDW_REGS));
 }
 
 
@@ -7843,6 +8830,8 @@ avr_attribute_table[] =
     false },
   { "interrupt", 0, 0, true,  false, false,  avr_handle_fndecl_attribute,
     false },
+  { "nmi",       0, 0, true,  false, false,  avr_handle_fndecl_attribute,
+    false },
   { "naked",     0, 0, false, true,  true,   avr_handle_fntype_attribute,
     false },
   { "OS_task",   0, 0, false, true,  true,   avr_handle_fntype_attribute,
@@ -8324,7 +9313,10 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)
       && SYMBOL_REF == GET_CODE (XEXP (rtl, 0)))
    {
       rtx sym = XEXP (rtl, 0);
-      addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (decl));
+      tree type = TREE_TYPE (decl);
+      if (type == error_mark_node)
+	return;
+      addr_space_t as = TYPE_ADDR_SPACE (type);
 
       /* PSTR strings are in generic space but located in flash:
          patch address space.  */
@@ -8410,10 +9402,10 @@ avr_file_start (void)
     fprintf (asm_out_file, "__RAMPX__ = 0x%02x\n", avr_addr.rampx - sfr_offset);
   if (AVR_HAVE_RAMPD)
     fprintf (asm_out_file, "__RAMPD__ = 0x%02x\n", avr_addr.rampd - sfr_offset);
-  if (AVR_XMEGA)
+  if (AVR_XMEGA || AVR_TINY)
     fprintf (asm_out_file, "__CCP__ = 0x%02x\n", avr_addr.ccp - sfr_offset);
-  fprintf (asm_out_file, "__tmp_reg__ = %d\n", TMP_REGNO);
-  fprintf (asm_out_file, "__zero_reg__ = %d\n", ZERO_REGNO);
+  fprintf (asm_out_file, "__tmp_reg__ = %d\n", AVR_TMP_REGNO);
+  fprintf (asm_out_file, "__zero_reg__ = %d\n", AVR_ZERO_REGNO);
 }
 
 
@@ -8460,6 +9452,18 @@ avr_adjust_reg_alloc_order (void)
       0, 1,
       32, 33, 34, 35
   };
+  static const int tiny_order_0[] = {
+    20, 21,
+    22, 23,
+    24, 25,
+    30, 31,
+    26, 27,
+    28, 29,
+    19, 18,
+    16, 17,
+    32, 33, 34, 35,
+    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+  };
   static const int order_1[] =
     {
       18, 19, 20, 21, 22, 23, 24, 25,
@@ -8469,6 +9473,17 @@ avr_adjust_reg_alloc_order (void)
       0, 1,
       32, 33, 34, 35
   };
+  static const int tiny_order_1[] = {
+    22, 23,
+    24, 25,
+    30, 31,
+    26, 27,
+    28, 29,
+    21, 20, 19, 18,
+    16, 17,
+    32, 33, 34, 35,
+    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+  };
   static const int order_2[] =
     {
       25, 24, 23, 22, 21, 20, 19, 18,
@@ -8479,9 +9494,14 @@ avr_adjust_reg_alloc_order (void)
       32, 33, 34, 35
   };
 
-  const int *order = (TARGET_ORDER_1 ? order_1 :
-		      TARGET_ORDER_2 ? order_2 :
-		      order_0);
+  /*
+  Select specific register allocation order. Tiny Core (attiny4/5/9/10/20/40)
+  devices has only 16 registers, so different allocation order should be used
+  */ 
+  const int *order = (TARGET_ORDER_1 ? (AVR_TINY ? tiny_order_1 : order_1) :
+             TARGET_ORDER_2 ? (AVR_TINY ? tiny_order_0 : order_2) :
+                                       (AVR_TINY ? tiny_order_0 : order_0));
+
   for (i = 0; i < ARRAY_SIZE (order_0); ++i)
       reg_alloc_order[i] = order[i];
 }
@@ -10163,7 +11183,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)
         {
           if (!clear_p)
             avr_asm_len (ldreg_p ? "ldi %0,0"
-                         : ZERO_REGNO == REGNO (xdest[n]) ? "clr %0"
+                         : AVR_ZERO_REGNO == REGNO (xdest[n]) ? "clr %0"
                          : "mov %0,__zero_reg__",
                          &xdest[n], len, 1);
           continue;
@@ -10365,6 +11385,49 @@ avr_output_addr_vec_elt (FILE *stream, int value)
     fprintf (stream, "\trjmp .L%d\n", value);
 }
 
+static void
+avr_conditional_register_usage(void) {
+
+  if (AVR_TINY) {
+    unsigned int i;
+
+    const int tiny_reg_alloc_order[] = {
+      24, 25,
+      22, 23,
+      30, 31,
+      26, 27,
+      28, 29,
+      21, 20, 19, 18,
+      16, 17,
+      32, 33, 34, 35,
+      15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+    };
+
+    /* Set R0-R17 as fixed registers. Reset R0-R17 in call used register list
+    - R0-R15 are not available in Tiny Core devices
+    - R16 and R17 are fixed registers
+    */
+    for (i = 0;  i <= 17;  i++) {
+      fixed_regs[i] = 1;
+      call_used_regs[i] = 1;
+    }
+
+    /* Set R18 to R21 as callee saved registers
+    - R18, R19, R20 and R21 are the callee saved registers in Tiny Core devices
+    */
+    for (i = 18; i <= LAST_CALLEE_SAVED_REG; i++) {
+      call_used_regs[i] = 0;
+    }
+
+    /*update register allocation order for Tiny Core devices */
+    for (i=0; i < ARRAY_SIZE (tiny_reg_alloc_order); i++) {
+      reg_alloc_order[i] = tiny_reg_alloc_order[i];
+    }
+
+    CLEAR_HARD_REG_SET(reg_class_contents[(int)ADDW_REGS]);
+    CLEAR_HARD_REG_SET(reg_class_contents[(int)NO_LD_REGS]);
+  }
+}
 
 /* Implement `TARGET_HARD_REGNO_SCRATCH_OK'.  */
 /* Returns true if SCRATCH are safe to be allocated as a scratch
@@ -10516,13 +11579,20 @@ avr_asm_out_dtor (rtx symbol, int priority)
 static bool
 avr_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 {
-  if (TYPE_MODE (type) == BLKmode)
-    {
-      HOST_WIDE_INT size = int_size_in_bytes (type);
-      return (size == -1 || size > 8);
-    }
+  HOST_WIDE_INT size = int_size_in_bytes (type);
+  HOST_WIDE_INT ret_size_limit = AVR_TINY ? 4 : 8;                                      
+
+  /* In avr, there are 8 return registers. But, for Tiny Core 
+  (attiny4/5/9/10/20/40) devices, only 4 registers available.
+  Return true if size is unknown or greater than the limit */
+  if ((size == -1) || (size > ret_size_limit))
+  {
+    return true;
+  }
   else
+  {
     return false;
+  }
 }
 
 
@@ -12157,6 +13227,9 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,
 #undef  TARGET_BUILTIN_SETJMP_FRAME_VALUE
 #define TARGET_BUILTIN_SETJMP_FRAME_VALUE avr_builtin_setjmp_frame_value
 
+#undef TARGET_CONDITIONAL_REGISTER_USAGE
+#define TARGET_CONDITIONAL_REGISTER_USAGE avr_conditional_register_usage
+
 #undef  TARGET_HARD_REGNO_SCRATCH_OK
 #define TARGET_HARD_REGNO_SCRATCH_OK avr_hard_regno_scratch_ok
 #undef  TARGET_CASE_VALUES_THRESHOLD
diff --git gcc/config/avr/avr.h gcc/config/avr/avr.h
index f223a61..b592465 100644
--- gcc/config/avr/avr.h
+++ gcc/config/avr/avr.h
@@ -97,6 +97,7 @@ enum
 #define AVR_3_BYTE_PC (AVR_HAVE_EIJMP_EICALL)
 
 #define AVR_XMEGA (avr_current_arch->xmega_p)
+#define AVR_TINY  (avr_current_arch->tiny_p)
 
 #define BITS_BIG_ENDIAN 0
 #define BYTES_BIG_ENDIAN 0
@@ -144,6 +145,8 @@ enum
 #define SIZE_TYPE (INT_TYPE_SIZE == 8 ? "long unsigned int" : "unsigned int")
 #define PTRDIFF_TYPE (INT_TYPE_SIZE == 8 ? "long int" :"int")
 
+#define WCHAR_TYPE "int"
+#define WINT_TYPE "int"
 #define WCHAR_TYPE_SIZE 16
 
 #define FIRST_PSEUDO_REGISTER 36
@@ -303,7 +306,7 @@ enum reg_class {
 
 #define ARG_POINTER_REGNUM 34
 
-#define STATIC_CHAIN_REGNUM 2
+#define STATIC_CHAIN_REGNUM ((AVR_TINY) ? 18 :2)
 
 #define ELIMINABLE_REGS {					\
       {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},		\
@@ -510,7 +513,8 @@ extern const char *avr_device_to_sp8 (int argc, const char **argv);
     %{!fenforce-eh-specs:-fno-enforce-eh-specs} \
     %{!fexceptions:-fno-exceptions}"
 
-#define ASM_SPEC "%:device_to_as(%{mmcu=*:%*}) "
+#define ASM_SPEC "%:device_to_as(%{mmcu=*:%*})\
+%{mrelax:-mlink-relax}"
   
 #define LINK_SPEC "\
 %{mrelax:--relax\
@@ -571,6 +575,10 @@ struct GTY(()) machine_function
   /* 'true' - if current function is a signal function 
      as specified by the "signal" attribute.  */
   int is_signal;
+
+  /* 'true' - if current function is an nmi function 
+     as specified by the "nmi" attribute.  */
+  int is_nmi;
   
   /* 'true' - if current function is a 'task' function 
      as specified by the "OS_task" attribute.  */
diff --git gcc/config/avr/avr.md gcc/config/avr/avr.md
index e9f5d03..d539e31 100644
--- gcc/config/avr/avr.md
+++ gcc/config/avr/avr.md
@@ -24,6 +24,10 @@
 ;;  B  Add 1 to REG number, MEM address or CONST_INT.
 ;;  C  Add 2.
 ;;  D  Add 3.
+;;  E  reg number in XEXP(x, 0).
+;;  F  Add 1 to reg number.
+;;  I  reg number in XEXP(XEXP(x, 0), 0).
+;;  J  Add 1 to reg number.
 ;;  j  Branch condition.
 ;;  k  Reverse branch condition.
 ;;..m..Constant Direct Data memory address.
@@ -32,6 +36,7 @@
 ;;  o  Displacement for (mem (plus (reg) (const_int))) operands.
 ;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)
 ;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)
+;;  r  Print a REG without the register prefix 'r'.
 ;; T/T Print operand suitable for BLD/BST instruction, i.e. register and
 ;;     bit number.  This gets 2 operands: The first %T gets a REG_P and
 ;;     just cashes the operand for the next %T.  The second %T gets
@@ -58,6 +63,11 @@
    (ZERO_REGNO  1)      ; zero register r1
    ])
 
+(define_constants
+  [ (TMP_REGNO_TINY 16)  ; r16 is temp register for AVR_TINY
+    (ZERO_REGNO_TINY 17) ; r17 is zero register for AVR_TINY
+  ])
+
 (define_c_enum "unspec"
   [UNSPEC_STRLEN
    UNSPEC_MOVMEM
@@ -140,7 +150,7 @@
   "out_bitop, plus, addto_sp,
    tsthi, tstpsi, tstsi, compare, compare64, call,
    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,
-   ufract, sfract,
+   ufract, sfract, round,
    xload, lpm, movmem,
    ashlqi, ashrqi, lshrqi,
    ashlhi, ashrhi, lshrhi,
@@ -158,9 +168,10 @@
 ;; lpm  : ISA has no LPMX                lpmx  : ISA has LPMX
 ;; elpm : ISA has ELPM but no ELPMX      elpmx : ISA has ELPMX
 ;; no_xmega: non-XMEGA core              xmega : XMEGA core
+;; no_tiny:  non-TINY core               tiny  : TINY core
 
 (define_attr "isa"
-  "mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega,
+  "mov,movw, rjmp,jmp, ijmp,eijmp, lpm,lpmx, elpm,elpmx, no_xmega,xmega, no_tiny,tiny,
    standard"
   (const_string "standard"))
 
@@ -212,9 +223,18 @@
               (match_test "AVR_XMEGA"))
          (const_int 1)
 
+         (and (eq_attr "isa" "tiny")
+              (match_test "AVR_TINY"))
+         (const_int 1)
+
          (and (eq_attr "isa" "no_xmega")
               (match_test "!AVR_XMEGA"))
          (const_int 1)
+
+         (and (eq_attr "isa" "no_tiny")
+              (match_test "!AVR_TINY"))
+         (const_int 1)
+
          ] (const_int 0)))
 
 
@@ -609,6 +629,33 @@
         emit_insn (gen_load<mode>_libgcc (dest, src));
         DONE;
       }
+
+    /* AVRTC-579
+    if the source operand expression is out of range for 'lds' instruction
+      copy source operand expression to register
+    For tiny core, LDS instruction's memory access range limited to 0x40..0xbf
+    */
+    if (!tiny_valid_direct_memory_access_range(src,<MODE>mode))
+      {
+        rtx srcx = XEXP(src,0);
+        operands[1] = src = replace_equiv_address (src,copy_to_mode_reg (GET_MODE(srcx),srcx));
+        emit_move_insn(dest,src);
+        DONE;
+      }
+
+    /* AVRTC-579
+    if the destination operand expression is out of range for 'sts' instruction
+      copy destination operand expression to register
+    For tiny core, STS instruction's memory access range limited to 0x40..0xbf
+    */
+    if (!tiny_valid_direct_memory_access_range(dest,<MODE>mode))
+    {
+      rtx destx = XEXP(dest,0);
+      operands[0] = dest = replace_equiv_address (dest,copy_to_mode_reg (GET_MODE(destx),destx));
+      emit_move_insn(dest,src);
+      DONE;
+    }
+
   })
 
 ;;========================================================================
@@ -625,8 +672,13 @@
 (define_insn "mov<mode>_insn"
   [(set (match_operand:ALL1 0 "nonimmediate_operand" "=r    ,d    ,Qm   ,r ,q,r,*r")
         (match_operand:ALL1 1 "nox_general_operand"   "r Y00,n Ynn,r Y00,Qm,r,q,i"))]
-  "register_operand (operands[0], <MODE>mode)
-   || reg_or_0_operand (operands[1], <MODE>mode)"
+  "(register_operand (operands[0], <MODE>mode)
+   || reg_or_0_operand (operands[1], <MODE>mode)) &&
+   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)
+   though access range is checked during define_expand, it is required
+   here to avoid merging rtls during combine pass */
+   tiny_valid_direct_memory_access_range(operands[0],QImode) &&
+   tiny_valid_direct_memory_access_range(operands[1],QImode)"
   {
     return output_movqi (insn, operands, NULL);
   }
@@ -719,8 +771,13 @@
 (define_insn "*mov<mode>"
   [(set (match_operand:ALL2 0 "nonimmediate_operand" "=r,r  ,r,m    ,d,*r,q,r")
         (match_operand:ALL2 1 "nox_general_operand"   "r,Y00,m,r Y00,i,i ,r,q"))]
-  "register_operand (operands[0], <MODE>mode)
-   || reg_or_0_operand (operands[1], <MODE>mode)"
+  "(register_operand (operands[0], <MODE>mode)
+   || reg_or_0_operand (operands[1], <MODE>mode)) &&
+   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)
+   though access range is checked during define_expand, it is required
+   here to avoid merging rtls during combine pass */
+   tiny_valid_direct_memory_access_range(operands[0],HImode) &&
+   tiny_valid_direct_memory_access_range(operands[1],HImode)"
   {
     return output_movhi (insn, operands, NULL);
   }
@@ -868,8 +925,13 @@
 (define_insn "*mov<mode>"
   [(set (match_operand:ALL4 0 "nonimmediate_operand" "=r,r  ,r ,Qm   ,!d,r")
         (match_operand:ALL4 1 "nox_general_operand"   "r,Y00,Qm,r Y00,i ,i"))]
-  "register_operand (operands[0], <MODE>mode)
-   || reg_or_0_operand (operands[1], <MODE>mode)"
+  "(register_operand (operands[0], <MODE>mode)
+   || reg_or_0_operand (operands[1], <MODE>mode)) &&
+   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)
+   though access range is checked during define_expand, it is required
+   here to avoid merging rtls during combine pass */
+   tiny_valid_direct_memory_access_range(operands[0],SImode) &&
+   tiny_valid_direct_memory_access_range(operands[1],SImode)"
   {
     return output_movsisf (insn, operands, NULL);
   }
@@ -883,8 +945,13 @@
 (define_insn "*movsf"
   [(set (match_operand:SF 0 "nonimmediate_operand" "=r,r,r ,Qm,!d,r")
         (match_operand:SF 1 "nox_general_operand"   "r,G,Qm,rG,F ,F"))]
-  "register_operand (operands[0], SFmode)
-   || reg_or_0_operand (operands[1], SFmode)"
+  "(register_operand (operands[0], SFmode)
+   || reg_or_0_operand (operands[1], SFmode)) &&
+   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)
+   though access range is checked during define_expand, it is required
+   here to avoid merging rtls during combine pass */
+   tiny_valid_direct_memory_access_range(operands[0],SFmode) &&
+   tiny_valid_direct_memory_access_range(operands[1],SFmode)"
   {
     return output_movsisf (insn, operands, NULL);
   }
@@ -5510,18 +5577,18 @@
    (set_attr "cc" "clobber")])
 
 (define_insn "delay_cycles_2"
-  [(unspec_volatile [(match_operand:HI 0 "const_int_operand" "n")
+  [(unspec_volatile [(match_operand:HI 0 "const_int_operand" "n,n")
                      (const_int 2)]
                     UNSPECV_DELAY_CYCLES)
    (set (match_operand:BLK 1 "" "")
 	(unspec_volatile:BLK [(match_dup 1)] UNSPECV_MEMORY_BARRIER))
-   (clobber (match_scratch:HI 2 "=&w"))]
+   (clobber (match_scratch:HI 2 "=&w,&d"))]
   ""
-  "ldi %A2,lo8(%0)
-	ldi %B2,hi8(%0)
-	1: sbiw %A2,1
-	brne 1b"
-  [(set_attr "length" "4")
+  "@
+    ldi %A2,lo8(%0)\;ldi %B2,hi8(%0)\;1: sbiw %A2,1\;brne 1b
+    ldi %A2,lo8(%0)\;ldi %B2,hi8(%0)\;1: subi %A2,1\;sbci %B2,0\;brne 1b"
+  [(set_attr "length" "4,5")
+   (set_attr "isa" "no_tiny,tiny")
    (set_attr "cc" "clobber")])
 
 (define_insn "delay_cycles_3"
diff --git gcc/config/avr/avr.opt gcc/config/avr/avr.opt
index 6b2e755..9b0f782 100644
--- gcc/config/avr/avr.opt
+++ gcc/config/avr/avr.opt
@@ -77,4 +77,8 @@ The device has no SPH special function register. This option will be overridden
 
 Waddr-space-convert
 Warning C Report Var(avr_warn_addr_space_convert) Init(0)
-Warn if the address space of an address is change.
+Warn if the address space of an address is changed.
+
+mfract-convert-truncate
+Target Report Mask(FRACT_CONV_TRUNC)
+Allow to use truncation instead of rounding towards 0 for fractional int types
diff --git gcc/config/avr/gen-avr-mmcu-texi.c gcc/config/avr/gen-avr-mmcu-texi.c
index 55335f9..e69cd41 100644
--- gcc/config/avr/gen-avr-mmcu-texi.c
+++ gcc/config/avr/gen-avr-mmcu-texi.c
@@ -68,6 +68,7 @@ comparator (const void *va, const void *vb)
 static void
 print_mcus (size_t n_mcus)
 {
+  int duplicate = 0;
   size_t i;
     
   if (!n_mcus)
@@ -78,7 +79,20 @@ print_mcus (size_t n_mcus)
   printf ("@*@var{mcu}@tie{}=");
 
   for (i = 0; i < n_mcus; i++)
-    printf (" @code{%s}%s", mcu_name[i], i == n_mcus-1 ? ".\n\n" : ",");
+    {
+      printf (" @code{%s}%s", mcu_name[i], i == n_mcus-1 ? ".\n\n" : ",");
+
+      if (i && !strcmp (mcu_name[i], mcu_name[i-1]))
+        {
+          /* Sanity-check: Fail on devices that are present more than once.  */
+
+          duplicate = 1;
+          fprintf (stderr, "error: duplicate device: %s\n", mcu_name[i]);
+        }
+    }
+
+  if (duplicate)
+    exit (1);
 }
 
 int main (void)
diff --git gcc/config/avr/t-multilib gcc/config/avr/t-multilib
index 6b1db60..e7e478d 100644
--- gcc/config/avr/t-multilib
+++ gcc/config/avr/t-multilib
@@ -21,9 +21,9 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7 msp8
+MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avr7/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7/mmcu=avrtiny msp8
 
-MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 tiny-stack avr25/tiny-stack
+MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avr7 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny tiny-stack avr25/tiny-stack
 
 MULTILIB_EXCEPTIONS = \
 	mmcu=avr3/msp8 \
@@ -33,11 +33,13 @@ MULTILIB_EXCEPTIONS = \
 	mmcu=avr5/msp8 \
 	mmcu=avr51/msp8 \
 	mmcu=avr6/msp8 \
+	mmcu=avr7/msp8 \
 	mmcu=avrxmega2/msp8 \
 	mmcu=avrxmega4/msp8 \
 	mmcu=avrxmega5/msp8 \
 	mmcu=avrxmega6/msp8 \
-	mmcu=avrxmega7/msp8
+	mmcu=avrxmega7/msp8 \
+	mmcu=avrtiny/msp8
 
 MULTILIB_MATCHES = \
 	mmcu?avr2=mmcu?at90s2313 \
@@ -52,8 +54,8 @@ MULTILIB_MATCHES = \
 	mmcu?avr2=mmcu?at90s8515 \
 	mmcu?avr2=mmcu?at90c8534 \
 	mmcu?avr2=mmcu?at90s8535 \
-	mmcu?avr25=mmcu?ata6289 \
 	mmcu?avr25=mmcu?ata5272 \
+	mmcu?avr25=mmcu?ata6616c \
 	mmcu?avr25=mmcu?attiny13 \
 	mmcu?avr25=mmcu?attiny13a \
 	mmcu?avr25=mmcu?attiny2313 \
@@ -63,6 +65,7 @@ MULTILIB_MATCHES = \
 	mmcu?avr25=mmcu?attiny4313 \
 	mmcu?avr25=mmcu?attiny44 \
 	mmcu?avr25=mmcu?attiny44a \
+	mmcu?avr25=mmcu?attiny441 \
 	mmcu?avr25=mmcu?attiny84 \
 	mmcu?avr25=mmcu?attiny84a \
 	mmcu?avr25=mmcu?attiny25 \
@@ -78,12 +81,16 @@ MULTILIB_MATCHES = \
 	mmcu?avr25=mmcu?attiny87 \
 	mmcu?avr25=mmcu?attiny48 \
 	mmcu?avr25=mmcu?attiny88 \
+	mmcu?avr25=mmcu?attiny828 \
+	mmcu?avr25=mmcu?attiny841 \
 	mmcu?avr25=mmcu?at86rf401 \
 	mmcu?avr3=mmcu?at43usb355 \
 	mmcu?avr3=mmcu?at76c711 \
 	mmcu?avr31=mmcu?atmega103 \
 	mmcu?avr31=mmcu?at43usb320 \
 	mmcu?avr35=mmcu?ata5505 \
+	mmcu?avr35=mmcu?ata6617c \
+	mmcu?avr35=mmcu?ata664251 \
 	mmcu?avr35=mmcu?at90usb82 \
 	mmcu?avr35=mmcu?at90usb162 \
 	mmcu?avr35=mmcu?atmega8u2 \
@@ -93,6 +100,8 @@ MULTILIB_MATCHES = \
 	mmcu?avr35=mmcu?attiny1634 \
 	mmcu?avr4=mmcu?ata6285 \
 	mmcu?avr4=mmcu?ata6286 \
+	mmcu?avr4=mmcu?ata6289 \
+	mmcu?avr4=mmcu?ata6612c \
 	mmcu?avr4=mmcu?atmega8 \
 	mmcu?avr4=mmcu?atmega8a \
 	mmcu?avr4=mmcu?atmega48 \
@@ -115,6 +124,8 @@ MULTILIB_MATCHES = \
 	mmcu?avr5=mmcu?ata5790 \
 	mmcu?avr5=mmcu?ata5790n \
 	mmcu?avr5=mmcu?ata5795 \
+	mmcu?avr5=mmcu?ata6613c \
+	mmcu?avr5=mmcu?ata6614q \
 	mmcu?avr5=mmcu?atmega16 \
 	mmcu?avr5=mmcu?atmega16a \
 	mmcu?avr5=mmcu?atmega161 \
@@ -135,15 +146,12 @@ MULTILIB_MATCHES = \
 	mmcu?avr5=mmcu?atmega169a \
 	mmcu?avr5=mmcu?atmega169p \
 	mmcu?avr5=mmcu?atmega169pa \
-	mmcu?avr5=mmcu?atmega16hva \
 	mmcu?avr5=mmcu?atmega16hvb \
 	mmcu?avr5=mmcu?atmega16hvbrevb \
 	mmcu?avr5=mmcu?atmega16m1 \
 	mmcu?avr5=mmcu?atmega16u4 \
-	mmcu?avr5=mmcu?atmega26hvg \
 	mmcu?avr5=mmcu?atmega32a \
 	mmcu?avr5=mmcu?atmega32 \
-	mmcu?avr5=mmcu?atmega32a \
 	mmcu?avr5=mmcu?atmega323 \
 	mmcu?avr5=mmcu?atmega324a \
 	mmcu?avr5=mmcu?atmega324p \
@@ -151,6 +159,7 @@ MULTILIB_MATCHES = \
 	mmcu?avr5=mmcu?atmega325 \
 	mmcu?avr5=mmcu?atmega325a \
 	mmcu?avr5=mmcu?atmega325p \
+	mmcu?avr5=mmcu?atmega325pa \
 	mmcu?avr5=mmcu?atmega3250 \
 	mmcu?avr5=mmcu?atmega3250a \
 	mmcu?avr5=mmcu?atmega3250p \
@@ -189,32 +198,21 @@ MULTILIB_MATCHES = \
 	mmcu?avr5=mmcu?atmega6490 \
 	mmcu?avr5=mmcu?atmega16hva \
 	mmcu?avr5=mmcu?atmega16hva2 \
-	mmcu?avr5=mmcu?atmega16hvb \
 	mmcu?avr5=mmcu?atmega32hvb \
 	mmcu?avr5=mmcu?atmega6490a \
 	mmcu?avr5=mmcu?atmega6490p \
 	mmcu?avr5=mmcu?atmega64c1 \
 	mmcu?avr5=mmcu?atmega64m1 \
 	mmcu?avr5=mmcu?atmega64hve \
-	mmcu?avr5=mmcu?atmega64rfa2 \
+	mmcu?avr5=mmcu?atmega64hve2 \
 	mmcu?avr5=mmcu?atmega64rfr2 \
-	mmcu?avr5=mmcu?atmega32hvb \
+	mmcu?avr5=mmcu?atmega644rfr2 \
 	mmcu?avr5=mmcu?atmega32hvbrevb \
-	mmcu?avr5=mmcu?atmega16hva2 \
-	mmcu?avr5=mmcu?atmega48hvf \
 	mmcu?avr5=mmcu?at90can32 \
 	mmcu?avr5=mmcu?at90can64 \
 	mmcu?avr5=mmcu?at90pwm161 \
 	mmcu?avr5=mmcu?at90pwm216 \
 	mmcu?avr5=mmcu?at90pwm316 \
-	mmcu?avr5=mmcu?atmega32c1 \
-	mmcu?avr5=mmcu?atmega64c1 \
-	mmcu?avr5=mmcu?atmega16m1 \
-	mmcu?avr5=mmcu?atmega32m1 \
-	mmcu?avr5=mmcu?atmega64m1 \
-	mmcu?avr5=mmcu?atmega16u4 \
-	mmcu?avr5=mmcu?atmega32u4 \
-	mmcu?avr5=mmcu?atmega32u6 \
 	mmcu?avr5=mmcu?at90scr100 \
 	mmcu?avr5=mmcu?at90usb646 \
 	mmcu?avr5=mmcu?at90usb647 \
@@ -227,57 +225,65 @@ MULTILIB_MATCHES = \
 	mmcu?avr51=mmcu?atmega1284 \
 	mmcu?avr51=mmcu?atmega1284p \
 	mmcu?avr51=mmcu?atmega128rfa1 \
+	mmcu?avr51=mmcu?atmega128rfr2 \
+	mmcu?avr51=mmcu?atmega1284rfr2 \
 	mmcu?avr51=mmcu?at90can128 \
 	mmcu?avr51=mmcu?at90usb1286 \
 	mmcu?avr51=mmcu?at90usb1287 \
 	mmcu?avr6=mmcu?atmega2560 \
 	mmcu?avr6=mmcu?atmega2561 \
+	mmcu?avr6=mmcu?atmega256rfr2 \
+	mmcu?avr6=mmcu?atmega2564rfr2 \
+	mmcu?avr7=mmcu?ata5831 \
+	mmcu?avrxmega2=mmcu?atxmega8e5 \
 	mmcu?avrxmega2=mmcu?atxmega16a4 \
+	mmcu?avrxmega2=mmcu?atxmega16a4u \
+	mmcu?avrxmega2=mmcu?atxmega16c4 \
 	mmcu?avrxmega2=mmcu?atxmega16d4 \
+	mmcu?avrxmega2=mmcu?atxmega16e5 \
 	mmcu?avrxmega2=mmcu?atxmega16x1 \
 	mmcu?avrxmega2=mmcu?atxmega32a4 \
-	mmcu?avrxmega2=mmcu?atxmega32d4 \
-	mmcu?avrxmega2=mmcu?atxmega32x1 \
-	mmcu?avrxmega2=mmcu?atmxt112sl \
-	mmcu?avrxmega2=mmcu?atmxt224 \
-	mmcu?avrxmega2=mmcu?atmxt224e \
-	mmcu?avrxmega2=mmcu?atmxt336s \
-	mmcu?avrxmega2=mmcu?atxmega16a4u \
-	mmcu?avrxmega2=mmcu?atxmega16c4 \
 	mmcu?avrxmega2=mmcu?atxmega32a4u \
+	mmcu?avrxmega2=mmcu?atxmega32c3 \
 	mmcu?avrxmega2=mmcu?atxmega32c4 \
+	mmcu?avrxmega2=mmcu?atxmega32d3 \
+	mmcu?avrxmega2=mmcu?atxmega32d4 \
 	mmcu?avrxmega2=mmcu?atxmega32e5 \
 	mmcu?avrxmega4=mmcu?atxmega64a3 \
-	mmcu?avrxmega4=mmcu?atxmega64d3 \
 	mmcu?avrxmega4=mmcu?atxmega64a3u \
 	mmcu?avrxmega4=mmcu?atxmega64a4u \
 	mmcu?avrxmega4=mmcu?atxmega64b1 \
 	mmcu?avrxmega4=mmcu?atxmega64b3 \
 	mmcu?avrxmega4=mmcu?atxmega64c3 \
+	mmcu?avrxmega4=mmcu?atxmega64d3 \
 	mmcu?avrxmega4=mmcu?atxmega64d4 \
 	mmcu?avrxmega5=mmcu?atxmega64a1 \
 	mmcu?avrxmega5=mmcu?atxmega64a1u \
 	mmcu?avrxmega6=mmcu?atxmega128a3 \
-	mmcu?avrxmega6=mmcu?atxmega128d3 \
-	mmcu?avrxmega6=mmcu?atxmega192a3 \
-	mmcu?avrxmega6=mmcu?atxmega192d3 \
-	mmcu?avrxmega6=mmcu?atxmega256a3 \
-	mmcu?avrxmega6=mmcu?atxmega256a3b \
-	mmcu?avrxmega6=mmcu?atxmega256a3bu \
-	mmcu?avrxmega6=mmcu?atxmega256d3 \
 	mmcu?avrxmega6=mmcu?atxmega128a3u \
 	mmcu?avrxmega6=mmcu?atxmega128b1 \
 	mmcu?avrxmega6=mmcu?atxmega128b3 \
 	mmcu?avrxmega6=mmcu?atxmega128c3 \
+	mmcu?avrxmega6=mmcu?atxmega128d3 \
 	mmcu?avrxmega6=mmcu?atxmega128d4 \
-	mmcu?avrxmega6=mmcu?atmxt540s \
-	mmcu?avrxmega6=mmcu?atmxt540sreva \
+	mmcu?avrxmega6=mmcu?atxmega192a3 \
 	mmcu?avrxmega6=mmcu?atxmega192a3u \
 	mmcu?avrxmega6=mmcu?atxmega192c3 \
+	mmcu?avrxmega6=mmcu?atxmega192d3 \
+	mmcu?avrxmega6=mmcu?atxmega256a3 \
+	mmcu?avrxmega6=mmcu?atxmega256a3b \
+	mmcu?avrxmega6=mmcu?atxmega256a3bu \
 	mmcu?avrxmega6=mmcu?atxmega256a3u \
 	mmcu?avrxmega6=mmcu?atxmega256c3 \
+	mmcu?avrxmega6=mmcu?atxmega256d3 \
 	mmcu?avrxmega6=mmcu?atxmega384c3 \
 	mmcu?avrxmega6=mmcu?atxmega384d3 \
 	mmcu?avrxmega7=mmcu?atxmega128a1 \
 	mmcu?avrxmega7=mmcu?atxmega128a1u \
-	mmcu?avrxmega7=mmcu?atxmega128a4u
+	mmcu?avrxmega7=mmcu?atxmega128a4u \
+	mmcu?avrtiny=mmcu?attiny4 \
+	mmcu?avrtiny=mmcu?attiny5 \
+	mmcu?avrtiny=mmcu?attiny9 \
+	mmcu?avrtiny=mmcu?attiny10 \
+	mmcu?avrtiny=mmcu?attiny20 \
+	mmcu?avrtiny=mmcu?attiny40
diff --git gcc/cse.c gcc/cse.c
index b200fef..9dd0b92 100644
--- gcc/cse.c
+++ gcc/cse.c
@@ -1824,7 +1824,7 @@ flush_hash_table (void)
       }
 }
 
-/* Function called for each rtx to check whether true dependence exist.  */
+/* Function called for each rtx to check whether an anti dependence exist.  */
 struct check_dependence_data
 {
   enum machine_mode mode;
@@ -1837,7 +1837,7 @@ check_dependence (rtx *x, void *data)
 {
   struct check_dependence_data *d = (struct check_dependence_data *) data;
   if (*x && MEM_P (*x))
-    return canon_true_dependence (d->exp, d->mode, d->addr, *x, NULL_RTX);
+    return canon_anti_dependence (*x, true, d->exp, d->mode, d->addr);
   else
     return 0;
 }
diff --git gcc/cselib.c gcc/cselib.c
index f2021b9..334d955 100644
--- gcc/cselib.c
+++ gcc/cselib.c
@@ -2260,8 +2260,8 @@ cselib_invalidate_mem (rtx mem_rtx)
 	      continue;
 	    }
 	  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)
-	      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx),
-					  mem_addr, x, NULL_RTX))
+	      && ! canon_anti_dependence (x, false, mem_rtx,
+					  GET_MODE (mem_rtx), mem_addr))
 	    {
 	      has_mem = true;
 	      num_mems++;
diff --git gcc/doc/avr-mmcu.texi gcc/doc/avr-mmcu.texi
index b1313c4..552d0ee 100644
--- gcc/doc/avr-mmcu.texi
+++ gcc/doc/avr-mmcu.texi
@@ -18,7 +18,7 @@
 
 @item avr25
 ``Classic'' devices with up to 8@tie{}KiB of program memory and with the @code{MOVW} instruction.
-@*@var{mcu}@tie{}= @code{ata5272}, @code{ata6289}, @code{attiny13}, @code{attiny13a}, @code{attiny2313}, @code{attiny2313a}, @code{attiny24}, @code{attiny24a}, @code{attiny25}, @code{attiny261}, @code{attiny261a}, @code{attiny43u}, @code{attiny4313}, @code{attiny44}, @code{attiny44a}, @code{attiny45}, @code{attiny461}, @code{attiny461a}, @code{attiny48}, @code{attiny84}, @code{attiny84a}, @code{attiny85}, @code{attiny861}, @code{attiny861a}, @code{attiny87}, @code{attiny88}, @code{at86rf401}.
+@*@var{mcu}@tie{}= @code{ata5272}, @code{ata6616c}, @code{attiny13}, @code{attiny13a}, @code{attiny2313}, @code{attiny2313a}, @code{attiny24}, @code{attiny24a}, @code{attiny25}, @code{attiny261}, @code{attiny261a}, @code{attiny43u}, @code{attiny4313}, @code{attiny44}, @code{attiny44a}, @code{attiny441}, @code{attiny45}, @code{attiny461}, @code{attiny461a}, @code{attiny48}, @code{attiny828}, @code{attiny84}, @code{attiny84a}, @code{attiny841}, @code{attiny85}, @code{attiny861}, @code{attiny861a}, @code{attiny87}, @code{attiny88}, @code{at86rf401}.
 
 @item avr3
 ``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of  program memory.
@@ -30,27 +30,31 @@
 
 @item avr35
 ``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory and with the @code{MOVW} instruction.
-@*@var{mcu}@tie{}= @code{ata5505}, @code{atmega16u2}, @code{atmega32u2}, @code{atmega8u2}, @code{attiny1634}, @code{attiny167}, @code{at90usb162}, @code{at90usb82}.
+@*@var{mcu}@tie{}= @code{ata5505}, @code{ata6617c}, @code{ata664251}, @code{atmega16u2}, @code{atmega32u2}, @code{atmega8u2}, @code{attiny1634}, @code{attiny167}, @code{at90usb162}, @code{at90usb82}.
 
 @item avr4
 ``Enhanced'' devices with up to 8@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{ata6285}, @code{ata6286}, @code{atmega48}, @code{atmega48a}, @code{atmega48p}, @code{atmega48pa}, @code{atmega8}, @code{atmega8a}, @code{atmega8hva}, @code{atmega8515}, @code{atmega8535}, @code{atmega88}, @code{atmega88a}, @code{atmega88p}, @code{atmega88pa}, @code{at90pwm1}, @code{at90pwm2}, @code{at90pwm2b}, @code{at90pwm3}, @code{at90pwm3b}, @code{at90pwm81}.
+@*@var{mcu}@tie{}= @code{ata6285}, @code{ata6286}, @code{ata6289}, @code{ata6612c}, @code{atmega48}, @code{atmega48a}, @code{atmega48p}, @code{atmega48pa}, @code{atmega8}, @code{atmega8a}, @code{atmega8hva}, @code{atmega8515}, @code{atmega8535}, @code{atmega88}, @code{atmega88a}, @code{atmega88p}, @code{atmega88pa}, @code{at90pwm1}, @code{at90pwm2}, @code{at90pwm2b}, @code{at90pwm3}, @code{at90pwm3b}, @code{at90pwm81}.
 
 @item avr5
 ``Enhanced'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{ata5790}, @code{ata5790n}, @code{ata5795}, @code{atmega16}, @code{atmega16a}, @code{atmega16hva}, @code{atmega16hva}, @code{atmega16hva2}, @code{atmega16hva2}, @code{atmega16hvb}, @code{atmega16hvb}, @code{atmega16hvbrevb}, @code{atmega16m1}, @code{atmega16m1}, @code{atmega16u4}, @code{atmega16u4}, @code{atmega161}, @code{atmega162}, @code{atmega163}, @code{atmega164a}, @code{atmega164p}, @code{atmega164pa}, @code{atmega165}, @code{atmega165a}, @code{atmega165p}, @code{atmega165pa}, @code{atmega168}, @code{atmega168a}, @code{atmega168p}, @code{atmega168pa}, @code{atmega169}, @code{atmega169a}, @code{atmega169p}, @code{atmega169pa}, @code{atmega26hvg}, @code{atmega32}, @code{atmega32a}, @code{atmega32a}, @code{atmega32c1}, @code{atmega32c1}, @code{atmega32hvb}, @code{atmega32hvb}, @code{atmega32hvbrevb}, @code{atmega32m1}, @code{atmega32m1}, @code{atmega32u4}, @code{atmega32u4}, @code{atmega32u6}, @code{atmega32u6}, @code{atmega323}, @code{atmega324a}, @code{atmega324p}, @code{atmega324pa}, @code{atmega325}, @code{atmega325a}, @code{atmega325p}, @code{atmega3250}, @code{atmega3250a}, @code{atmega3250p}, @code{atmega3250pa}, @code{atmega328}, @code{atmega328p}, @code{atmega329}, @code{atmega329a}, @code{atmega329p}, @code{atmega329pa}, @code{atmega3290}, @code{atmega3290a}, @code{atmega3290p}, @code{atmega3290pa}, @code{atmega406}, @code{atmega48hvf}, @code{atmega64}, @code{atmega64a}, @code{atmega64c1}, @code{atmega64c1}, @code{atmega64hve}, @code{atmega64m1}, @code{atmega64m1}, @code{atmega64rfa2}, @code{atmega64rfr2}, @code{atmega640}, @code{atmega644}, @code{atmega644a}, @code{atmega644p}, @code{atmega644pa}, @code{atmega645}, @code{atmega645a}, @code{atmega645p}, @code{atmega6450}, @code{atmega6450a}, @code{atmega6450p}, @code{atmega649}, @code{atmega649a}, @code{atmega649p}, @code{atmega6490}, @code{atmega6490a}, @code{atmega6490p}, @code{at90can32}, @code{at90can64}, @code{at90pwm161}, @code{at90pwm216}, @code{at90pwm316}, @code{at90scr100}, @code{at90usb646}, @code{at90usb647}, @code{at94k}, @code{m3000}.
+@*@var{mcu}@tie{}= @code{ata5790}, @code{ata5790n}, @code{ata5795}, @code{ata6613c}, @code{ata6614q}, @code{atmega16}, @code{atmega16a}, @code{atmega16hva}, @code{atmega16hva2}, @code{atmega16hvb}, @code{atmega16hvbrevb}, @code{atmega16m1}, @code{atmega16u4}, @code{atmega161}, @code{atmega162}, @code{atmega163}, @code{atmega164a}, @code{atmega164p}, @code{atmega164pa}, @code{atmega165}, @code{atmega165a}, @code{atmega165p}, @code{atmega165pa}, @code{atmega168}, @code{atmega168a}, @code{atmega168p}, @code{atmega168pa}, @code{atmega169}, @code{atmega169a}, @code{atmega169p}, @code{atmega169pa}, @code{atmega32}, @code{atmega32a}, @code{atmega32c1}, @code{atmega32hvb}, @code{atmega32hvbrevb}, @code{atmega32m1}, @code{atmega32u4}, @code{atmega32u6}, @code{atmega323}, @code{atmega324a}, @code{atmega324p}, @code{atmega324pa}, @code{atmega325}, @code{atmega325a}, @code{atmega325p}, @code{atmega325pa}, @code{atmega3250}, @code{atmega3250a}, @code{atmega3250p}, @code{atmega3250pa}, @code{atmega328}, @code{atmega328p}, @code{atmega329}, @code{atmega329a}, @code{atmega329p}, @code{atmega329pa}, @code{atmega3290}, @code{atmega3290a}, @code{atmega3290p}, @code{atmega3290pa}, @code{atmega406}, @code{atmega64}, @code{atmega64a}, @code{atmega64c1}, @code{atmega64hve}, @code{atmega64hve2}, @code{atmega64m1}, @code{atmega64rfr2}, @code{atmega640}, @code{atmega644}, @code{atmega644a}, @code{atmega644p}, @code{atmega644pa}, @code{atmega644rfr2}, @code{atmega645}, @code{atmega645a}, @code{atmega645p}, @code{atmega6450}, @code{atmega6450a}, @code{atmega6450p}, @code{atmega649}, @code{atmega649a}, @code{atmega649p}, @code{atmega6490}, @code{atmega6490a}, @code{atmega6490p}, @code{at90can32}, @code{at90can64}, @code{at90pwm161}, @code{at90pwm216}, @code{at90pwm316}, @code{at90scr100}, @code{at90usb646}, @code{at90usb647}, @code{at94k}, @code{m3000}.
 
 @item avr51
 ``Enhanced'' devices with 128@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atmega128}, @code{atmega128a}, @code{atmega128rfa1}, @code{atmega1280}, @code{atmega1281}, @code{atmega1284}, @code{atmega1284p}, @code{at90can128}, @code{at90usb1286}, @code{at90usb1287}.
+@*@var{mcu}@tie{}= @code{atmega128}, @code{atmega128a}, @code{atmega128rfa1}, @code{atmega128rfr2}, @code{atmega1280}, @code{atmega1281}, @code{atmega1284}, @code{atmega1284p}, @code{atmega1284rfr2}, @code{at90can128}, @code{at90usb1286}, @code{at90usb1287}.
 
 @item avr6
 ``Enhanced'' devices with 3-byte PC, i.e.@: with more than 128@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atmega2560}, @code{atmega2561}.
+@*@var{mcu}@tie{}= @code{atmega256rfr2}, @code{atmega2560}, @code{atmega2561}, @code{atmega2564rfr2}.
+
+@item avr7
+``Enhanced'' devices with 20@tie{}KiB of program memory starts at 0x8000.
+@*@var{mcu}@tie{}= @code{ata5831}.
 
 @item avrxmega2
 ``XMEGA'' devices with more than 8@tie{}KiB and up to 64@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atmxt112sl}, @code{atmxt224}, @code{atmxt224e}, @code{atmxt336s}, @code{atxmega16a4}, @code{atxmega16a4u}, @code{atxmega16c4}, @code{atxmega16d4}, @code{atxmega16x1}, @code{atxmega32a4}, @code{atxmega32a4u}, @code{atxmega32c4}, @code{atxmega32d4}, @code{atxmega32e5}, @code{atxmega32x1}.
+@*@var{mcu}@tie{}= @code{atxmega16a4}, @code{atxmega16a4u}, @code{atxmega16c4}, @code{atxmega16d4}, @code{atxmega16e5}, @code{atxmega16x1}, @code{atxmega32a4}, @code{atxmega32a4u}, @code{atxmega32c3}, @code{atxmega32c4}, @code{atxmega32d3}, @code{atxmega32d4}, @code{atxmega32e5}, @code{atxmega8e5}.
 
 @item avrxmega4
 ``XMEGA'' devices with more than 64@tie{}KiB and up to 128@tie{}KiB of program memory.
@@ -62,12 +66,16 @@
 
 @item avrxmega6
 ``XMEGA'' devices with more than 128@tie{}KiB of program memory.
-@*@var{mcu}@tie{}= @code{atmxt540s}, @code{atmxt540sreva}, @code{atxmega128a3}, @code{atxmega128a3u}, @code{atxmega128b1}, @code{atxmega128b3}, @code{atxmega128c3}, @code{atxmega128d3}, @code{atxmega128d4}, @code{atxmega192a3}, @code{atxmega192a3u}, @code{atxmega192c3}, @code{atxmega192d3}, @code{atxmega256a3}, @code{atxmega256a3b}, @code{atxmega256a3bu}, @code{atxmega256a3u}, @code{atxmega256c3}, @code{atxmega256d3}, @code{atxmega384c3}, @code{atxmega384d3}.
+@*@var{mcu}@tie{}= @code{atxmega128a3}, @code{atxmega128a3u}, @code{atxmega128b1}, @code{atxmega128b3}, @code{atxmega128c3}, @code{atxmega128d3}, @code{atxmega128d4}, @code{atxmega192a3}, @code{atxmega192a3u}, @code{atxmega192c3}, @code{atxmega192d3}, @code{atxmega256a3}, @code{atxmega256a3b}, @code{atxmega256a3bu}, @code{atxmega256a3u}, @code{atxmega256c3}, @code{atxmega256d3}, @code{atxmega384c3}, @code{atxmega384d3}.
 
 @item avrxmega7
 ``XMEGA'' devices with more than 128@tie{}KiB of program memory and more than 64@tie{}KiB of RAM.
 @*@var{mcu}@tie{}= @code{atxmega128a1}, @code{atxmega128a1u}, @code{atxmega128a4u}.
 
+@item avrtiny
+``TINY'' Tiny core devices with 512@tie{}B up to 4@tie{}KiB of program memory.
+@*@var{mcu}@tie{}= @code{attiny10}, @code{attiny20}, @code{attiny4}, @code{attiny40}, @code{attiny5}, @code{attiny9}.
+
 @item avr1
 This ISA is implemented by the minimal AVR core and supported for assembler only.
 @*@var{mcu}@tie{}= @code{attiny11}, @code{attiny12}, @code{attiny15}, @code{attiny28}, @code{at90s1200}.
diff --git gcc/gcc.c gcc/gcc.c
index fea7394..c20f2b0 100644
--- gcc/gcc.c
+++ gcc/gcc.c
@@ -627,7 +627,7 @@ proper position among the other output files.  */
      && defined(HAVE_AS_GDWARF2_DEBUG_FLAG) && defined(HAVE_AS_GSTABS_DEBUG_FLAG)
 #  define ASM_DEBUG_SPEC						\
       (PREFERRED_DEBUGGING_TYPE == DBX_DEBUG				\
-       ? "%{!g0:%{gdwarf-2*:--gdwarf2}%{!gdwarf-2*:%{g*:--gstabs}}}" ASM_MAP	\
+       ? "%{!g0:%{gdwarf*:--gdwarf2}%{!gdwarf*:%{g*:--gstabs}}}" ASM_MAP	\
        : "%{!g0:%{gstabs*:--gstabs}%{!gstabs*:%{g*:--gdwarf2}}}" ASM_MAP)
 # else
 #  if defined(DBX_DEBUGGING_INFO) && defined(HAVE_AS_GSTABS_DEBUG_FLAG)
diff --git gcc/opts.c gcc/opts.c
index 45b12fe..f96ed16 100644
--- gcc/opts.c
+++ gcc/opts.c
@@ -1699,6 +1699,18 @@ common_handle_option (struct gcc_options *opts,
       set_debug_level (SDB_DEBUG, false, arg, opts, opts_set, loc);
       break;
 
+    case OPT_gdwarf:
+      if (arg && strlen(arg) != 0)
+        {
+          error_at (loc, "%<-gdwarf%s%> is ambiguous; "
+                    "use %<-gdwarf-%s%> for DWARF version "
+                    "or %<-gdwarf -g%s%> for debug level", arg, arg, arg);
+          break;
+        }
+      else
+        {
+          value = opts->x_dwarf_version;
+        }
     case OPT_gdwarf_:
       if (value < 2 || value > 4)
 	error_at (loc, "dwarf version %d is not supported", value);
diff --git gcc/postreload.c gcc/postreload.c
index daabaa1..6586522 100644
--- gcc/postreload.c
+++ gcc/postreload.c
@@ -1639,14 +1639,22 @@ reload_combine_note_use (rtx *xp, rtx insn, int ruid, rtx containing_mem)
    later disable any optimization that would cross it.
    reg_offset[n] / reg_base_reg[n] / reg_symbol_ref[n] / reg_mode[n]
    are only valid if reg_set_luid[n] is greater than
-   move2add_last_label_luid.  */
+   move2add_last_label_luid.
+   For a set that established a new (potential) base register with
+   non-constant value, we use move2add_luid from the place where the
+   setting insn is encountered; registers based off that base then
+   get the same reg_set_luid.  Constants all get
+   move2add_last_label_luid + 1 as their reg_set_luid.  */
 static int reg_set_luid[FIRST_PSEUDO_REGISTER];
 
 /* If reg_base_reg[n] is negative, register n has been set to
    reg_offset[n] or reg_symbol_ref[n] + reg_offset[n] in mode reg_mode[n].
    If reg_base_reg[n] is non-negative, register n has been set to the
    sum of reg_offset[n] and the value of register reg_base_reg[n]
-   before reg_set_luid[n], calculated in mode reg_mode[n] .  */
+   before reg_set_luid[n], calculated in mode reg_mode[n] .
+   For multi-hard-register registers, all but the first one are
+   recorded as BLKmode in reg_mode.  Setting reg_mode to VOIDmode
+   marks it as invalid.  */
 static HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];
 static int reg_base_reg[FIRST_PSEUDO_REGISTER];
 static rtx reg_symbol_ref[FIRST_PSEUDO_REGISTER];
@@ -1668,6 +1676,77 @@ static int move2add_last_label_luid;
    || (GET_MODE_SIZE (OUTMODE) <= GET_MODE_SIZE (INMODE) \
        && TRULY_NOOP_TRUNCATION_MODES_P (OUTMODE, INMODE)))
 
+/* Record that REG is being set to a value with the mode of REG.  */
+
+static void
+move2add_record_mode (rtx reg)
+{
+  int regno, nregs;
+  enum machine_mode mode = GET_MODE (reg);
+
+  if (GET_CODE (reg) == SUBREG)
+    {
+      regno = subreg_regno (reg);
+      nregs = subreg_nregs (reg);
+    }
+  else if (REG_P (reg))
+    {
+      regno = REGNO (reg);
+      nregs = hard_regno_nregs[regno][mode];
+    }
+  else
+    gcc_unreachable ();
+  for (int i = nregs - 1; i > 0; i--)
+    reg_mode[regno + i] = BLKmode;
+  reg_mode[regno] = mode;
+}
+
+/* Record that REG is being set to the sum of SYM and OFF.  */
+
+static void
+move2add_record_sym_value (rtx reg, rtx sym, rtx off)
+{
+  int regno = REGNO (reg);
+
+  move2add_record_mode (reg);
+  reg_set_luid[regno] = move2add_luid;
+  reg_base_reg[regno] = -1;
+  reg_symbol_ref[regno] = sym;
+  reg_offset[regno] = INTVAL (off);
+}
+
+/* Check if REGNO contains a valid value in MODE.  */
+
+static bool
+move2add_valid_value_p (int regno, enum machine_mode mode)
+{
+  if (reg_set_luid[regno] <= move2add_last_label_luid)
+    return false;
+
+  if (mode != reg_mode[regno])
+    {
+      if (!MODES_OK_FOR_MOVE2ADD (mode, reg_mode[regno]))
+	return false;
+      /* The value loaded into regno in reg_mode[regno] is also valid in
+	 mode after truncation only if (REG:mode regno) is the lowpart of
+	 (REG:reg_mode[regno] regno).  Now, for big endian, the starting
+	 regno of the lowpart might be different.  */
+      int s_off = subreg_lowpart_offset (mode, reg_mode[regno]);
+      s_off = subreg_regno_offset (regno, reg_mode[regno], s_off, mode);
+      if (s_off != 0)
+	/* We could in principle adjust regno, check reg_mode[regno] to be
+	   BLKmode, and return s_off to the caller (vs. -1 for failure),
+	   but we currently have no callers that could make use of this
+	   information.  */
+	return false;
+    }
+
+  for (int i = hard_regno_nregs[regno][mode] - 1; i > 0; i--)
+    if (reg_mode[regno + i] != BLKmode)
+      return false;
+  return true;
+}
+
 /* This function is called with INSN that sets REG to (SYM + OFF),
    while REG is known to already have value (SYM + offset).
    This function tries to change INSN into an add instruction
@@ -1726,8 +1805,7 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)
 		  && ((reg_offset[regno] & ~GET_MODE_MASK (narrow_mode))
 		      == (INTVAL (off) & ~GET_MODE_MASK (narrow_mode))))
 		{
-		  rtx narrow_reg = gen_rtx_REG (narrow_mode,
-						REGNO (reg));
+		  rtx narrow_reg = gen_lowpart_common (narrow_mode, reg);
 		  rtx narrow_src = gen_int_mode (INTVAL (off),
 						 narrow_mode);
 		  rtx new_set
@@ -1743,11 +1821,7 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)
 	    }
 	}
     }
-  reg_set_luid[regno] = move2add_luid;
-  reg_base_reg[regno] = -1;
-  reg_mode[regno] = GET_MODE (reg);
-  reg_symbol_ref[regno] = sym;
-  reg_offset[regno] = INTVAL (off);
+  move2add_record_sym_value (reg, sym, off);
   return changed;
 }
 
@@ -1781,8 +1855,7 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)
   SET_SRC (pat) = plus_expr;
 
   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
-    if (reg_set_luid[i] > move2add_last_label_luid
-	&& reg_mode[i] == GET_MODE (reg)
+    if (move2add_valid_value_p (i, GET_MODE (reg))
 	&& reg_base_reg[i] < 0
 	&& reg_symbol_ref[i] != NULL_RTX
 	&& rtx_equal_p (sym, reg_symbol_ref[i]))
@@ -1830,10 +1903,7 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)
 	changed = true;
     }
   reg_set_luid[regno] = move2add_luid;
-  reg_base_reg[regno] = -1;
-  reg_mode[regno] = GET_MODE (reg);
-  reg_symbol_ref[regno] = sym;
-  reg_offset[regno] = INTVAL (off);
+  move2add_record_sym_value (reg, sym, off);
   return changed;
 }
 
@@ -1884,8 +1954,7 @@ reload_cse_move2add (rtx first)
 
 	  /* Check if we have valid information on the contents of this
 	     register in the mode of REG.  */
-	  if (reg_set_luid[regno] > move2add_last_label_luid
-	      && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg), reg_mode[regno])
+	  if (move2add_valid_value_p (regno, GET_MODE (reg))
               && dbg_cnt (cse2_move2add))
 	    {
 	      /* Try to transform (set (REGX) (CONST_INT A))
@@ -1922,8 +1991,7 @@ reload_cse_move2add (rtx first)
 	      else if (REG_P (src)
 		       && reg_set_luid[regno] == reg_set_luid[REGNO (src)]
 		       && reg_base_reg[regno] == reg_base_reg[REGNO (src)]
-		       && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg),
-						 reg_mode[REGNO (src)]))
+		       && move2add_valid_value_p (REGNO (src), GET_MODE (reg)))
 		{
 		  rtx next = next_nonnote_nondebug_insn (insn);
 		  rtx set = NULL_RTX;
@@ -1976,10 +2044,10 @@ reload_cse_move2add (rtx first)
 			delete_insn (insn);
 		      changed |= success;
 		      insn = next;
-		      reg_mode[regno] = GET_MODE (reg);
-		      reg_offset[regno] =
-			trunc_int_for_mode (added_offset + base_offset,
-					    GET_MODE (reg));
+		      move2add_record_mode (reg);
+		      reg_offset[regno]
+			= trunc_int_for_mode (added_offset + base_offset,
+					      GET_MODE (reg));
 		      continue;
 		    }
 		}
@@ -2015,8 +2083,7 @@ reload_cse_move2add (rtx first)
 
 	      /* If the reg already contains the value which is sum of
 		 sym and some constant value, we can use an add2 insn.  */
-	      if (reg_set_luid[regno] > move2add_last_label_luid
-		  && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg), reg_mode[regno])
+	      if (move2add_valid_value_p (regno, GET_MODE (reg))
 		  && reg_base_reg[regno] < 0
 		  && reg_symbol_ref[regno] != NULL_RTX
 		  && rtx_equal_p (sym, reg_symbol_ref[regno]))
@@ -2039,7 +2106,10 @@ reload_cse_move2add (rtx first)
 	      /* Reset the information about this register.  */
 	      int regno = REGNO (XEXP (note, 0));
 	      if (regno < FIRST_PSEUDO_REGISTER)
-		reg_set_luid[regno] = 0;
+		{
+		  move2add_record_mode (XEXP (note, 0));
+		  reg_mode[regno] = VOIDmode;
+		}
 	    }
 	}
       note_stores (PATTERN (insn), move2add_note_store, insn);
@@ -2076,7 +2146,7 @@ reload_cse_move2add (rtx first)
 	    {
 	      if (call_used_regs[i])
 		/* Reset the information about this register.  */
-		reg_set_luid[i] = 0;
+		reg_mode[i] = VOIDmode;
 	    }
 	}
     }
@@ -2093,20 +2163,8 @@ move2add_note_store (rtx dst, const_rtx set, void *data)
 {
   rtx insn = (rtx) data;
   unsigned int regno = 0;
-  unsigned int nregs = 0;
-  unsigned int i;
   enum machine_mode mode = GET_MODE (dst);
 
-  if (GET_CODE (dst) == SUBREG)
-    {
-      regno = subreg_regno_offset (REGNO (SUBREG_REG (dst)),
-				   GET_MODE (SUBREG_REG (dst)),
-				   SUBREG_BYTE (dst),
-				   GET_MODE (dst));
-      nregs = subreg_nregs (dst);
-      dst = SUBREG_REG (dst);
-    }
-
   /* Some targets do argument pushes without adding REG_INC notes.  */
 
   if (MEM_P (dst))
@@ -2114,27 +2172,28 @@ move2add_note_store (rtx dst, const_rtx set, void *data)
       dst = XEXP (dst, 0);
       if (GET_CODE (dst) == PRE_INC || GET_CODE (dst) == POST_INC
 	  || GET_CODE (dst) == PRE_DEC || GET_CODE (dst) == POST_DEC)
-	reg_set_luid[REGNO (XEXP (dst, 0))] = 0;
+	reg_mode[REGNO (XEXP (dst, 0))] = VOIDmode;
       return;
     }
-  if (!REG_P (dst))
-    return;
 
-  regno += REGNO (dst);
-  if (!nregs)
-    nregs = hard_regno_nregs[regno][mode];
+  if (GET_CODE (dst) == SUBREG)
+    regno = subreg_regno (dst);
+  else if (REG_P (dst))
+    regno = REGNO (dst);
+  else
+    return;
 
-  if (SCALAR_INT_MODE_P (GET_MODE (dst))
-      && nregs == 1 && GET_CODE (set) == SET)
+  if (SCALAR_INT_MODE_P (mode)
+      && GET_CODE (set) == SET)
     {
       rtx note, sym = NULL_RTX;
-      HOST_WIDE_INT off;
+      rtx off;
 
       note = find_reg_equal_equiv_note (insn);
       if (note && GET_CODE (XEXP (note, 0)) == SYMBOL_REF)
 	{
 	  sym = XEXP (note, 0);
-	  off = 0;
+	  off = const0_rtx;
 	}
       else if (note && GET_CODE (XEXP (note, 0)) == CONST
 	       && GET_CODE (XEXP (XEXP (note, 0), 0)) == PLUS
@@ -2142,22 +2201,18 @@ move2add_note_store (rtx dst, const_rtx set, void *data)
 	       && CONST_INT_P (XEXP (XEXP (XEXP (note, 0), 0), 1)))
 	{
 	  sym = XEXP (XEXP (XEXP (note, 0), 0), 0);
-	  off = INTVAL (XEXP (XEXP (XEXP (note, 0), 0), 1));
+	  off = XEXP (XEXP (XEXP (note, 0), 0), 1);
 	}
 
       if (sym != NULL_RTX)
 	{
-	  reg_base_reg[regno] = -1;
-	  reg_symbol_ref[regno] = sym;
-	  reg_offset[regno] = off;
-	  reg_mode[regno] = mode;
-	  reg_set_luid[regno] = move2add_luid;
+	  move2add_record_sym_value (dst, sym, off);
 	  return;
 	}
     }
 
-  if (SCALAR_INT_MODE_P (GET_MODE (dst))
-      && nregs == 1 && GET_CODE (set) == SET
+  if (SCALAR_INT_MODE_P (mode)
+      && GET_CODE (set) == SET
       && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT
       && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)
     {
@@ -2165,9 +2220,6 @@ move2add_note_store (rtx dst, const_rtx set, void *data)
       rtx base_reg;
       HOST_WIDE_INT offset;
       int base_regno;
-      /* This may be different from mode, if SET_DEST (set) is a
-	 SUBREG.  */
-      enum machine_mode dst_mode = GET_MODE (dst);
 
       switch (GET_CODE (src))
 	{
@@ -2179,20 +2231,14 @@ move2add_note_store (rtx dst, const_rtx set, void *data)
 	      if (CONST_INT_P (XEXP (src, 1)))
 		offset = INTVAL (XEXP (src, 1));
 	      else if (REG_P (XEXP (src, 1))
-		       && (reg_set_luid[REGNO (XEXP (src, 1))]
-			   > move2add_last_label_luid)
-		       && (MODES_OK_FOR_MOVE2ADD
-			   (dst_mode, reg_mode[REGNO (XEXP (src, 1))])))
+		       && move2add_valid_value_p (REGNO (XEXP (src, 1)), mode))
 		{
 		  if (reg_base_reg[REGNO (XEXP (src, 1))] < 0
 		      && reg_symbol_ref[REGNO (XEXP (src, 1))] == NULL_RTX)
 		    offset = reg_offset[REGNO (XEXP (src, 1))];
 		  /* Maybe the first register is known to be a
 		     constant.  */
-		  else if (reg_set_luid[REGNO (base_reg)]
-			   > move2add_last_label_luid
-			   && (MODES_OK_FOR_MOVE2ADD
-			       (dst_mode, reg_mode[REGNO (base_reg)]))
+		  else if (move2add_valid_value_p (REGNO (base_reg), mode)
 			   && reg_base_reg[REGNO (base_reg)] < 0
 			   && reg_symbol_ref[REGNO (base_reg)] == NULL_RTX)
 		    {
@@ -2222,33 +2268,26 @@ move2add_note_store (rtx dst, const_rtx set, void *data)
 	  reg_offset[regno] = INTVAL (SET_SRC (set));
 	  /* We assign the same luid to all registers set to constants.  */
 	  reg_set_luid[regno] = move2add_last_label_luid + 1;
-	  reg_mode[regno] = mode;
+	  move2add_record_mode (dst);
 	  return;
 
 	default:
-	invalidate:
-	  /* Invalidate the contents of the register.  */
-	  reg_set_luid[regno] = 0;
-	  return;
+	  goto invalidate;
 	}
 
       base_regno = REGNO (base_reg);
       /* If information about the base register is not valid, set it
 	 up as a new base register, pretending its value is known
 	 starting from the current insn.  */
-      if (reg_set_luid[base_regno] <= move2add_last_label_luid)
+      if (!move2add_valid_value_p (base_regno, mode))
 	{
 	  reg_base_reg[base_regno] = base_regno;
 	  reg_symbol_ref[base_regno] = NULL_RTX;
 	  reg_offset[base_regno] = 0;
 	  reg_set_luid[base_regno] = move2add_luid;
-	  reg_mode[base_regno] = mode;
+	  gcc_assert (GET_MODE (base_reg) == mode);
+	  move2add_record_mode (base_reg);
 	}
-      else if (! MODES_OK_FOR_MOVE2ADD (dst_mode,
-					reg_mode[base_regno]))
-	goto invalidate;
-
-      reg_mode[regno] = mode;
 
       /* Copy base information from our base register.  */
       reg_set_luid[regno] = reg_set_luid[base_regno];
@@ -2256,17 +2295,17 @@ move2add_note_store (rtx dst, const_rtx set, void *data)
       reg_symbol_ref[regno] = reg_symbol_ref[base_regno];
 
       /* Compute the sum of the offsets or constants.  */
-      reg_offset[regno] = trunc_int_for_mode (offset
-					      + reg_offset[base_regno],
-					      dst_mode);
+      reg_offset[regno]
+	= trunc_int_for_mode (offset + reg_offset[base_regno], mode);
+
+      move2add_record_mode (dst);
     }
   else
     {
-      unsigned int endregno = regno + nregs;
-
-      for (i = regno; i < endregno; i++)
-	/* Reset the information about this register.  */
-	reg_set_luid[i] = 0;
+    invalidate:
+      /* Invalidate the contents of the register.  */
+      move2add_record_mode (dst);
+      reg_mode[regno] = VOIDmode;
     }
 }
 
diff --git gcc/reload.c gcc/reload.c
index 2546c1b..b8f3c9c 100644
--- gcc/reload.c
+++ gcc/reload.c
@@ -680,8 +680,8 @@ find_valid_class (enum machine_mode outer ATTRIBUTE_UNUSED,
 	    if (HARD_REGNO_MODE_OK (regno, inner))
 	      {
 		good = 1;
-		if (! TEST_HARD_REG_BIT (reg_class_contents[rclass], regno + n)
-		    || ! HARD_REGNO_MODE_OK (regno + n, outer))
+		if (TEST_HARD_REG_BIT (reg_class_contents[rclass], regno + n)
+		    && ! HARD_REGNO_MODE_OK (regno + n, outer))
 		  bad = 1;
 	      }
 	  }
diff --git gcc/rtl.h gcc/rtl.h
index 93a64f4..5770023 100644
--- gcc/rtl.h
+++ gcc/rtl.h
@@ -2705,6 +2705,8 @@ extern int canon_true_dependence (const_rtx, enum machine_mode, rtx,
 				  const_rtx, rtx);
 extern int read_dependence (const_rtx, const_rtx);
 extern int anti_dependence (const_rtx, const_rtx);
+extern int canon_anti_dependence (const_rtx, bool,
+				  const_rtx, enum machine_mode, rtx);
 extern int output_dependence (const_rtx, const_rtx);
 extern int may_alias_p (const_rtx, const_rtx);
 extern void init_alias_target (void);
diff --git gcc/testsuite/ChangeLog.AVR gcc/testsuite/ChangeLog.AVR
new file mode 100644
index 0000000..1ba5612
--- /dev/null
+++ gcc/testsuite/ChangeLog.AVR
@@ -0,0 +1,161 @@
+2013-08-26  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from fsf-gcc/trunk:
+      2013-04-02  Pitchumani Sivanupandi <pitchumani.s@atmel.com>
+	* gcc.dg/tree-ssa/sra-13.c: Fix for 16 bit int.
+      2013-05-14  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+	* gcc.dg/torture/alias-1.c: Add dg-require-effective-target
+	scheduling.
+      2013-04-29  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>
+	* gcc.dg/c1x-align-3.c: Add test for negative power of 2.
+
+2013-08-23  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from fsf-gcc/trunk:
+      2013-06-16  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR rtl-optimization/57425
+	PR rtl-optimization/57569
+	* gcc.dg/torture/pr57425-1.c, gcc.dg/torture/pr57425-2.c: New files.
+	* gcc.dg/torture/pr57425-3.c, gcc.dg/torture/pr57569.c: Likewise.
+      2013-07-04  Joern Rennecke <joern.rennecke@embecosm.com>
+	* gcc.dg/tree-ssa/vrp66.c: Make conditional on { target { ! int16 } } .
+	* gcc.dg/tree-ssa/vrp66-int16-sw.c: New test.
+      2013-07-04  Joern Rennecke <joern.rennecke@embecosm.com>
+	PR c/57821
+	* gcc.dg/large-size-array-6.c: New test.
+      2013-07-20  Joern Rennecke <joern.rennecke@embecosm.com>
+	* gcc.dg/tree-ssa/pr21090.c: Do vrp1 scan check only for
+	target { ! keeps_null_pointer_checks }.
+	* gcc.dg/tree-ssa/unreachable.c: Do optimized scan check only for
+	target { ! keeps_null_pointer_checks }.
+	* gcc.dg/torture/pr53366-1.c: Only run for target { size32plus }.
+	* gcc.dg/torture/pr56488.c: Likewise.
+      2013-07-22  Georg-Johann Lay  <avr@gjlay.de>
+	PR testsuite/52641
+	* gcc.c-torture/execute/pr53366-1.x: New: Skip int16 platforms.
+      2013-07-22  Georg-Johann Lay  <avr@gjlay.de>
+	PR testsuite/52641
+	* gcc.c-torture/execute/pr57344-2.x: New. Skip int16.
+	* gcc.dg/pr53265.c: Add dg-require-effective-target size32plus.
+	* gcc.dg/torture/pr53366-1.c: Same.
+	* gcc.dg/torture/pr56488.c: Add dg-require-effective-target int32plus.
+	* gcc.dg/tree-ssa/pr57385.c: Same.
+      2013-08-14  Joern Rennecke <joern.rennecke@embecosm.com>
+	* gcc.dg/debug/dwarf2/dwarf2.exp: Replace -gdwarf-2 with -gdwarf.
+	* gcc.dg/debug/dwarf2/dwarf-die7.c: Likewise.
+	* gcc.dg/debug/dwarf2/static1.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-dfp.c: Likewise.
+	* gcc.dg/debug/dwarf2/fesd-any.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-uninit.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-die1.c: Likewise.
+	* gcc.dg/debug/dwarf2/var1.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr29609-2.c: Likewise.
+	* gcc.dg/debug/dwarf2/aranges-fnsec-1.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-die3.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-merge.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-char1.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-char2.c: Likewise.
+	* gcc.dg/debug/dwarf2/fesd-baseonly.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr36690-3.c: Likewise.
+	* gcc.dg/debug/dwarf2/const-2.c: Likewise.
+	* gcc.dg/debug/dwarf2/ipa-cp1.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-char3.c: Likewise.
+	* gcc.dg/debug/dwarf2/var2.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr36690-2.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr31230.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-float.c: Likewise.
+	* gcc.dg/debug/dwarf2/short-circuit.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr36690-1.c: Likewise.
+	* gcc.dg/debug/dwarf2/fesd-reduced.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr37616.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-die2.c: Likewise.
+	* gcc.dg/debug/dwarf2/inline1.c: Likewise.
+	* gcc.dg/debug/dwarf2/fesd-sys.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr29609-1.c: Likewise.
+	* gcc.dg/debug/dwarf2/asm-line1.c: Likewise.
+	* gcc.dg/debug/dwarf2/c99-typedef1.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf2-macro.c: Likewise.
+	* gcc.dg/debug/dwarf2/fesd-none.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr51410.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-file1.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-die6.c: Likewise.
+	* gcc.dg/debug/dwarf2/const-2b.c: Likewise.
+	* gcc.dg/debug/dwarf2/dwarf-die5.c: Likewise.
+	PR testsuite/52641
+	* gcc.c-torture/execute/pr56799.x: New file.
+
+	* gcc.dg/c99-stdint-1.c [avr-*-*]: Update line number for dg-bogus.
+	* gcc.dg/torture/stackalign/builtin-apply-2.c: Also skip for avr.
+	* gcc.dg/pr44214-1.c (v2df): Define size using sizeof (double).
+	* gcc.dg/pr44214-3.c (v2df): Likewise.
+	* gcc.dg/pr46647.c: xfail for avr-*-*.
+	* gcc.dg/strlenopt-10.c [avr-*-*]: Reduce number of expected
+	memcpy by one.
+	* gcc.dg/strlenopt-11.c [avr-*-*]: Likewise.
+	Expect l to be optimized away.
+	* gcc.dg/strlenopt-13.c [avr-*-*]: Likewise.
+	PR testsuite/52641
+	* c-c++-common/scal-to-vec1.c: Add !int16 and large_double conditions
+	to tests that assume int/double are larger than short/float.
+	PR testsuite/52641
+	* c-c++-common/simulate-thread/bitfields-2.c: Run test only for
+	target { ! int16 }.
+	* gcc.dg/tree-ssa/pr54245.c: Do slsr scan only for target { ! int16 }.
+	* gcc.dg/tree-ssa/slsr-1.c: Adjust multiplicators to scan for for
+	target { int16 }.  Restrict existing tests to target { int32 }
+	where appropriate.
+	* gcc.dg/tree-ssa/slsr-2.c, gcc.dg/tree-ssa/slsr-27.c: Likewise.
+	* gcc.dg/tree-ssa/slsr-28.c, gcc.dg/tree-ssa/slsr-29.c: Likewise.
+	* gcc.dg/tree-ssa/slsr-3.c, gcc.dg/tree-ssa/ssa-ccp-23.c: Likewise.
+	* lib/target-supports.exp (check_effective_target_int32): New proc.
+
+	* gcc.dg/tree-ssa/pr42585.c: Add avr-*-* to list of targets to
+	exclude from scan test.
+	* gcc.dg/debug/dwarf2/global-used-types.c: Request dwarf output. 
+	* gcc.dg/debug/dwarf2/inline2.c: Likewise.
+	* gcc.dg/debug/dwarf2/inline3.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr37726.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr41445-1.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr41445-2.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr41445-3.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr41445-4.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr41445-5.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr41445-6.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr41543.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr41695.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr43237.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr47939-1.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr47939-2.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr47939-3.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr47939-4.c: Likewise.
+	* gcc.dg/debug/dwarf2/pr53948.c: Likewise.
+	* gcc.dg/debug/dwarf2/struct-loc1.c: Likewise.
+      2013-08-19  Joern Rennecke  <joern.rennecke@embecosm.com>
+	* gcc.target/avr/progmem-error-1.cpp: Update linenumber of error.
+	* gcc.dg/tree-ssa/ssa-dom-thread-4.c [avr-*-*]: Expect 6 times
+	"Threaded".
+	* gcc.dg/tree-ssa/vrp55.c: Use keeps_null_pointer_checks to determine
+	correct test response.
+	PR testsuite/52641
+	* gcc.dg/tree-ssa/pr31261.c [int16]: Change expected unsigned type.
+	* gcc.dg/tree-ssa/ssa-pre-21.c [! size32plus]: Mark as xfail.
+	* gcc.dg/tree-ssa/vector-4.c (SItype): New typedef.
+	(v4si): Use it.
+	* gcc.dg/tree-ssa/ssa-pre-30.c: Test requires int32.
+	* gcc.dg/tree-ssa/vrp58.c: Adjust scan expression for int16.
+      2013-05-14  Joern Rennecke <joern.rennecke@embecosm.com>
+	* testsuite/gcc.c-torture/compile/limits-externdecl.c [target avr-*-*]:
+	Expect "size of array is too large" error.
+      2013-07-11  Georg-Johann Lay  <avr@gjlay.de>
+	PR target/57631
+	* gcc.target/avr/torture/pr57631.c: New test.
+      2013-07-19  Georg-Johann Lay  <avr@gjlay.de>
+	PR target/57516
+	* gcc.target/avr/torture/builtins-4-roundfx.c (test2hr, test2k):
+	Adjust to corrected rounding.
+      Merged from embecosm/avr-gcc-mainline:
+      2013-08-19  Joern Rennecke <joern.rennecke@embecosm.com>
+	* gcc.dg/ipa/ipa-pta-14.c (scan-ipa-dump): Don't expect NULL in
+	foo.result set.
+	* gcc.dg/tree-ssa/pta-escape-1.c (scan-tree-dump): Don't expect NULL
+	in ESCAPED set.
+	* gcc.dg/tree-ssa/pta-escape-2.c: Likewise.
+	* gcc.dg/tree-ssa/pta-escape-3.c: Likewise.
diff --git gcc/testsuite/ChangeLog.Atmel gcc/testsuite/ChangeLog.Atmel
new file mode 100644
index 0000000..43514e7
--- /dev/null
+++ gcc/testsuite/ChangeLog.Atmel
@@ -0,0 +1,8 @@
+2013-09-12  Senthil Kumar Selvaraj <senthil_kumar.selvaraj@atmel.com>
+
+	* gcc.target/avr/misspelled-handler-warning.c: New test.
+	* gcc.target/avr/xmega_const_hi_io_address.c: New test.
+	* gcc.target/avr/xmega_const_qi_io_address.c: New test.
+	* gcc.target/avr/xmega_interrupt_no_cli.c: New test.
+	* gcc.target/avr/xmega_sfr_offsets.c: New test.
+
diff --git gcc/testsuite/c-c++-common/scal-to-vec1.c gcc/testsuite/c-c++-common/scal-to-vec1.c
index beb450d..52cc2e3 100644
--- gcc/testsuite/c-c++-common/scal-to-vec1.c
+++ gcc/testsuite/c-c++-common/scal-to-vec1.c
@@ -26,13 +26,13 @@ int main (int argc, char *argv[]) {
     int     i = 12;
     double  d = 3.;
 
-    v1 = i + v0;        /* { dg-error "conversion of scalar \[^\\n\]* to vector" } */
+    v1 = i + v0;        /* { dg-error "conversion of scalar \[^\\n\]* to vector" "scalar to vector" { target { ! int16 } } } */
     v1 = 99999 + v0;    /* { dg-error "conversion of scalar \[^\\n\]* to vector" } */
 
-    f1 = d + f0;        /* { dg-error "conversion of scalar \[^\\n\]* to vector" } */
-    f1 = 1.3 + f0;      /* { dg-error "conversion of scalar \[^\\n\]* to vector" } */
+    f1 = d + f0;        /* { dg-error "conversion of scalar \[^\\n\]* to vector" "scalar to vector" { target { large_double } } } */
+    f1 = 1.3 + f0;      /* { dg-error "conversion of scalar \[^\\n\]* to vector" "scalar to vector" { target { large_double } } } */
     f1 = sll + f0;      /* { dg-error "conversion of scalar \[^\\n\]* to vector" } */
-    f1 = ((int)998769576) + f0; /* { dg-error "conversion of scalar \[^\\n\]* to vector" } */
+    f1 = ((int)998769576) + f0; /* { dg-error "conversion of scalar \[^\\n\]* to vector" "scalar to vector" { target { ! int16 } } } */
 
     /* convert.c should take care of this.  */
     i1 = sfl + i0;      /* { dg-error "can't convert value to a vector|invalid operands" } */
diff --git gcc/testsuite/c-c++-common/simulate-thread/bitfields-2.c gcc/testsuite/c-c++-common/simulate-thread/bitfields-2.c
index 392f779..0b29ffb 100644
--- gcc/testsuite/c-c++-common/simulate-thread/bitfields-2.c
+++ gcc/testsuite/c-c++-common/simulate-thread/bitfields-2.c
@@ -1,4 +1,4 @@
-/* { dg-do link } */
+/* { dg-do link { target { ! int16 } } } */
 /* { dg-options "--param allow-store-data-races=0" } */
 /* { dg-final { simulate-thread } } */
 
diff --git gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c
index 070db97..6899d4b 100644
--- gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c
+++ gcc/testsuite/gcc.c-torture/compile/limits-externdecl.c
@@ -52,4 +52,4 @@ LIM5 (X);
 REFERENCE references[] = {
   LIM5 (X)
   0
-};
+}; /* { dg-error "size of array is too large" "" { target avr-*-* } } */
diff --git gcc/testsuite/gcc.c-torture/execute/pr53366-1.x gcc/testsuite/gcc.c-torture/execute/pr53366-1.x
new file mode 100644
index 0000000..eeb3846
--- /dev/null
+++ gcc/testsuite/gcc.c-torture/execute/pr53366-1.x
@@ -0,0 +1,7 @@
+load_lib target-supports.exp
+
+if { [check_effective_target_int16] } {
+	return 1
+}
+
+return 0
diff --git gcc/testsuite/gcc.c-torture/execute/pr56799.x gcc/testsuite/gcc.c-torture/execute/pr56799.x
new file mode 100644
index 0000000..4efed4c
--- /dev/null
+++ gcc/testsuite/gcc.c-torture/execute/pr56799.x
@@ -0,0 +1,7 @@
+load_lib target-supports.exp
+
+if { [check_effective_target_int32plus] } {
+	return 0
+}
+
+return 1;
diff --git gcc/testsuite/gcc.c-torture/execute/pr57344-2.x gcc/testsuite/gcc.c-torture/execute/pr57344-2.x
new file mode 100644
index 0000000..121fcfe
--- /dev/null
+++ gcc/testsuite/gcc.c-torture/execute/pr57344-2.x
@@ -0,0 +1,7 @@
+load_lib target-supports.exp
+
+if { [check_effective_target_int16] } {
+	return 1
+}
+
+return 0;
diff --git gcc/testsuite/gcc.dg/c1x-align-3.c gcc/testsuite/gcc.dg/c1x-align-3.c
index 0b2a77f..b97351c 100644
--- gcc/testsuite/gcc.dg/c1x-align-3.c
+++ gcc/testsuite/gcc.dg/c1x-align-3.c
@@ -23,6 +23,7 @@ _Alignas (-(__LONG_LONG_MAX__-1)/4) char i3; /* { dg-error "too large|power of 2
 _Alignas (-(__LONG_LONG_MAX__-1)/8) char i4; /* { dg-error "too large|power of 2" } */
 _Alignas (-(__LONG_LONG_MAX__-1)/16) char i5; /* { dg-error "too large|power of 2" } */
 _Alignas (-1) char j; /* { dg-error "power of 2" } */
+_Alignas (-2) char j; /* { dg-error "positive power of 2" } */
 _Alignas (3) char k; /* { dg-error "power of 2" } */
 
 _Alignas ((void *) 1) char k; /* { dg-error "integer constant" } */
diff --git gcc/testsuite/gcc.dg/c99-stdint-1.c gcc/testsuite/gcc.dg/c99-stdint-1.c
index 37e1203..89bdec8 100644
--- gcc/testsuite/gcc.dg/c99-stdint-1.c
+++ gcc/testsuite/gcc.dg/c99-stdint-1.c
@@ -214,7 +214,7 @@ test_max (void)
 void
 test_misc_limits (void)
 {
-/* { dg-bogus  "size" "ptrdiff is 16bits" { xfail avr-*-* } 218 } */
+/* { dg-bogus  "size" "ptrdiff is 16bits" { xfail avr-*-* } 56 } */
   CHECK_SIGNED_LIMITS_2(__PTRDIFF_TYPE__, PTRDIFF_MIN, PTRDIFF_MAX, -65535L, 65535L);
 #ifndef SIGNAL_SUPPRESS
   CHECK_LIMITS_2(sig_atomic_t, SIG_ATOMIC_MIN, SIG_ATOMIC_MAX, -127, 127, 255);
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/aranges-fnsec-1.c gcc/testsuite/gcc.dg/debug/dwarf2/aranges-fnsec-1.c
index 8a97e4d..4e40aea 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/aranges-fnsec-1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/aranges-fnsec-1.c
@@ -3,7 +3,7 @@
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
 /* { dg-do compile } */
 /* { dg-require-effective-target function_sections } */
-/* { dg-options "-gdwarf-2 -ffunction-sections -w -dA" } */
+/* { dg-options "-gdwarf -ffunction-sections -w -dA" } */
 /* { dg-final { scan-assembler-not "\\.Letext0-\\.Ltext0" } } */
 /* { dg-final { scan-assembler-not "\\.Ltext0\[^\n\r\]*Offset 0x0" } } */
 /* { dg-final { scan-assembler "DW_AT_ranges" } } */
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/asm-line1.c gcc/testsuite/gcc.dg/debug/dwarf2/asm-line1.c
index 1d2e148..1851e12 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/asm-line1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/asm-line1.c
@@ -1,6 +1,6 @@
 /* PR debug/50983 */
 /* { dg-do compile { target *-*-linux-gnu } } */
-/* { dg-options "-O0 -gdwarf-2" } */
+/* { dg-options "-O0 -gdwarf" } */
 /* { dg-final { scan-assembler "is_stmt 1" } } */
 
 int i;
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/c99-typedef1.c gcc/testsuite/gcc.dg/debug/dwarf2/c99-typedef1.c
index b7bd66a..c1ca1eb 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/c99-typedef1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/c99-typedef1.c
@@ -1,4 +1,4 @@
-// { dg-options "-std=iso9899:1999 -gdwarf-2" }
+// { dg-options "-std=iso9899:1999 -gdwarf" }
 
 void f() {
   int n = 3;
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/const-2.c gcc/testsuite/gcc.dg/debug/dwarf2/const-2.c
index 16e1d8b..b139122 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/const-2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/const-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target powerpc_altivec_ok } } */
-/* { dg-options "-O -gdwarf-2 -dA -maltivec" } */
+/* { dg-options "-O -gdwarf -dA -maltivec" } */
 /* { dg-final { scan-assembler "DW_AT_const_value" } } */
 
 typedef float FloatVect __attribute__((__vector_size__(16)));
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/const-2b.c gcc/testsuite/gcc.dg/debug/dwarf2/const-2b.c
index 6cbdc85..e7d199d 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/const-2b.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/const-2b.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target i386*-*-* } } */
-/* { dg-options "-O -gdwarf-2 -dA -msse" } */
+/* { dg-options "-O -gdwarf -dA -msse" } */
 /* { dg-require-effective-target sse } */
 /* { dg-final { scan-assembler "DW_AT_const_value" } } */
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char1.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char1.c
index ed32349..23f9596 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char1.c
@@ -1,6 +1,6 @@
 /* PR debug/7241 */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 /* { dg-skip-if "Unmatchable assembly" { mmix-*-* } { "*" } { "" } } */
 /* { dg-final { scan-assembler "0x\[68\]\[ \t\]+\[#@;!/|\]+\[ \t\]+DW_AT_encoding" } } */
 /* { dg-final { scan-assembler-not "0x\[57\]\[ \t\]+\[#@;!/|\]+\[ \t\]+DW_AT_encoding" } } */
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char2.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char2.c
index dc14585..4a4bd43 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char2.c
@@ -1,6 +1,6 @@
 /* PR debug/7241 */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 /* { dg-skip-if "Unmatchable assembly" { mmix-*-* } { "*" } { "" } } */
 /* { dg-final { scan-assembler "0x\[68\]\[ \t\]+\[#@;!/|\]+\[ \t\]+DW_AT_encoding" } } */
 /* { dg-final { scan-assembler-not "0x\[57\]\[ \t\]+\[#@;!/|\]+\[ \t\]+DW_AT_encoding" } } */
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char3.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char3.c
index edc1d83..4ff201f 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char3.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-char3.c
@@ -1,6 +1,6 @@
 /* PR debug/7241 */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 /* { dg-skip-if "Unmatchable assembly" { mmix-*-* } { "*" } { "" } } */
 /* { dg-final { scan-assembler "0x\[68\]\[ \t\]+\[#@;!/|\]+\[ \t\]+DW_AT_encoding" } } */
 /* { dg-final { scan-assembler-not "0x\[57\]\[ \t\]+\[#@;!/|\]+\[ \t\]+DW_AT_encoding" } } */
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-dfp.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-dfp.c
index ddb6022..951380f 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-dfp.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-dfp.c
@@ -2,7 +2,7 @@
 
 /* { dg-do compile */
 /* { dg-require-effective-target dfp } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 /* { dg-final { scan-assembler "0x10.*DW_AT_encoding" } } */
 /* { dg-final { scan-assembler "0x4.*DW_AT_byte_size" } } */
 /* { dg-final { scan-assembler "0x8.*DW_AT_byte_size" } } */
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die1.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die1.c
index fdfbf83..9ca84e7 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die1.c
@@ -1,6 +1,6 @@
 /* Verify that inline function never actually inlined has no abstract DIE.  */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 /* { dg-final { scan-assembler-not "DW_AT_inline" } } */
 inline int t()
 {
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die2.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die2.c
index ac897ab..746ab03 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die2.c
@@ -1,6 +1,6 @@
 /* Verify that inline function never actually emit has no DIE.  */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 /* { dg-final { scan-assembler-not "CIE Version" } } */
 static inline int t()
 {
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die3.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die3.c
index 04b2f36..2b071fc 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die3.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die3.c
@@ -1,6 +1,6 @@
 /* Verify that extern inline function never actually inlined has no abstract DIE.  */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 /* { dg-final { scan-assembler-not "DW_AT_inline" } } */
 extern inline int t()
 {
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die5.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die5.c
index 3fefd41..68985b7 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die5.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die5.c
@@ -1,6 +1,6 @@
 /* Inlined inline function must have abstract DIE  */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA -fpreprocessed" } */
+/* { dg-options "-O2 -gdwarf -dA -fpreprocessed" } */
 /* { dg-final { scan-assembler "3.*DW_AT_inline" } } */
 #1 "test.h"
 inline int t()
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die6.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die6.c
index d8f477f..ff0d679 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die6.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die6.c
@@ -1,6 +1,6 @@
 /* not inline inline function must not have abstract DIE  */
 /* { dg-do compile } */
-/* { dg-options "-O2 -fno-inline -gdwarf-2 -dA -fpreprocessed" } */
+/* { dg-options "-O2 -fno-inline -gdwarf -dA -fpreprocessed" } */
 /* { dg-final { scan-assembler-not "DW_AT_inline" } } */
 #1 "test.h"
 inline int t()
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die7.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die7.c
index b747076..88d78e2 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die7.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-die7.c
@@ -1,6 +1,6 @@
 /* Inlined non-inline function must have abstract DIE  */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA -fpreprocessed" } */
+/* { dg-options "-O2 -gdwarf -dA -fpreprocessed" } */
 /* { dg-final { scan-assembler "1.*DW_AT_inline" } } */
 #1 "test.h"
 void f(void);
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-file1.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-file1.c
index c68dfe4..b753955 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-file1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-file1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 /* { dg-final { scan-assembler "File Entry:|.file" } } */
 /* Verify that a file entry is output for this file.  Only systems that
    do not define HAVE_AS_DWARF2_DEBUG_LINE will put out "File Entry:",
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-float.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-float.c
index 84d605f..a028d14 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-float.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-float.c
@@ -1,7 +1,7 @@
 /* Verify the DWARF encoding of C99 floating point types.  */
 
 /* { dg-do compile */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 /* { dg-final { scan-assembler "0x4.*DW_AT_encoding" } } */
 /* { dg-final { scan-assembler "0x4.*DW_AT_byte_size" } } */
 /* { dg-final { scan-assembler "0x8.*DW_AT_byte_size" } } */
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-merge.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-merge.c
index 767d38b..15e09b1 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-merge.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-merge.c
@@ -1,7 +1,7 @@
 /* Verify that mergeable strings are used in the CU DIE.  */
 /* { dg-do compile } */
 /* { dg-require-effective-target string_merging } */
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 /* { dg-final { scan-assembler "DW_AT_producer: \"GNU C" } } */
 /* { dg-final { scan-assembler-not "GNU C\[^\\n\\r\]*DW_AT_producer" } } */
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-uninit.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-uninit.c
index 7bcebe3..d871bab 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-uninit.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-uninit.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 /* { dg-final { scan-assembler "DW_TAG_variable" } } */
 /* PR debug/21828 */
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf2-macro.c gcc/testsuite/gcc.dg/debug/dwarf2/dwarf2-macro.c
index 4efb25e..fd61296 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf2-macro.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf2-macro.c
@@ -1,6 +1,6 @@
 /* Test to make sure the mcaro info includes a start file command for the main source */
 /* { dg-do compile } */
-/* { dg-options "-g3 -gdwarf-2 -dA -fverbose-asm" } */
+/* { dg-options "-g3 -gdwarf -dA -fverbose-asm" } */
 /* { dg-final { scan-assembler "Start new file" } } */
 
 #define ADD(x) (M + x)
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/dwarf2.exp gcc/testsuite/gcc.dg/debug/dwarf2/dwarf2.exp
index 829840c..824d994 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/dwarf2.exp
+++ gcc/testsuite/gcc.dg/debug/dwarf2/dwarf2.exp
@@ -22,7 +22,7 @@ load_lib gcc-dg.exp
 # If a testcase doesn't have special options, use these.
 global DEFAULT_CFLAGS
 if ![info exists DEFAULT_CFLAGS] then {
-    set DEFAULT_CFLAGS " -ansi -pedantic-errors -gdwarf-2"
+    set DEFAULT_CFLAGS " -ansi -pedantic-errors -gdwarf"
 }
 
 # Initialize `dg'.
@@ -31,7 +31,7 @@ dg-init
 # Main loop.
 set comp_output [gcc_target_compile \
     "$srcdir/$subdir/../trivial.c" "trivial.S" assembly \
-    "additional_flags=-gdwarf-2"]
+    "additional_flags=-gdwarf"]
 if { ! [string match "*: target system does not support the * debug format*" \
     $comp_output] } {
     remove-build-file "trivial.S"
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/fesd-any.c gcc/testsuite/gcc.dg/debug/dwarf2/fesd-any.c
index fc51090..810788a 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/fesd-any.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/fesd-any.c
@@ -1,5 +1,5 @@
 // { dg-do compile }
-// { dg-options "-gdwarf-2 -dA -femit-struct-debug-detailed=any" }
+// { dg-options "-gdwarf -dA -femit-struct-debug-detailed=any" }
 // { dg-final { scan-assembler "timespec.*DW_AT_name" } }
 // { dg-final { scan-assembler "tv_sec.*DW_AT_name" } }
 // { dg-final { scan-assembler "tv_nsec.*DW_AT_name" } }
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/fesd-baseonly.c gcc/testsuite/gcc.dg/debug/dwarf2/fesd-baseonly.c
index a32abb5..aefcb87 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/fesd-baseonly.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/fesd-baseonly.c
@@ -1,5 +1,5 @@
 // { dg-do compile }
-// { dg-options "-gdwarf-2 -dA -femit-struct-debug-baseonly" }
+// { dg-options "-gdwarf -dA -femit-struct-debug-baseonly" }
 // { dg-final { scan-assembler "timespec.*DW_AT_name" } }
 // { dg-final { scan-assembler-not "tv_sec.*DW_AT_name" } }
 // { dg-final { scan-assembler-not "tv_nsec.*DW_AT_name" } }
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/fesd-none.c gcc/testsuite/gcc.dg/debug/dwarf2/fesd-none.c
index bd218f8..193c05d 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/fesd-none.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/fesd-none.c
@@ -1,5 +1,5 @@
 // { dg-do compile }
-// { dg-options "-gdwarf-2 -dA -femit-struct-debug-detailed=none" }
+// { dg-options "-gdwarf -dA -femit-struct-debug-detailed=none" }
 // { dg-final { scan-assembler "timespec.*DW_AT_name" } }
 // { dg-final { scan-assembler-not "tv_sec.*DW_AT_name" } }
 // { dg-final { scan-assembler-not "tv_nsec.*DW_AT_name" } }
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/fesd-reduced.c gcc/testsuite/gcc.dg/debug/dwarf2/fesd-reduced.c
index ac599f4..ebbfc36 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/fesd-reduced.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/fesd-reduced.c
@@ -1,5 +1,5 @@
 // { dg-do compile }
-// { dg-options "-gdwarf-2 -dA -femit-struct-debug-reduced" }
+// { dg-options "-gdwarf -dA -femit-struct-debug-reduced" }
 // { dg-final { scan-assembler "timespec.*DW_AT_name" } }
 // { dg-final { scan-assembler "tv_sec.*DW_AT_name" } }
 // { dg-final { scan-assembler "tv_nsec.*DW_AT_name" } }
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/fesd-sys.c gcc/testsuite/gcc.dg/debug/dwarf2/fesd-sys.c
index 3a5c0bf..ad0a44a 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/fesd-sys.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/fesd-sys.c
@@ -1,5 +1,5 @@
 // { dg-do compile }
-// { dg-options "-gdwarf-2 -dA -femit-struct-debug-detailed=sys" }
+// { dg-options "-gdwarf -dA -femit-struct-debug-detailed=sys" }
 // { dg-final { scan-assembler "timespec.*DW_AT_name" } }
 // { dg-final { scan-assembler "tv_sec.*DW_AT_name" } }
 // { dg-final { scan-assembler "tv_nsec.*DW_AT_name" } }
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/global-used-types.c gcc/testsuite/gcc.dg/debug/dwarf2/global-used-types.c
index 54fa58a..431b429 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/global-used-types.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/global-used-types.c
@@ -1,6 +1,6 @@
 /*
  Contributed by Dodji Seketeli <dodji@redhat.com>
- { dg-options "-g -dA -fno-merge-debug-strings" }
+ { dg-options "-gdwarf -dA -fno-merge-debug-strings" }
  { dg-do compile }
  { dg-final { scan-assembler-times "DIE \\(0x\[^\n\]*\\) DW_TAG_enumeration_type" 1 } }
  { dg-final { scan-assembler-times "DIE \\(0x\[^\n\]*\\) DW_TAG_enumerator" 2 } }
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/inline1.c gcc/testsuite/gcc.dg/debug/dwarf2/inline1.c
index 11c8fad..bd7f7b9 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/inline1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/inline1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 void e(int);
 __attribute__ ((always_inline)) inline int
 t(int function_parameter)
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c
index 20edb58..b194769 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c
@@ -14,7 +14,7 @@
   properly nested DW_TAG_inlined_subroutine DIEs for third, second and first.
 */
 
-/* { dg-options "-O -g3 -dA" } */
+/* { dg-options "-O -g3 -gdwarf -dA" } */
 /* { dg-do compile } */
 
 /* There are 6 inlined subroutines:
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/inline3.c gcc/testsuite/gcc.dg/debug/dwarf2/inline3.c
index d2d3e0f..baa2f66 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/inline3.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/inline3.c
@@ -1,7 +1,7 @@
 /* Verify that only one DW_AT_const_value is emitted for baz,
    not for baz abstract DIE and again inside of
    DW_TAG_inlined_subroutine.  */
-/* { dg-options "-O2 -g -dA -fmerge-all-constants" } */
+/* { dg-options "-O2 -gdwarf -dA -fmerge-all-constants" } */
 /* { dg-do compile } */
 /* { dg-final { scan-assembler-times " DW_AT_const_value" 1 } } */
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/ipa-cp1.c gcc/testsuite/gcc.dg/debug/dwarf2/ipa-cp1.c
index 7442dab..395c544 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/ipa-cp1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/ipa-cp1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 void q(int p);
 static void
 t(int constant_propagated_par)
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-1.c gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-1.c
index 5476aac..e818263 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-1.c
@@ -1,7 +1,7 @@
 /* PR debug/29609 */
 /* Verify that breakpoint on the break is hit.  */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 
 void abort (void);
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-2.c gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-2.c
index 43bc545..463d3cc 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr29609-2.c
@@ -1,7 +1,7 @@
 /* PR debug/29609 */
 /* Verify that breakpoint on both goto failure; stmts is hit.  */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 
 extern void abort (void);
 int x;
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr31230.c gcc/testsuite/gcc.dg/debug/dwarf2/pr31230.c
index ce26ec6..36d55bf 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr31230.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr31230.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-gdwarf-2 -dA --param ggc-min-expand=0 --param ggc-min-heapsize=0" } */
+/* { dg-options "-gdwarf -dA --param ggc-min-expand=0 --param ggc-min-heapsize=0" } */
 /* { dg-final { scan-assembler-times "DIE.*DW_TAG_array_type" 1  } } */
 /* { dg-final { scan-assembler-times "DIE.*DW_TAG_subrange_type" 1  } } */
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-1.c gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-1.c
index de90acb..d84ce26 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-1.c
@@ -1,7 +1,7 @@
 /* PR debug/36690 */
 /* Verify that break func is hit.  */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 
 int i;
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-2.c gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-2.c
index 2330f53..0927e74 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-2.c
@@ -3,7 +3,7 @@
    varz at that spot is defined and contains 5.  Nowhere else
    in the function should be varz in the scope.  */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 
 int cnt;
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-3.c gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-3.c
index 234ad12..bc492f2 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-3.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr36690-3.c
@@ -1,6 +1,6 @@
 /* PR debug/36690 */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 
 int cnt;
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr37616.c gcc/testsuite/gcc.dg/debug/dwarf2/pr37616.c
index badff44..016dbc9 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr37616.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr37616.c
@@ -2,7 +2,7 @@
 /* Test that one can put breakpoints onto continue, exitlab and break
    and actually see program reaching those breakpoints.  */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 
 extern void abort (void);
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr37726.c gcc/testsuite/gcc.dg/debug/dwarf2/pr37726.c
index 60fb839..622fbcf 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr37726.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr37726.c
@@ -1,6 +1,6 @@
 /* PR debug/37726 */
 /* { dg-do compile } */
-/* { dg-options "-g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 int foo (int parm)
 {
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-1.c gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-1.c
index 452c0f6..4e856ec 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-1.c
@@ -2,7 +2,7 @@
 /* Test that token after multi-line function-like macro use
    gets correct locus even when preprocessing separately.  */
 /* { dg-do compile } */
-/* { dg-options "-save-temps -g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-save-temps -gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 #define A(a,b)
 int varh;A(1,
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-2.c gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-2.c
index d2ee408..e416b0f 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-2.c
@@ -1,6 +1,6 @@
 /* PR preprocessor/41445 */
 /* { dg-do compile } */
-/* { dg-options "-g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 #include "pr41445-1.c"
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-3.c gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-3.c
index 2a74dc5..46f57e6 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-3.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-3.c
@@ -2,7 +2,7 @@
 /* Test that token after multi-line function-like macro use
    gets correct locus even when preprocessing separately.  */
 /* { dg-do compile } */
-/* { dg-options "-save-temps -g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-save-temps -gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 #define A(a,b)
 int varh;/*
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-4.c gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-4.c
index 8aa92de..409f79f 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-4.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-4.c
@@ -1,6 +1,6 @@
 /* PR preprocessor/41445 */
 /* { dg-do compile } */
-/* { dg-options "-g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 #include "pr41445-3.c"
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c
index d21acd5..de5a1cc 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-5.c
@@ -2,7 +2,7 @@
 /* Test that token after multi-line function-like macro use
    gets correct locus even when preprocessing separately.  */
 /* { dg-do compile } */
-/* { dg-options "-save-temps -g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-save-temps -gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 #define A(x) vari x
 #define vari(x)
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-6.c gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-6.c
index d6d79cc..340cb38 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-6.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr41445-6.c
@@ -1,6 +1,6 @@
 /* PR preprocessor/41445 */
 /* { dg-do compile } */
-/* { dg-options "-g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 #include "pr41445-5.c"
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr41543.c gcc/testsuite/gcc.dg/debug/dwarf2/pr41543.c
index 0268396..872ed7d 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr41543.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr41543.c
@@ -1,6 +1,6 @@
 /* PR preprocessor/41543 */
 /* { dg-do compile } */
-/* { dg-options "-save-temps -g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-save-temps -gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 #include <stdarg.h>
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr41695.c gcc/testsuite/gcc.dg/debug/dwarf2/pr41695.c
index d61b5a2..90ae5cd 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr41695.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr41695.c
@@ -1,6 +1,6 @@
 /* PR debug/41695 */
 /* { dg-do compile } */
-/* { dg-options "-g -O2 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-gdwarf -O2 -dA -fno-merge-debug-strings" } */
 
 int bar (int);
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr43237.c gcc/testsuite/gcc.dg/debug/dwarf2/pr43237.c
index 21262c3..8db2543 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr43237.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr43237.c
@@ -1,6 +1,6 @@
 /* PR debug/43237 */
 /* { dg-do compile } */
-/* { dg-options "-g -O2 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-gdwarf -O2 -dA -fno-merge-debug-strings" } */
 
 struct S
 {
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-1.c gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-1.c
index 2e4c3cd..a859ac9 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-save-temps -g -dA" } */
+/* { dg-options "-save-temps -gdwarf -dA" } */
 
 typedef struct _Harry { int dummy; } Harry_t;
 Harry_t harry;
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-2.c gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-2.c
index 13856d7..dfbfa2f 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-save-temps -g -dA" } */
+/* { dg-options "-save-temps -gdwarf -dA" } */
 
 typedef const struct _Harry { int dummy; } Harry_t;
 Harry_t harry;
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-3.c gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-3.c
index f1e463e..c8039ef 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-3.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-save-temps -g -dA" } */
+/* { dg-options "-save-temps -gdwarf -dA" } */
 
 typedef struct _Harry { int dummy; } Harry_t;
 const Harry_t harry[5];
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-4.c gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-4.c
index cf0a2af..bd2351b 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-4.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr47939-4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-save-temps -g -dA" } */
+/* { dg-options "-save-temps -gdwarf -dA" } */
 
 typedef const struct _Harry { int dummy; } Harry_t;
 Harry_t harry[10];
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr51410.c gcc/testsuite/gcc.dg/debug/dwarf2/pr51410.c
index 957c152..62b389e 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr51410.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr51410.c
@@ -1,6 +1,6 @@
 /* PR debug/51410 */
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-O0 -gdwarf -dA -fno-merge-debug-strings" } */
 
 int x;
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/pr53948.c gcc/testsuite/gcc.dg/debug/dwarf2/pr53948.c
index d2d44ea..0ec3e84 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/pr53948.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/pr53948.c
@@ -1,6 +1,6 @@
 /* Test that we have line information for the line
    with local variable initializations.  */
-/* { dg-options "-O0 -g -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 /* { dg-final { scan-assembler ".loc 1 8 0|\[#/!\]\[ \t\]+line 8" } } */
 
 
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/short-circuit.c gcc/testsuite/gcc.dg/debug/dwarf2/short-circuit.c
index 7e745ff..4fa199c 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/short-circuit.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/short-circuit.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O0 -gdwarf-2 -dA" } */
+/* { dg-options "-O0 -gdwarf -dA" } */
 
 #define True  1
 #define False 0
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/static1.c gcc/testsuite/gcc.dg/debug/dwarf2/static1.c
index b9b5d0b..bdc118d 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/static1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/static1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf-2" } */
+/* { dg-options "-O2 -gdwarf" } */
 void
 main(void)
 {
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/struct-loc1.c gcc/testsuite/gcc.dg/debug/dwarf2/struct-loc1.c
index 216a498..bf893ee 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/struct-loc1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/struct-loc1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-g -O0 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-gdwarf -O0 -dA -fno-merge-debug-strings" } */
 
 struct foo;
 struct foo *obj;
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/var1.c gcc/testsuite/gcc.dg/debug/dwarf2/var1.c
index 04dd129..297d244 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/var1.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/var1.c
@@ -1,6 +1,6 @@
 /* PR 23190 */
 /* { dg-do compile }
-/* { dg-options "-gdwarf-2 -dA -fno-merge-debug-strings" } */
+/* { dg-options "-gdwarf -dA -fno-merge-debug-strings" } */
 /* { dg-final { scan-assembler "xyzzy\[^\\n\\r\]+DW_AT_name" } } */
 
 void f(void)
diff --git gcc/testsuite/gcc.dg/debug/dwarf2/var2.c gcc/testsuite/gcc.dg/debug/dwarf2/var2.c
index 8ef2a74..72aef41 100644
--- gcc/testsuite/gcc.dg/debug/dwarf2/var2.c
+++ gcc/testsuite/gcc.dg/debug/dwarf2/var2.c
@@ -1,6 +1,6 @@
 /* PR 23190 */
 /* { dg-do compile }
-/* { dg-options "-O2 -gdwarf-2 -dA" } */
+/* { dg-options "-O2 -gdwarf -dA" } */
 /* { dg-final { scan-assembler "DW_OP_addr\[\\n\\r\]+\[^\\n\\r\]+foo" } } */
 /* { dg-final { scan-assembler "DW_OP_addr\[\\n\\r\]+\[^\\n\\r\]+bar" } } */
 
diff --git gcc/testsuite/gcc.dg/ipa/ipa-pta-14.c gcc/testsuite/gcc.dg/ipa/ipa-pta-14.c
index e8abc32..ac6ccbe 100644
--- gcc/testsuite/gcc.dg/ipa/ipa-pta-14.c
+++ gcc/testsuite/gcc.dg/ipa/ipa-pta-14.c
@@ -22,7 +22,7 @@ int main()
   a.p = (void *)&c;
   p = foo(&a, &a);
   /* { dg-final { scan-ipa-dump "foo.result = { NULL a\[^ \]* c\[^ \]* }" "pta" { xfail *-*-* } } } */
-  /* { dg-final { scan-ipa-dump "foo.result = { NULL a\[^ \]* a\[^ \]* c\[^ \]* }" "pta" } } */
+  /* { dg-final { scan-ipa-dump "foo.result = { NULL a\[^ \]* a\[^ \]* c\[^ \]* }" "pta" { target { ! keeps_null_pointer_checks } } } } */
   ((struct X *)p)->p = (void *)0;
   if (a.p != (void *)0)
     abort ();
diff --git gcc/testsuite/gcc.dg/large-size-array-6.c gcc/testsuite/gcc.dg/large-size-array-6.c
new file mode 100644
index 0000000..f7da47e
--- /dev/null
+++ gcc/testsuite/gcc.dg/large-size-array-6.c
@@ -0,0 +1,6 @@
+/* PR c/57821 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+static char * name[] = {
+    [0x8000000000000000]  = "bar"
+  }; /* { dg-error "too large" } */
diff --git gcc/testsuite/gcc.dg/pr44214-1.c gcc/testsuite/gcc.dg/pr44214-1.c
index 292ce57..28194e4 100644
--- gcc/testsuite/gcc.dg/pr44214-1.c
+++ gcc/testsuite/gcc.dg/pr44214-1.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -freciprocal-math -fdump-tree-ccp1" } */
 
-typedef double v2df __attribute__ ((vector_size (16)));
+typedef double v2df __attribute__ ((vector_size (2 * sizeof (double))));
 
 void do_div (v2df *a, v2df *b)
 {
diff --git gcc/testsuite/gcc.dg/pr44214-3.c gcc/testsuite/gcc.dg/pr44214-3.c
index 46d5ee8..a0eb35b 100644
--- gcc/testsuite/gcc.dg/pr44214-3.c
+++ gcc/testsuite/gcc.dg/pr44214-3.c
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-ccp1" } */
 
-typedef double v2df __attribute__ ((vector_size (16)));
+typedef double v2df __attribute__ ((vector_size (2 * sizeof (double))));
 
 void do_div (v2df *a, v2df *b)
 {
diff --git gcc/testsuite/gcc.dg/pr46647.c gcc/testsuite/gcc.dg/pr46647.c
index 961bd32..4510d69 100644
--- gcc/testsuite/gcc.dg/pr46647.c
+++ gcc/testsuite/gcc.dg/pr46647.c
@@ -25,6 +25,6 @@ func3 (void)
   return 0;
 }
 
-/* The xfail for cris-* and crisv32-* is due to PR53535.  */
-/* { dg-final { scan-tree-dump-not "memset" "optimized" { xfail cris-*-* crisv32-*-* } } } */
+/* The xfail for avr, cris-* and crisv32-* is due to PR53535.  */
+/* { dg-final { scan-tree-dump-not "memset" "optimized" { xfail avr-*-* cris-*-* crisv32-*-* } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git gcc/testsuite/gcc.dg/pr53265.c gcc/testsuite/gcc.dg/pr53265.c
index c60a736..8b342db 100644
--- gcc/testsuite/gcc.dg/pr53265.c
+++ gcc/testsuite/gcc.dg/pr53265.c
@@ -1,6 +1,7 @@
 /* PR tree-optimization/53265 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -Wall" } */
+/* { dg-require-effective-target size32plus } */
 
 void bar (void *);
 int baz (int);
diff --git gcc/testsuite/gcc.dg/strlenopt-10.c gcc/testsuite/gcc.dg/strlenopt-10.c
index a18c06a..b044496 100644
--- gcc/testsuite/gcc.dg/strlenopt-10.c
+++ gcc/testsuite/gcc.dg/strlenopt-10.c
@@ -70,7 +70,10 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "strlen \\(" 2 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "memcpy \\(" 8 "strlen" } } */
+/* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op
+   to expand the memcpy call at the end of fn2.  */
+/* { dg-final { scan-tree-dump-times "memcpy \\(" 8 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "memcpy \\(" 7 "strlen" { target { avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "strcpy \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
diff --git gcc/testsuite/gcc.dg/strlenopt-11.c gcc/testsuite/gcc.dg/strlenopt-11.c
index 888eeb2..0fb327c 100644
--- gcc/testsuite/gcc.dg/strlenopt-11.c
+++ gcc/testsuite/gcc.dg/strlenopt-11.c
@@ -59,12 +59,18 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "strlen \\(" 3 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "memcpy \\(" 7 "strlen" } } */
+/* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op
+   to expand the memcpy call at the end of fn1.  */
+/* { dg-final { scan-tree-dump-times "memcpy \\(" 7 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "memcpy \\(" 6 "strlen" { target { avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "strcpy \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.0. = " 1 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.6. = " 1 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.9. = " 1 "strlen" } } */
+/* Where the memcpy is expanded, the assignemts to elements of l are
+   propagated.  */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.0. = " 1 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.6. = " 1 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.9. = " 1 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;" 3 "strlen" { target { avr-*-* } } } } */
 /* { dg-final { cleanup-tree-dump "strlen" } } */
diff --git gcc/testsuite/gcc.dg/strlenopt-13.c gcc/testsuite/gcc.dg/strlenopt-13.c
index 9413cb5..f9ab561 100644
--- gcc/testsuite/gcc.dg/strlenopt-13.c
+++ gcc/testsuite/gcc.dg/strlenopt-13.c
@@ -56,13 +56,19 @@ main ()
 }
 
 /* { dg-final { scan-tree-dump-times "strlen \\(" 4 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "memcpy \\(" 7 "strlen" } } */
+/* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op
+   to expand the memcpy call at the end of fn1.  */
+/* { dg-final { scan-tree-dump-times "memcpy \\(" 7 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "memcpy \\(" 6 "strlen" { target { avr-*-* } } } } */
 /* { dg-final { scan-tree-dump-times "strcpy \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strcat \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "strchr \\(" 0 "strlen" } } */
 /* { dg-final { scan-tree-dump-times "stpcpy \\(" 0 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.0. = " 1 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.1. = " 1 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.5. = " 1 "strlen" } } */
-/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.6. = " 1 "strlen" } } */
+/* Where the memcpy is expanded, the assignemts to elements of l are
+   propagated.  */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.0. = " 1 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.1. = " 1 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.5. = " 1 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;\[\n\r\]*  l.6. = " 1 "strlen" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "  _\[0-9\]* = strlen \\(\[^\n\r\]*;" 4 "strlen" { target { avr-*-* } } } } */
 /* { dg-final { cleanup-tree-dump "strlen" } } */
diff --git gcc/testsuite/gcc.dg/torture/alias-1.c gcc/testsuite/gcc.dg/torture/alias-1.c
index 1e60341..92b8809 100644
--- gcc/testsuite/gcc.dg/torture/alias-1.c
+++ gcc/testsuite/gcc.dg/torture/alias-1.c
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-fschedule-insns" } */
+/* { dg-require-effective-target scheduling } */
 
 extern void abort (void) __attribute__((noreturn));
 
diff --git gcc/testsuite/gcc.dg/torture/pr53366-1.c gcc/testsuite/gcc.dg/torture/pr53366-1.c
index ca9997e..d70eae8 100644
--- gcc/testsuite/gcc.dg/torture/pr53366-1.c
+++ gcc/testsuite/gcc.dg/torture/pr53366-1.c
@@ -1,5 +1,6 @@
 /* PR tree-optimization/53366 */
-/* { dg-do run } */
+/* { dg-do run { target { size32plus } } } */
+/* { dg-require-effective-target size32plus } */
 
 extern void abort (void);
 
diff --git gcc/testsuite/gcc.dg/torture/pr56488.c gcc/testsuite/gcc.dg/torture/pr56488.c
index 78bac7b..94add8d 100644
--- gcc/testsuite/gcc.dg/torture/pr56488.c
+++ gcc/testsuite/gcc.dg/torture/pr56488.c
@@ -1,4 +1,5 @@
-/* { dg-do run } */
+/* { dg-do run { target { size32plus } } } */
+/* { dg-require-effective-target int32plus } */
 
 int a, c, d = 1;
 struct S { int s; } b, f;
diff --git gcc/testsuite/gcc.dg/torture/pr57425-1.c gcc/testsuite/gcc.dg/torture/pr57425-1.c
new file mode 100644
index 0000000..8ca85ca
--- /dev/null
+++ gcc/testsuite/gcc.dg/torture/pr57425-1.c
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+
+extern void abort (void) __attribute__((noreturn));
+
+union setconflict
+{
+  int a[20];
+  long b[10];
+};
+
+int
+main ()
+{
+  int sum = 0;
+  {
+    union setconflict a;
+    int *c;
+    c = a.a;
+    asm ("": "=r" (c):"0" (c));
+    *c = 0;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+  {
+    union setconflict a;
+    long *c;
+    c = a.b;
+    asm ("": "=r" (c):"0" (c));
+    *c = 1;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+
+  if (sum != 1)
+    abort();
+  return 0;
+}
diff --git gcc/testsuite/gcc.dg/torture/pr57425-2.c gcc/testsuite/gcc.dg/torture/pr57425-2.c
new file mode 100644
index 0000000..ccb546e
--- /dev/null
+++ gcc/testsuite/gcc.dg/torture/pr57425-2.c
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+extern void abort (void) __attribute__((noreturn));
+
+int
+main ()
+{
+  int sum = 0;
+  {
+    int a[20];
+    int *c;
+    c = a;
+    asm ("": "=r" (c):"0" (c));
+    *c = 0;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+  {
+    long b[10];
+    long *c;
+    c = b;
+    asm ("": "=r" (c):"0" (c));
+    *c = 1;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+
+  if (sum != 1)
+    abort();
+  return 0;
+}
diff --git gcc/testsuite/gcc.dg/torture/pr57425-3.c gcc/testsuite/gcc.dg/torture/pr57425-3.c
new file mode 100644
index 0000000..8e0c7fe
--- /dev/null
+++ gcc/testsuite/gcc.dg/torture/pr57425-3.c
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+extern void abort (void) __attribute__((noreturn));
+
+int
+main ()
+{
+  int sum = 0;
+  {
+    long a[20];
+    long *c;
+    c = a;
+    asm ("": "=r" (c):"0" (c));
+    *c = 0;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+  {
+    long long b[10];
+    long long *c;
+    c = b;
+    asm ("": "=r" (c):"0" (c));
+    *c = 1;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+
+  if (sum != 1)
+    abort();
+  return 0;
+}
diff --git gcc/testsuite/gcc.dg/torture/pr57569.c gcc/testsuite/gcc.dg/torture/pr57569.c
new file mode 100644
index 0000000..f036d55
--- /dev/null
+++ gcc/testsuite/gcc.dg/torture/pr57569.c
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+
+extern void abort (void) __attribute__((noreturn));
+
+struct S { int f0; } a; 
+
+int b, e, *d = &b, f;
+
+void 
+fn1 ()
+{
+  int **g[9][6];
+  int ***h = &g[6][3];
+  for (; e < 9; e++) {
+    f = 0;
+    for (; f < 6; f++)
+      g[e][f] = &d;
+  }
+  ***h = 0;
+}
+
+void
+fn2 ()
+{
+  fn1 ();
+  struct S c[4][10] = {};
+  a = c[3][9];
+}
+
+int
+main ()
+{
+  fn2 ();
+  if (a.f0 != 0)
+    abort ();
+  return 0;
+}
diff --git gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
index cbb38ef..566b94f 100644
--- gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
+++ gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
@@ -6,7 +6,10 @@
 
 /* { dg-do run } */
 
-/* { dg-skip-if "Variadic funcs use Base AAPCS.  Normal funcs use VFP variant." { arm_hf_eabi } } */
+/* arm_hf_eabi: Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.
+   avr: Variadic funcs don't pass arguments in registers, while normal funcs
+        do.  */
+/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs" { arm_hf_eabi || { avr-*-* } } "*" "" } */
    
 
 #define INTEGER_ARG  5
diff --git gcc/testsuite/gcc.dg/tree-ssa/pr21090.c gcc/testsuite/gcc.dg/tree-ssa/pr21090.c
index 8e32e42..40d960d 100644
--- gcc/testsuite/gcc.dg/tree-ssa/pr21090.c
+++ gcc/testsuite/gcc.dg/tree-ssa/pr21090.c
@@ -19,5 +19,5 @@ foo (int a)
     return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "Folding predicate.*to 1" 1 "vrp1" } } */
+/* { dg-final { scan-tree-dump-times "Folding predicate.*to 1" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { cleanup-tree-dump "vrp1" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/pr31261.c gcc/testsuite/gcc.dg/tree-ssa/pr31261.c
index 42bd2a2..54f677b 100644
--- gcc/testsuite/gcc.dg/tree-ssa/pr31261.c
+++ gcc/testsuite/gcc.dg/tree-ssa/pr31261.c
@@ -35,6 +35,7 @@ f5 (int e)
 /* { dg-final { scan-tree-dump-times "return -a \& 7;" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return b \& 7;" 1 "original" } } */
 /* { dg-final { scan-tree-dump-times "return \\(char\\) -\\(unsigned char\\) c \& 31;" 1 "original" } } */
-/* { dg-final { scan-tree-dump-times "return \\(int\\) \\(12 - \\(unsigned int\\) d\\) \& 7;" 1 "original" } } */
+/* { dg-final { scan-tree-dump-times "return \\(int\\) \\(12 - \\(unsigned int\\) d\\) \& 7;" 1 "original" { target { ! int16 } } } } */
+/* { dg-final { scan-tree-dump-times "return \\(int\\) \\(12 - \\(unsigned short\\) d\\) \& 7;" 1 "original" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "return 12 - \\(e \& 7\\) \& 15;" 1 "original" } } */
 /* { dg-final { cleanup-tree-dump "original" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/pr42585.c gcc/testsuite/gcc.dg/tree-ssa/pr42585.c
index d01b8ab..58d92ec 100644
--- gcc/testsuite/gcc.dg/tree-ssa/pr42585.c
+++ gcc/testsuite/gcc.dg/tree-ssa/pr42585.c
@@ -35,6 +35,6 @@ Cyc_string_ungetc (int ignore, struct _fat_ptr *sptr)
 /* Whether the structs are totally scalarized or not depends on the
    MOVE_RATIO macro defintion in the back end.  The scalarization will
    not take place when using small values for MOVE_RATIO.  */
-/* { dg-final { scan-tree-dump-times "struct _fat_ptr _ans" 0 "optimized" { target { ! "arm-*-* powerpc*-*-* s390*-*-* sh*-*-*" } } } } */
-/* { dg-final { scan-tree-dump-times "struct _fat_ptr _T2" 0 "optimized" { target { ! "arm-*-* powerpc*-*-* s390*-*-* sh*-*-*" } } } } */
+/* { dg-final { scan-tree-dump-times "struct _fat_ptr _ans" 0 "optimized" { target { ! "arm-*-* avr-*-* powerpc*-*-* s390*-*-* sh*-*-*" } } } } */
+/* { dg-final { scan-tree-dump-times "struct _fat_ptr _T2" 0 "optimized" { target { ! "arm-*-* avr-*-* powerpc*-*-* s390*-*-* sh*-*-*" } } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/pr54245.c gcc/testsuite/gcc.dg/tree-ssa/pr54245.c
index 0e11d06..daca042 100644
--- gcc/testsuite/gcc.dg/tree-ssa/pr54245.c
+++ gcc/testsuite/gcc.dg/tree-ssa/pr54245.c
@@ -45,5 +45,5 @@ int main(void)
 /* For now, disable inserting an initializer when the multiplication will
    take place in a smaller type than originally.  This test may be deleted
    in future when this case is handled more precisely.  */
-/* { dg-final { scan-tree-dump-times "Inserting initializer" 0 "slsr" } } */
+/* { dg-final { scan-tree-dump-times "Inserting initializer" 0 "slsr" { target { ! int16 } } } } */
 /* { dg-final { cleanup-tree-dump "slsr" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/pr57385.c gcc/testsuite/gcc.dg/tree-ssa/pr57385.c
index fc21461..a1f001d 100644
--- gcc/testsuite/gcc.dg/tree-ssa/pr57385.c
+++ gcc/testsuite/gcc.dg/tree-ssa/pr57385.c
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O1" } */
+/* { dg-require-effective-target int32plus } */
 
 int c;
 
diff --git gcc/testsuite/gcc.dg/tree-ssa/pta-escape-1.c gcc/testsuite/gcc.dg/tree-ssa/pta-escape-1.c
index a424417..f71e9ff 100644
--- gcc/testsuite/gcc.dg/tree-ssa/pta-escape-1.c
+++ gcc/testsuite/gcc.dg/tree-ssa/pta-escape-1.c
@@ -33,5 +33,5 @@ int main()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" } } */
+/* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { cleanup-tree-dump "alias" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/pta-escape-2.c gcc/testsuite/gcc.dg/tree-ssa/pta-escape-2.c
index 8580382..2dc3678 100644
--- gcc/testsuite/gcc.dg/tree-ssa/pta-escape-2.c
+++ gcc/testsuite/gcc.dg/tree-ssa/pta-escape-2.c
@@ -34,5 +34,5 @@ int main()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" } } */
+/* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { cleanup-tree-dump "alias" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/pta-escape-3.c gcc/testsuite/gcc.dg/tree-ssa/pta-escape-3.c
index 5a121a0..31df220 100644
--- gcc/testsuite/gcc.dg/tree-ssa/pta-escape-3.c
+++ gcc/testsuite/gcc.dg/tree-ssa/pta-escape-3.c
@@ -38,5 +38,5 @@ int main()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" } } */
+/* { dg-final { scan-tree-dump "ESCAPED = { NULL ESCAPED NONLOCAL x }" "alias" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { cleanup-tree-dump "alias" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/slsr-1.c gcc/testsuite/gcc.dg/tree-ssa/slsr-1.c
index 38da179..e8c0ff0 100644
--- gcc/testsuite/gcc.dg/tree-ssa/slsr-1.c
+++ gcc/testsuite/gcc.dg/tree-ssa/slsr-1.c
@@ -14,7 +14,9 @@ f (int *p, unsigned int n)
     foo (*(p + 48 + n * 4));
 }
 
-/* { dg-final { scan-tree-dump-times "\\+ 128|\\, 128>" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times "\\+ 128|\\, 128>" 1 "optimized" { target { int32plus } } } } */
 /* { dg-final { scan-tree-dump-times "\\+ 64|\\, 64>" 1 "optimized" } } */
-/* { dg-final { scan-tree-dump-times "\\+ 192|\\, 192>" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times "\\+ 32|\\, 32>" 1 "optimized" { target { int16 } } } } */
+/* { dg-final { scan-tree-dump-times "\\+ 192|\\, 192>" 1 "optimized" { target { int32 } } } } */
+/* { dg-final { scan-tree-dump-times "\\+ 96|\\, 96>" 1 "optimized" { target { int16 } } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/slsr-2.c gcc/testsuite/gcc.dg/tree-ssa/slsr-2.c
index c6bb3e0..56697ff 100644
--- gcc/testsuite/gcc.dg/tree-ssa/slsr-2.c
+++ gcc/testsuite/gcc.dg/tree-ssa/slsr-2.c
@@ -11,6 +11,8 @@ f (int *p, int n)
   foo (*(p + 16 + n * 4));
 }
 
-/* { dg-final { scan-tree-dump-times "\\+ 144|\\, 144>" 1 "optimized" } } */
-/* { dg-final { scan-tree-dump-times "\\+ 96|\\, 96>" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times "\\+ 144|\\, 144>" 1 "optimized" { target { int32 } } } } */
+/* { dg-final { scan-tree-dump-times "\\+ 72|\\, 72>" 1 "optimized" { target { int16 } } } } */
+/* { dg-final { scan-tree-dump-times "\\+ 96|\\, 96>" 1 "optimized" { target { int32 } } } } */
+/* { dg-final { scan-tree-dump-times "\\+ 48|\\, 48>" 1 "optimized" { target { int16 } } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/slsr-27.c gcc/testsuite/gcc.dg/tree-ssa/slsr-27.c
index eb5734a..c664262 100644
--- gcc/testsuite/gcc.dg/tree-ssa/slsr-27.c
+++ gcc/testsuite/gcc.dg/tree-ssa/slsr-27.c
@@ -16,7 +16,8 @@ f (struct x *p, unsigned int n)
   foo (p->a[n], p->c[n], p->b[n]);
 }
 
-/* { dg-final { scan-tree-dump-times "\\* 4;" 1 "dom2" } } */
+/* { dg-final { scan-tree-dump-times "\\* 4;" 1 "dom2" { target { int32 } } } } */
+/* { dg-final { scan-tree-dump-times "\\* 2;" 1 "dom2" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "p_\\d\+\\(D\\) \\+ \[^\r\n\]*_\\d\+;" 1 "dom2" } } */
 /* { dg-final { scan-tree-dump-times "MEM\\\[\\(struct x \\*\\)\[^\r\n\]*_\\d\+" 3 "dom2" } } */
 /* { dg-final { cleanup-tree-dump "dom2" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/slsr-28.c gcc/testsuite/gcc.dg/tree-ssa/slsr-28.c
index 7e7c751..c4dbf54 100644
--- gcc/testsuite/gcc.dg/tree-ssa/slsr-28.c
+++ gcc/testsuite/gcc.dg/tree-ssa/slsr-28.c
@@ -20,7 +20,8 @@ f (struct x *p, unsigned int n)
     foo (p->b[n], p->a[n], p->c[n]);
 }
 
-/* { dg-final { scan-tree-dump-times "\\* 4;" 1 "dom2" } } */
+/* { dg-final { scan-tree-dump-times "\\* 4;" 1 "dom2" { target { int32 } } } } */
+/* { dg-final { scan-tree-dump-times "\\* 2;" 1 "dom2" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "p_\\d\+\\(D\\) \\+ \[^\r\n\]*_\\d\+" 1 "dom2" } } */
 /* { dg-final { scan-tree-dump-times "MEM\\\[\\(struct x \\*\\)\[^\r\n\]*_\\d\+" 9 "dom2" } } */
 /* { dg-final { cleanup-tree-dump "dom2" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/slsr-29.c gcc/testsuite/gcc.dg/tree-ssa/slsr-29.c
index 2a8fe0e..c8e7a5e 100644
--- gcc/testsuite/gcc.dg/tree-ssa/slsr-29.c
+++ gcc/testsuite/gcc.dg/tree-ssa/slsr-29.c
@@ -22,7 +22,8 @@ f (struct x *p, unsigned int n)
     }
 }
 
-/* { dg-final { scan-tree-dump-times "\\* 4;" 1 "dom2" } } */
+/* { dg-final { scan-tree-dump-times "\\* 4;" 1 "dom2" { target { int32 } } } } */
+/* { dg-final { scan-tree-dump-times "\\* 2;" 1 "dom2" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "p_\\d\+\\(D\\) \\+ \[^\r\n\]*_\\d\+" 1 "dom2" } } */
 /* { dg-final { scan-tree-dump-times "MEM\\\[\\(struct x \\*\\)\[^\r\n\]*_\\d\+" 9 "dom2" } } */
 /* { dg-final { cleanup-tree-dump "dom2" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/slsr-3.c gcc/testsuite/gcc.dg/tree-ssa/slsr-3.c
index 32edf2b..89d1d2e 100644
--- gcc/testsuite/gcc.dg/tree-ssa/slsr-3.c
+++ gcc/testsuite/gcc.dg/tree-ssa/slsr-3.c
@@ -15,8 +15,11 @@ foo (int a[], int b[], int i)
   return i;
 }
 
-/* { dg-final { scan-tree-dump-times "\\* 4" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times "\\* 4" 1 "optimized" { target { int32 } } } } */
+/* { dg-final { scan-tree-dump-times "\\* 2" 1 "optimized" { target { int16 } } } } */
+/* { dg-final { scan-tree-dump-times "\\+ 2|\\, 2>" 5 "optimized" { target { int16 } } } } */
 /* { dg-final { scan-tree-dump-times "\\+ 4|\\, 4>" 2 "optimized" } } */
-/* { dg-final { scan-tree-dump-times "\\+ 8|\\, 8>" 1 "optimized" } } */
-/* { dg-final { scan-tree-dump-times "\\+ 12|\\, 12>" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times "\\+ 8|\\, 8>" 1 "optimized" { target { int32plus } } } } */
+/* { dg-final { scan-tree-dump-times "\\+ 6|\\, 6>" 1 "optimized" { target { int16 } } } } */
+/* { dg-final { scan-tree-dump-times "\\+ 12|\\, 12>" 1 "optimized" { target { int32 } } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/sra-13.c gcc/testsuite/gcc.dg/tree-ssa/sra-13.c
index 12b77fe..d4aa47a 100644
--- gcc/testsuite/gcc.dg/tree-ssa/sra-13.c
+++ gcc/testsuite/gcc.dg/tree-ssa/sra-13.c
@@ -95,7 +95,7 @@ main (void)
   b = 0;
   gu1.b.l = 20000000;
   s = bar ();
-  if (s != 20000000)
+  if (s != (int)20000000)
     __builtin_abort ();
   if (gu2.b.l != 20000000)
     __builtin_abort ();
diff --git gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-23.c gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-23.c
index fb4af2d..8b95b0c 100644
--- gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-23.c
+++ gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-23.c
@@ -15,5 +15,6 @@ int foo (void)
   return *x;
 }
 
-/* { dg-final { scan-tree-dump "MEM\\\[\\\(int \\\*\\\)&a \\\+ 4B\\\]" "ccp1" } } */
+/* { dg-final { scan-tree-dump "MEM\\\[\\\(int \\\*\\\)&a \\\+ 2B\\\]" "ccp1" { target { int16 } } } } */
+/* { dg-final { scan-tree-dump "MEM\\\[\\\(int \\\*\\\)&a \\\+ 4B\\\]" "ccp1" { target { int32 } } } } */
 /* { dg-final { cleanup-tree-dump "ccp1" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-4.c gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-4.c
index 44b05f0..e97719f 100644
--- gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-4.c
+++ gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-4.c
@@ -61,7 +61,7 @@ bitmap_ior_and_compl (bitmap dst, const_bitmap a, const_bitmap b,
    zero.  */
 /* ARM Cortex-M0 defined LOGICAL_OP_NON_SHORT_CIRCUIT to false,
    so skip below test.  */
-/* { dg-final { scan-tree-dump-times "Threaded" 3 "dom1" { target { ! { mips*-*-* || { arm_cortex_m && arm_thumb1 } } } } } } */
+/* { dg-final { scan-tree-dump-times "Threaded" 3 "dom1" { target { ! { { mips*-*-* avr-*-* } || { arm_cortex_m && arm_thumb1 } } } } } } */
 /* MIPS defines LOGICAL_OP_NON_SHORT_CIRCUIT to 0, so we split both
    "a_elt || b_elt" and "b_elt && kill_elt" into two conditions each,
    rather than using "(var1 != 0) op (var2 != 0)".  Also, as on other targets,
@@ -81,6 +81,8 @@ bitmap_ior_and_compl (bitmap dst, const_bitmap a, const_bitmap b,
       -> "kill_elt->indx == b_elt->indx" in the second condition,
 	 skipping the known-true "b_elt && kill_elt" in the second
 	 condition.  */
-/* { dg-final { scan-tree-dump-times "Threaded" 6 "dom1" { target mips*-*-* } } } */
+/* For avr, BRANCH_COST is by default 0, so the default
+   LOGICAL_OP_NON_SHORT_CIRCUIT definition also computes as 0.  */
+/* { dg-final { scan-tree-dump-times "Threaded" 6 "dom1" { target mips*-*-* avr-*-* } } } */
 /* { dg-final { cleanup-tree-dump "dom1" } } */
 
diff --git gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-21.c gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-21.c
index e4c9772..40bb421 100644
--- gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-21.c
+++ gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-21.c
@@ -11,5 +11,5 @@ NumSift (long *array, unsigned long k)
 
 /* There should be only two loads left.  */
 
-/* { dg-final { scan-tree-dump-times "= \\\*\[^\n;\]*;" 2 "pre" } } */
+/* { dg-final { scan-tree-dump-times "= \\\*\[^\n;\]*;" 2 "pre" { xfail { ! size32plus } } } } */ /* xfail: PR tree-optimization/58169 */
 /* { dg-final { cleanup-tree-dump "pre" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-30.c gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-30.c
index 68a7a7f..91e0e89 100644
--- gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-30.c
+++ gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-30.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target int32 } */
 /* { dg-options "-O2 -fdump-tree-pre-details" } */
 
 int f;
diff --git gcc/testsuite/gcc.dg/tree-ssa/unreachable.c gcc/testsuite/gcc.dg/tree-ssa/unreachable.c
index 279a277..c4caeaf 100644
--- gcc/testsuite/gcc.dg/tree-ssa/unreachable.c
+++ gcc/testsuite/gcc.dg/tree-ssa/unreachable.c
@@ -11,5 +11,5 @@ main()
     return 1;
   return 0;
 }
-/* { dg-final { scan-tree-dump-not "bad_boy" "optimized"} } */
+/* { dg-final { scan-tree-dump-not "bad_boy" "optimized" { target { ! keeps_null_pointer_checks } } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/vector-4.c gcc/testsuite/gcc.dg/tree-ssa/vector-4.c
index 10aebc4..018b8cb 100644
--- gcc/testsuite/gcc.dg/tree-ssa/vector-4.c
+++ gcc/testsuite/gcc.dg/tree-ssa/vector-4.c
@@ -1,7 +1,8 @@
 /* { dg-do compile } */
 /* { dg-options "-w -O1 -fdump-tree-gimple" } */
 
-typedef int v4si __attribute__ ((vector_size (16)));
+typedef int SItype __attribute__ ((mode (SI)));
+typedef SItype v4si __attribute__ ((vector_size (16)));
 
 v4si vs (v4si a, v4si b)
 {
diff --git gcc/testsuite/gcc.dg/tree-ssa/vrp55.c gcc/testsuite/gcc.dg/tree-ssa/vrp55.c
index 7adfe62..7a3e726 100644
--- gcc/testsuite/gcc.dg/tree-ssa/vrp55.c
+++ gcc/testsuite/gcc.dg/tree-ssa/vrp55.c
@@ -9,6 +9,7 @@ fu (char *p, int x)
     arf ();
 }
 
-/* { dg-final { scan-tree-dump-times "Threaded jump" 1 "vrp1" } } */
+/* { dg-final { scan-tree-dump-times "Threaded jump" 1 "vrp1" { target { ! keeps_null_pointer_checks } } } } */
+/* { dg-final { scan-tree-dump-times "Threaded jump" 0 "vrp1" { target {   keeps_null_pointer_checks } } } } */
 /* { dg-final { cleanup-tree-dump "vrp1" } } */
 
diff --git gcc/testsuite/gcc.dg/tree-ssa/vrp58.c gcc/testsuite/gcc.dg/tree-ssa/vrp58.c
index 7da3896..aa10af2 100644
--- gcc/testsuite/gcc.dg/tree-ssa/vrp58.c
+++ gcc/testsuite/gcc.dg/tree-ssa/vrp58.c
@@ -8,5 +8,6 @@ foo (long long a, signed char b, signed char c)
   return a + (short)bc;
 }
 
-/* { dg-final { scan-tree-dump "Folded into" "vrp1" } } */
+/* { dg-final { scan-tree-dump "Folded into" "vrp1" { target int32plus } } } */
+/* { dg-final { scan-tree-dump "Folding statement: _\[0-9\]\* = \\(long long int\\) bc_\[0-9\]\*;" "vrp1" { target int16 } } } */
 /* { dg-final { cleanup-tree-dump "vrp1" } } */
diff --git gcc/testsuite/gcc.dg/tree-ssa/vrp66-int16-sw.c gcc/testsuite/gcc.dg/tree-ssa/vrp66-int16-sw.c
new file mode 100644
index 0000000..b194d23
--- /dev/null
+++ gcc/testsuite/gcc.dg/tree-ssa/vrp66-int16-sw.c
@@ -0,0 +1,914 @@
+/* PR tree-optimization/52267 */
+/* { dg-do run { target { int16 } } } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+
+#define BITSM1 (sizeof (int) * __CHAR_BIT__ - 1)
+#define BITSH ((sizeof (int) - sizeof (short)) * __CHAR_BIT__)
+
+void
+f1 (unsigned int s)
+{
+  if ((s & (7U << (BITSM1 - 2))) != 0)
+    {
+      if (s == (0xc000U << BITSH) - 1 || s == (0xf000U << BITSH) - 1
+	  || s == (0x9000U << BITSH) - 1 || s == (0xa031U << BITSH) - 1
+	  || s == (0xbfbfU << BITSH) || s == (0xc000U << BITSH)
+	  || s == (0xf000U << BITSH) || s == (0x9000U << BITSH)
+	  || s == (0xc000U << BITSH) + 1 || s == -1U || s == -15U
+	  || s == 0x3cbf || s == 0x3cc0
+	  || s == -15550U || s == -15552U || s == (0x7000 << BITSH) - 1
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == 1U + __INT_MAX__ || s == -32U
+	  || s == (3 << (BITSM1 - 2)) + 2 || s == -5U || s == -63U
+	  || s == -64U || s == -65U || s == 6U + __INT_MAX__ || s == -8189U
+	  || s == -8191U || s == -8192U || s == -8193U || s == -8250U
+	  || s == -8255U || s == -8256U || s == -8257U || s == __INT_MAX__
+	  || s == __INT_MAX__ + 9U)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3f || s == 1
+	  || s == (1 << (BITSM1 - 2)) - 1 || s == 2 || s == 24 || s == 5)
+	return;
+    }
+  abort ();
+}
+
+void
+f2 (int s)
+{
+  if ((s & (7U << (BITSM1 - 2))) == 0)
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3f || s == 1
+	  || s == (1 << (BITSM1 - 2)) - 1 || s == 2 || s == 24 || s == 5)
+	return;
+    }
+  else
+    {
+      if (s == (-0x4000 << BITSH) - 1 || s == (-0x1000 << BITSH) - 1
+	  || s == (-0x7000 << BITSH) - 1 || s == (-0x5fcf << BITSH) - 1
+	  || s == (-0x4041 << BITSH) || s == (-0x4000 << BITSH)
+	  || s == (-0x1000 << BITSH) || s == (-0x7000 << BITSH)
+	  || s == (-0x4000 << BITSH) + 1 || s == -1 || s == -15 || s == -15550
+	  || s == 0x3cbf || s == 0x3cc0
+	  || s == -15552 || s == (0x7000 << BITSH) - 1
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == -__INT_MAX__ - 1 || s == -32 || s == (3 << (BITSM1 - 2)) + 2
+	  || s == -5 || s == -63 || s == -64 || s == -65
+	  || s == -__INT_MAX__ + 4 || s == -8189 || s == -8191 || s == -8192
+	  || s == -8193 || s == -8250 || s == -8255 || s == -8256
+	  || s == -8257 || s == __INT_MAX__ || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f3 (unsigned int s)
+{
+  if ((s & 0x3cc0) == 0)
+    {
+      if (s == 0 || s == 0x20 || s == 0x3f
+	  || s == (0xc000U << BITSH)
+	  || s == (0xc000U << BITSH) + 1 || s == 1
+	  || s == 1U + __INT_MAX__ || s == 2 || s == 24
+	  || s == 5 || s == 6U + __INT_MAX__
+	  || s == __INT_MAX__ + 9U)
+	return;
+    }
+  else
+    {
+      if (s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == (0xbfbfU << BITSH) || s == (0xf000U << BITSH)
+	  || s == (0x9000U << BITSH)
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == (3 << (BITSM1 - 2)) + 2
+	  || s == 0x3cbf || s == 0x3cc0 || s == (0xc000U << BITSH) - 1
+	  || s == (0xf000U << BITSH) - 1 || s == (0x9000U << BITSH) - 1
+	  || s == (0xa031U << BITSH) - 1 || s == -1U || s == -15U
+	  || s == -15550U || s == -15552U || s == (0x7000 << BITSH) - 1
+	  || s == (1 << (BITSM1 - 2)) - 1 || s == -32U || s == -5U
+	  || s == -63U || s == -64U || s == -65U || s == -8189U || s == -8191U
+	  || s == -8192U || s == -8193U || s == -8250U || s == -8255U
+	  || s == -8256U || s == -8257U || s == __INT_MAX__)
+	return;
+    }
+  abort ();
+}
+
+void
+f4 (int s)
+{
+  if ((s & 0x3cc0) == 0)
+    {
+      if (s == 0 || s == 0x20 || s == 0x3f
+	  || s == (-0x4000 << BITSH)
+	  || s == (-0x4000 << BITSH) + 1 || s == 1
+	  || s == -__INT_MAX__ - 1 || s == 2 || s == 24
+	  || s == 5 || s == -__INT_MAX__ + 4
+	  || s == -__INT_MAX__ + 7)
+	return;
+    }
+  else
+    {
+      if (s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == (-0x4041 << BITSH) || s == (-0x1000 << BITSH)
+	  || s == (-0x7000 << BITSH)
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == (3 << (BITSM1 - 2)) + 2
+	  || s == 0x3cbf || s == 0x3cc0 || s == (-0x4000 << BITSH) - 1
+	  || s == (-0x1000 << BITSH) - 1 || s == (-0x7000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1 || s == -1 || s == -15 || s == -15550
+	  || s == -15552 || s == (0x7000 << BITSH) - 1
+	  || s == (1 << (BITSM1 - 2)) - 1 || s == -32 || s == -5 || s == -63
+	  || s == -64 || s == -65 || s == -8189 || s == -8191 || s == -8192
+	  || s == -8193 || s == -8250 || s == -8255 || s == -8256
+	  || s == -8257 || s == __INT_MAX__)
+	return;
+    }
+  abort ();
+}
+
+void
+f5 (int s)
+{
+  if ((s & 0x3cc0U) == 0)
+    {
+      if (s == 0 || s == 0x20 || s == 0x3f
+	  || s == (-0x4000 << BITSH)
+	  || s == (-0x4000 << BITSH) + 1 || s == 1
+	  || s == -__INT_MAX__ - 1 || s == 2 || s == 24
+	  || s == 5 || s == -__INT_MAX__ + 4
+	  || s == -__INT_MAX__ + 7)
+	return;
+    }
+  else
+    {
+      if (s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == (-0x4041 << BITSH) || s == (-0x1000 << BITSH)
+	  || s == (-0x7000 << BITSH)
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == (3 << (BITSM1 - 2)) + 2
+	  || s == 0x3cbf || s == 0x3cc0 || s == (-0x4000 << BITSH) - 1
+	  || s == (-0x1000 << BITSH) - 1 || s == (-0x7000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1 || s == -1 || s == -15 || s == -15550
+	  || s == -15552 || s == (0x7000 << BITSH) - 1
+	  || s == (1 << (BITSM1 - 2)) - 1 || s == -32 || s == -5 || s == -63
+	  || s == -64 || s == -65 || s == -8189 || s == -8191 || s == -8192
+	  || s == -8193 || s == -8250 || s == -8255 || s == -8256
+	  || s == -8257 || s == __INT_MAX__)
+	return;
+    }
+  abort ();
+}
+
+void
+f6 (unsigned int s)
+{
+  if ((s & 0x3cc0) == 0x3cc0)
+    {
+      if (s == 0x3cc0 || s == (0xc000U << BITSH) - 1
+	  || s == -1U || s == -15U
+	  || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -32U || s == -5U || s == -63U || s == -64U
+	  || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == (0xf000U << BITSH) - 1 || s == (0x9000U << BITSH) - 1
+	  || s == (0xa031U << BITSH) - 1
+	  || s == (0x7000 << BITSH) - 1
+	  || s == 0x20 || s == 0x3cbf || s == 0x3f || s == (0xbfbfU << BITSH)
+	  || s == (0xc000U << BITSH) || s == (0xf000U << BITSH)
+	  || s == (0x9000U << BITSH) || s == (0xc000U << BITSH) + 1 || s == 1
+	  || s == -15550U || s == -15552U || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == 1U + __INT_MAX__ || s == 2
+	  || s == 24 || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -65U
+	  || s == 6U + __INT_MAX__ || s == -8189U || s == -8191U
+	  || s == -8192U || s == -8193U || s == -8250U || s == -8255U
+	  || s == -8256U || s == -8257U || s == __INT_MAX__ + 9U)
+	return;
+    }
+  abort ();
+}
+
+void
+f7 (int s)
+{
+  if ((s & 0x3cc0) == 0x3cc0)
+    {
+      if (s == 0x3cc0 || s == (-0x4000 << BITSH) - 1
+	  || s == -1 || s == -15
+	  || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -32 || s == -5 || s == -63 || s == -64 || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == (-0x1000 << BITSH) - 1 || s == (-0x7000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1
+	  || s == (0x7000 << BITSH) - 1
+	  || s == 0x20 || s == 0x3cbf || s == 0x3f || s == (-0x4041 << BITSH)
+	  || s == (-0x4000 << BITSH) || s == (-0x1000 << BITSH)
+	  || s == (-0x7000 << BITSH) || s == (-0x4000 << BITSH) + 1 || s == 1
+	  || s == -15550 || s == -15552 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == -__INT_MAX__ - 1 || s == 2
+	  || s == 24 || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -65
+	  || s == -__INT_MAX__ + 4 || s == -8189 || s == -8191 || s == -8192
+	  || s == -8193 || s == -8250 || s == -8255 || s == -8256
+	  || s == -8257 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f8 (int s)
+{
+  if ((s & 0x3cc0U) == 0x3cc0)
+    {
+      if (s == 0x3cc0 || s == (-0x4000 << BITSH) - 1
+	  || s == -1 || s == -15
+	  || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -32 || s == -5 || s == -63 || s == -64 || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == (-0x1000 << BITSH) - 1 || s == (-0x7000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1
+	  || s == (0x7000 << BITSH) - 1
+	  || s == 0x20 || s == 0x3cbf || s == 0x3f || s == (-0x4041 << BITSH)
+	  || s == (-0x4000 << BITSH) || s == (-0x1000 << BITSH)
+	  || s == (-0x7000 << BITSH) || s == (-0x4000 << BITSH) + 1 || s == 1
+	  || s == -15550 || s == -15552 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == -__INT_MAX__ - 1 || s == 2
+	  || s == 24 || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -65
+	  || s == -__INT_MAX__ + 4 || s == -8189 || s == -8191 || s == -8192
+	  || s == -8193 || s == -8250 || s == -8255 || s == -8256
+	  || s == -8257 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f9 (unsigned int s)
+{
+  if ((s & 0x3cc0) >= 0x1cc0)
+    {
+      if (s == 0x1cc0 || s == 0x1fff || s == 0x2000 || s == 0x3cbf
+	  || s == 0x3cc0 || s == (0xc000U << BITSH) - 1
+	  || s == (0xf000U << BITSH) - 1
+	  || s == (0xbfbfU << BITSH) || s == (0xf000U << BITSH)
+	  || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == (3 << (BITSM1 - 2)) + 2
+	  || s == (0xa031U << BITSH) - 1 || s == -1U || s == -15U
+	  || s == (0x7000 << BITSH) - 1 || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -32U || s == -5U || s == -63U || s == -64U || s == -65U
+	  || s == -8189U || s == -8191U || s == -8192U || s == -8193U
+	  || s == -8250U || s == -8255U || s == -8256U || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x20 || s == 0x3f
+	  || s == (0x9000U << BITSH) - 1 || s == (0xc000U << BITSH)
+	  || s == (0x9000U << BITSH)
+	  || s == (0xc000U << BITSH) + 1 || s == 1 || s == -15550U
+	  || s == -15552U
+	  || s == 1U + __INT_MAX__ || s == 2
+	  || s == 24 || s == 5
+	  || s == 6U + __INT_MAX__ || s == -8257U || s == __INT_MAX__ + 9U)
+	return;
+    }
+  abort ();
+}
+
+void
+f10 (unsigned int s)
+{
+  if ((s & 0x3cc0) > 0x1cc0)
+    {
+      if (s == 0x2000 || s == 0x3cbf || s == 0x3cc0
+	  || s == (0xc000U << BITSH) - 1 || s == (0xf000U << BITSH) - 1
+	  || s == (0xbfbfU << BITSH) || s == (0xa031U << BITSH) - 1
+	  || s == (0xf000U << BITSH)
+	  || s == -1U || s == -15U || s == (0x7000 << BITSH) - 1
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == -32U || s == (3 << (BITSM1 - 2)) + 2 || s == -5U
+	  || s == -63U || s == -64U || s == -65U || s == -8189U || s == -8191U
+	  || s == -8192U || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x20
+	  || s == 0x3f || s == (0x9000U << BITSH) - 1
+	  || s == (0xc000U << BITSH) || s == (0x9000U << BITSH)
+	  || s == (0xc000U << BITSH) + 1 || s == 1 || s == -15550U
+	  || s == -15552U || s == (1 << (BITSM1 - 2)) - 1
+	  || s == 1U + __INT_MAX__ || s == 2
+	  || s == 24 || s == 5
+	  || s == 6U + __INT_MAX__ || s == -8193U || s == -8250U
+	  || s == -8255U || s == -8256U || s == -8257U
+	  || s == __INT_MAX__ + 9U)
+	return;
+    }
+  abort ();
+}
+
+void
+f11 (int s)
+{
+  if ((s & 0x3cc0) >= 0x1cc0)
+    {
+      if (s == 0x1cc0 || s == 0x1fff || s == 0x2000 || s == 0x3cbf
+	  || s == 0x3cc0 || s == (-0x4000 << BITSH) - 1
+	  || s == (-0x1000 << BITSH) - 1
+	  || s == (-0x4041 << BITSH)
+	  || s == (-0x1000 << BITSH)
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == (3 << (BITSM1 - 2)) + 2
+	  || s == (-0x5fcf << BITSH) - 1 || s == -1 || s == -15
+	  || s == (0x7000 << BITSH) - 1 || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -32 || s == -5 || s == -63 || s == -64 || s == -65
+	  || s == -8189 || s == -8191 || s == -8192 || s == -8193
+	  || s == -8250 || s == -8255 || s == -8256 || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x20 || s == 0x3f
+	  || s == (-0x7000 << BITSH) - 1 || s == (-0x4000 << BITSH)
+	  || s == (-0x7000 << BITSH)
+	  || s == (-0x4000 << BITSH) + 1 || s == 1 || s == -15550
+	  || s == -15552
+	  || s == -__INT_MAX__ - 1 || s == 2 || s == 24
+	  || s == 5 || s == -__INT_MAX__ + 4
+	  || s == -8257 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f12 (int s)
+{
+  if ((s & 0x3cc0) > 0x1cc0)
+    {
+      if (s == 0x2000 || s == 0x3cbf || s == 0x3cc0
+	  || s == (-0x4000 << BITSH) - 1 || s == (-0x1000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1
+	  || s == (-0x4041 << BITSH)
+	  || s == (-0x1000 << BITSH)
+	  || s == -1 || s == -15 || s == (0x7000 << BITSH) - 1
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == (3 << (BITSM1 - 2)) + 2
+	  || s == -32 || s == -5 || s == -63
+	  || s == -64 || s == -65 || s == -8189 || s == -8191 || s == -8192
+	  || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x20
+	  || s == 0x3f || s == (-0x7000 << BITSH) - 1
+	  || s == (-0x4000 << BITSH) || s == (-0x7000 << BITSH)
+	  || s == (-0x4000 << BITSH) + 1 || s == 1 || s == -15550
+	  || s == -15552 || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -__INT_MAX__ - 1 || s == 2 || s == 24
+	  || s == 5 || s == -__INT_MAX__ + 4
+	  || s == -8193 || s == -8250 || s == -8255 || s == -8256
+	  || s == -8257 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f13 (unsigned int s)
+{
+  if ((s & (0xe071U << BITSH)) > (0xb030U << BITSH))
+    {
+      if (s == (0xf000U << BITSH) - 1 || s == (0xc000U << BITSH)
+	  || s == (0xf000U << BITSH) || s == (0xc000U << BITSH) + 1
+	  || s == -1U || s == -15U || s == -15550U || s == -15552U
+	  || s == -32U || s == -5U || s == -63U || s == -64U || s == -65U
+	  || s == -8189U || s == -8191U || s == -8192U || s == -8193U
+	  || s == -8250U || s == -8255U || s == -8256U || s == -8257U)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (0xc000U << BITSH) - 1 || s == (0x9000U << BITSH) - 1
+	  || s == (0xa031U << BITSH) - 1 || s == (0xbfbfU << BITSH)
+	  || s == (0x9000U << BITSH) || s == 1 || s == (0x7000 << BITSH) - 1
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == (1 << (BITSM1 - 2)) - 1 || s == 1U + __INT_MAX__ || s == 2
+	  || s == 24 || s == (3 << (BITSM1 - 2)) + 2 || s == 5
+	  || s == 6U + __INT_MAX__ || s == __INT_MAX__
+	  || s == __INT_MAX__ + 9U)
+	return;
+    }
+  abort ();
+}
+
+void
+f14 (unsigned int s)
+{
+  if ((s & (0xe071U << BITSH)) > (0xa030U << BITSH))
+    {
+      if (s == (0xc000U << BITSH) - 1 || s == (0xf000U << BITSH) - 1
+	  || s == (0xbfbfU << BITSH) || s == (0xc000U << BITSH)
+	  || s == (0xf000U << BITSH) || s == (0xc000U << BITSH) + 1
+	  || s == -1U || s == -15U || s == -15550U || s == -15552U
+	  || s == -32U || s == -5U || s == -63U || s == -64U || s == -65U
+	  || s == -8189U || s == -8191U || s == -8192U || s == -8193U
+	  || s == -8250U || s == -8255U || s == -8256U || s == -8257U)
+	return;
+    }
+  else
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (0x9000U << BITSH) - 1 || s == (0xa031U << BITSH) - 1
+	  || s == (0x9000U << BITSH) || s == 1 || s == (0x7000 << BITSH) - 1
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == (1 << (BITSM1 - 2)) - 1 || s == 1U + __INT_MAX__ || s == 2
+	  || s == 24 || s == (3 << (BITSM1 - 2)) + 2 || s == 5
+	  || s == 6U + __INT_MAX__ || s == __INT_MAX__
+	  || s == __INT_MAX__ + 9U)
+	return;
+    }
+  abort ();
+}
+
+void
+f15 (int s)
+{
+  if ((s & ((-0x1f8f) << BITSH)) > ((-0x4fd0) << BITSH))
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (-0x1000 << BITSH) - 1 || s == (-0x4000 << BITSH)
+	  || s == (-0x1000 << BITSH) || s == (-0x4000 << BITSH) + 1 || s == 1
+	  || s == -1 || s == -15 || s == -15550 || s == -15552
+	  || s == (0x7000 << BITSH) - 1 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == 2 || s == 24 || s == -32 || s == (3 << (BITSM1 - 2)) + 2
+	  || s == 5 || s == -5 || s == -63 || s == -64 || s == -65
+	  || s == -8189 || s == -8191 || s == -8192 || s == -8193
+	  || s == -8250 || s == -8255 || s == -8256 || s == -8257
+	  || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == (-0x4000 << BITSH) - 1 || s == (-0x7000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1 || s == (-0x4041 << BITSH)
+	  || s == (-0x7000 << BITSH) || s == -__INT_MAX__ - 1
+	  || s == -__INT_MAX__ + 4 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f16 (int s)
+{
+  if ((s & ((-0x1f8f) << BITSH)) >= ((-0x4fd0) << BITSH))
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (-0x1000 << BITSH) - 1 || s == (-0x4000 << BITSH)
+	  || s == (-0x1000 << BITSH) || s == (-0x4000 << BITSH) + 1 || s == 1
+	  || s == -1 || s == -15 || s == -15550 || s == -15552
+	  || s == (0x7000 << BITSH) - 1 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == 2 || s == 24 || s == -32 || s == (3 << (BITSM1 - 2)) + 2
+	  || s == 5 || s == -5 || s == -63 || s == -64 || s == -65
+	  || s == -8189 || s == -8191 || s == -8192 || s == -8193
+	  || s == -8250 || s == -8255 || s == -8256 || s == -8257
+	  || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == (-0x4000 << BITSH) - 1 || s == (-0x7000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1 || s == (-0x4041 << BITSH)
+	  || s == (-0x7000 << BITSH) || s == -__INT_MAX__ - 1
+	  || s == -__INT_MAX__ + 4 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f17 (int s)
+{
+  if ((s & ((-0x4000 << BITSH) | 1)) != -__INT_MAX__ - 1)
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (-0x4000 << BITSH) - 1 || s == (-0x1000 << BITSH) - 1
+	  || s == (-0x7000 << BITSH) - 1 || s == (-0x4041 << BITSH)
+	  || s == (-0x4000 << BITSH) || s == (-0x1000 << BITSH)
+	  || s == (-0x4000 << BITSH) + 1 || s == 1 || s == -1 || s == -15
+	  || s == -15550 || s == -15552 || s == (0x7000 << BITSH) - 1
+	  || s == (0x7000 << BITSH) || s == (1 << (BITSM1 - 2))
+	  || s == (1 << (BITSM1 - 2)) - 1 || s == 2 || s == 24 || s == -32
+	  || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -5 || s == -63
+	  || s == -64 || s == -65 || s == -__INT_MAX__ + 4 || s == -8189
+	  || s == -8191 || s == -8192 || s == -8193 || s == -8250
+	  || s == -8255 || s == -8256 || s == -8257 || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == (-0x5fcf << BITSH) - 1 || s == (-0x7000 << BITSH)
+	  || s == -__INT_MAX__ - 1 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f18 (int s)
+{
+  if ((s & ((-0x4000 << BITSH) | 1)) != ((-0x4000 << BITSH) | 1))
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (-0x4000 << BITSH) - 1 || s == (-0x7000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1 || s == (-0x4041 << BITSH)
+	  || s == (-0x4000 << BITSH) || s == (-0x1000 << BITSH)
+	  || s == (-0x7000 << BITSH) || s == 1 || s == -15550 || s == -15552
+	  || s == (0x7000 << BITSH) - 1 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -__INT_MAX__ - 1 || s == 2 || s == 24 || s == -32
+	  || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -64
+	  || s == -__INT_MAX__ + 4 || s == -8192 || s == -8250 || s == -8256
+	  || s == __INT_MAX__ || s == -__INT_MAX__ + 7)
+	return;
+    }
+  else
+    {
+      if (s == (-0x1000 << BITSH) - 1 || s == (-0x4000 << BITSH) + 1
+	  || s == -1 || s == -15 || s == -5 || s == -63 || s == -65
+	  || s == -8189 || s == -8191 || s == -8193 || s == -8255
+	  || s == -8257)
+	return;
+    }
+  abort ();
+}
+
+void
+f19 (int s)
+{
+  if ((s & ((-0x4000 << BITSH) | 1)) != ((0x4000 << BITSH) | 1))
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (-0x4000 << BITSH) - 1 || s == (-0x1000 << BITSH) - 1
+	  || s == (-0x7000 << BITSH) - 1 || s == (-0x5fcf << BITSH) - 1
+	  || s == (-0x4041 << BITSH) || s == (-0x4000 << BITSH)
+	  || s == (-0x1000 << BITSH) || s == (-0x7000 << BITSH)
+	  || s == (-0x4000 << BITSH) + 1 || s == 1 || s == -1 || s == -15
+	  || s == -15550 || s == -15552 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -__INT_MAX__ - 1 || s == 2 || s == 24 || s == -32
+	  || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -5 || s == -63
+	  || s == -64 || s == -65 || s == -__INT_MAX__ + 4 || s == -8189
+	  || s == -8191 || s == -8192 || s == -8193 || s == -8250
+	  || s == -8255 || s == -8256 || s == -8257 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  else
+    {
+      if (s == (0x7000 << BITSH) - 1 || s == __INT_MAX__)
+	return;
+    }
+  abort ();
+}
+
+void
+f20 (int s)
+{
+  if ((s & (-0x1000 << BITSH)) != -__INT_MAX__ - 1)
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (-0x4000 << BITSH) - 1 || s == (-0x1000 << BITSH) - 1
+	  || s == (-0x5fcf << BITSH) - 1 || s == (-0x4041 << BITSH)
+	  || s == (-0x4000 << BITSH) || s == (-0x1000 << BITSH)
+	  || s == (-0x7000 << BITSH) || s == (-0x4000 << BITSH) + 1 || s == 1
+	  || s == -1 || s == -15 || s == -15550 || s == -15552
+	  || s == (0x7000 << BITSH) - 1 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == 2 || s == 24 || s == -32 || s == (3 << (BITSM1 - 2)) + 2
+	  || s == 5 || s == -5 || s == -63 || s == -64 || s == -65
+	  || s == -8189 || s == -8191 || s == -8192 || s == -8193
+	  || s == -8250 || s == -8255 || s == -8256 || s == -8257
+	  || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == (-0x7000 << BITSH) - 1 || s == -__INT_MAX__ - 1
+	  || s == -__INT_MAX__ + 4 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  abort ();
+}
+
+void
+f21 (int s)
+{
+  if ((s & (-0x1000 << BITSH)) != (-0x1000 << BITSH))
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (-0x4000 << BITSH) - 1 || s == (-0x1000 << BITSH) - 1
+	  || s == (-0x7000 << BITSH) - 1 || s == (-0x5fcf << BITSH) - 1
+	  || s == (-0x4041 << BITSH) || s == (-0x4000 << BITSH)
+	  || s == (-0x7000 << BITSH) || s == (-0x4000 << BITSH) + 1 || s == 1
+	  || s == -15550 || s == -15552
+	  || s == (0x7000 << BITSH) - 1 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -__INT_MAX__ - 1 || s == 2 || s == 24
+	  || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -__INT_MAX__ + 4
+	  || s == -8189 || s == -8191 || s == -8192 || s == -8193
+	  || s == -8250 || s == -8255 || s == -8256 || s == -8257
+	  || s == __INT_MAX__ || s == -__INT_MAX__ + 7)
+	return;
+    }
+  else
+    {
+      if (s == (-0x1000 << BITSH) || s == -1 || s == -15
+	  || s == -32 || s == -5 || s == -63 || s == -64
+	  || s == -65)
+	return;
+    }
+  abort ();
+}
+
+void
+f22 (int s)
+{
+  if ((s & (-0x1000 << BITSH)) != (0x7000 << BITSH))
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (-0x4000 << BITSH) - 1 || s == (-0x1000 << BITSH) - 1
+	  || s == (-0x7000 << BITSH) - 1 || s == (-0x5fcf << BITSH) - 1
+	  || s == (-0x4041 << BITSH) || s == (-0x4000 << BITSH)
+	  || s == (-0x1000 << BITSH) || s == (-0x7000 << BITSH)
+	  || s == (-0x4000 << BITSH) + 1 || s == 1 || s == -1 || s == -15
+	  || s == -15550 || s == -15552 || s == (0x7000 << BITSH) - 1
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == -__INT_MAX__ - 1 || s == 2 || s == 24 || s == -32
+	  || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -5 || s == -63
+	  || s == -64 || s == -65 || s == -__INT_MAX__ + 4 || s == -8189
+	  || s == -8191 || s == -8192 || s == -8193 || s == -8250
+	  || s == -8255 || s == -8256 || s == -8257 || s == -__INT_MAX__ + 7)
+	return;
+    }
+  else
+    {
+      if (s == (0x7000 << BITSH) || s == __INT_MAX__)
+	return;
+    }
+  abort ();
+}
+
+void
+f23 (unsigned int s)
+{
+  if ((s & (0xf000U << BITSH)) != (0x7000 << BITSH))
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (0xc000U << BITSH) - 1 || s == (0xf000U << BITSH) - 1
+	  || s == (0x9000U << BITSH) - 1 || s == (0xa031U << BITSH) - 1
+	  || s == (0xbfbfU << BITSH) || s == (0xc000U << BITSH)
+	  || s == (0xf000U << BITSH) || s == (0x9000U << BITSH)
+	  || s == (0xc000U << BITSH) + 1 || s == 1 || s == -1U || s == -15U
+	  || s == -15550U || s == -15552U || s == (0x7000 << BITSH) - 1
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == 1U + __INT_MAX__ || s == 2 || s == 24 || s == -32U
+	  || s == (3 << (BITSM1 - 2)) + 2 || s == 5 || s == -5U || s == -63U
+	  || s == -64U || s == -65U || s == 6U + __INT_MAX__ || s == -8189U
+	  || s == -8191U || s == -8192U || s == -8193U || s == -8250U
+	  || s == -8255U || s == -8256U || s == -8257U
+	  || s == __INT_MAX__ + 9U)
+	return;
+    }
+  else
+    {
+      if (s == (0x7000 << BITSH) || s == __INT_MAX__)
+	return;
+    }
+  abort ();
+}
+
+void
+f24 (unsigned int s)
+{
+  if ((s & (0xf000U << BITSH)) != (0x8000U << BITSH))
+    {
+      if (s == 0 || s == 0x1cbf || s == 0x1cc0 || s == 0x1fff || s == 0x2000
+	  || s == 0x20 || s == 0x3cbf || s == 0x3cc0 || s == 0x3f
+	  || s == (0xc000U << BITSH) - 1 || s == (0xf000U << BITSH) - 1
+	  || s == (0xa031U << BITSH) - 1 || s == (0xbfbfU << BITSH)
+	  || s == (0xc000U << BITSH) || s == (0xf000U << BITSH)
+	  || s == (0x9000U << BITSH) || s == (0xc000U << BITSH) + 1 || s == 1
+	  || s == -1U || s == -15U || s == -15550U || s == -15552U
+	  || s == (0x7000 << BITSH) - 1 || s == (0x7000 << BITSH)
+	  || s == (1 << (BITSM1 - 2)) || s == (1 << (BITSM1 - 2)) - 1
+	  || s == 2 || s == 24 || s == -32U || s == (3 << (BITSM1 - 2)) + 2
+	  || s == 5 || s == -5U || s == -63U || s == -64U || s == -65U
+	  || s == -8189U || s == -8191U || s == -8192U || s == -8193U
+	  || s == -8250U || s == -8255U || s == -8256U || s == -8257U
+	  || s == __INT_MAX__)
+	return;
+    }
+  else
+    {
+      if (s == (0x9000U << BITSH) - 1 || s == 1U + __INT_MAX__
+	  || s == 6U + __INT_MAX__ || s == __INT_MAX__ + 9U)
+	return;
+    }
+  abort ();
+}
+
+/* Make this easier to run on microcontroller architectures by using a switch
+   statements instead of arrays.
+   We still don't want the compiler to constant-propagate the array contents,
+   so use an asm in each accessor function with to hide what's going on.  */
+
+int
+svals (int i)
+{
+  asm ("" : "=g" (i) : "0" (i));
+  switch (i)
+    {
+    case  0: return 0;
+    case  1: return 0x1cbf;
+    case  2: return 0x1cc0;
+    case  3: return 0x1fff;
+    case  4: return 0x2000;
+    case  5: return 0x20;
+    case  6: return 0x3cbf;
+    case  7: return 0x3cc0;
+    case  8: return 0x3f;
+    case  9: return (-0x4000 << BITSH) - 1;
+    case 10: return (-0x1000 << BITSH) - 1;
+    case 11: return (-0x7000 << BITSH) - 1;
+    case 12: return (-0x5fcf << BITSH) - 1;
+    case 13: return (-0x4041 << BITSH);
+    case 14: return (-0x4000 << BITSH);
+    case 15: return (-0x1000 << BITSH);
+    case 16: return (-0x7000 << BITSH);
+    case 17: return (-0x4000 << BITSH) + 1;
+    case 18: return 1;
+    case 19: return -1;
+    case 20: return -15;
+    case 21: return -15550;
+    case 22: return -15552;
+    case 23: return (0x7000 << BITSH) - 1;
+    case 24: return (0x7000 << BITSH);
+    case 25: return (1 << (BITSM1 - 2));
+    case 26: return (1 << (BITSM1 - 2)) - 1;
+    case 27: return -__INT_MAX__ - 1;
+    case 28: return 2;
+    case 29: return 24;
+    case 30: return -32;
+    case 31: return (3 << (BITSM1 - 2)) + 2;
+    case 32: return 5;
+    case 33: return -5;
+    case 34: return -63;
+    case 35: return -64;
+    case 36: return -65;
+    case 37: return -__INT_MAX__ + 4;
+    case 38: return -8189;
+    case 39: return -8191;
+    case 40: return -8192;
+    case 41: return -8193;
+    case 42: return -8250;
+    case 43: return -8255;
+    case 44: return -8256;
+    case 45: return -8257;
+    case 46: return __INT_MAX__;
+    case 47: return -__INT_MAX__ + 7;
+#define SVAL_NUM 48
+    default: abort ();
+    }
+};
+
+unsigned int
+uvals (int i)
+{
+  asm ("" : "=g" (i) : "0" (i));
+  switch (i)
+    {
+    case  0: return 0;
+    case  1: return 0x1cbf;
+    case  2: return 0x1cc0;
+    case  3: return 0x1fff;
+    case  4: return 0x2000;
+    case  5: return 0x20;
+    case  6: return 0x3cbf;
+    case  7: return 0x3cc0;
+    case  8: return 0x3f;
+    case  9: return (0xc000U << BITSH) - 1;
+    case 10: return (0xf000U << BITSH) - 1;
+    case 11: return (0x9000U << BITSH) - 1;
+    case 12: return (0xa031U << BITSH) - 1;
+    case 13: return (0xbfbfU << BITSH);
+    case 14: return (0xc000U << BITSH);
+    case 15: return (0xf000U << BITSH);
+    case 16: return (0x9000U << BITSH);
+    case 17: return (0xc000U << BITSH) + 1;
+    case 18: return 1;
+    case 19: return -1U;
+    case 20: return -15U;
+    case 21: return -15550U;
+    case 22: return -15552U;
+    case 23: return (0x7000 << BITSH) - 1;
+    case 24: return (0x7000 << BITSH);
+    case 25: return (1 << (BITSM1 - 2));
+    case 26: return (1 << (BITSM1 - 2)) - 1;
+    case 27: return 1U + __INT_MAX__;
+    case 28: return 2;
+    case 29: return 24;
+    case 30: return -32U;
+    case 31: return (3 << (BITSM1 - 2)) + 2;
+    case 32: return 5;
+    case 33: return -5U;
+    case 34: return -63U;
+    case 35: return -64U;
+    case 36: return -65U;
+    case 37: return 6U + __INT_MAX__;
+    case 38: return -8189U;
+    case 39: return -8191U;
+    case 40: return -8192U;
+    case 41: return -8193U;
+    case 42: return -8250U;
+    case 43: return -8255U;
+    case 44: return -8256U;
+    case 45: return -8257U;
+    case 46: return __INT_MAX__;
+    case 47: return __INT_MAX__ + 9U;
+#define UVAL_NUM 48
+    default: abort ();
+    }
+};
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < SVAL_NUM; i++)
+    {
+      f2 (svals (i));
+      f4 (svals (i));
+      f5 (svals (i));
+      f7 (svals (i));
+      f8 (svals (i));
+      f11 (svals (i));
+      f12 (svals (i));
+      f15 (svals (i));
+      f16 (svals (i));
+      f17 (svals (i));
+      f18 (svals (i));
+      f19 (svals (i));
+      f20 (svals (i));
+      f21 (svals (i));
+      f22 (svals (i));
+    }
+  for (i = 0; i < UVAL_NUM; i++)
+    {
+      f1 (uvals (i));
+      f3 (uvals (i));
+      f6 (uvals (i));
+      f9 (uvals (i));
+      f10 (uvals (i));
+      f13 (uvals (i));
+      f14 (uvals (i));
+      f23 (uvals (i));
+      f24 (uvals (i));
+    }
+  return 0;
+}
diff --git gcc/testsuite/gcc.dg/tree-ssa/vrp66.c gcc/testsuite/gcc.dg/tree-ssa/vrp66.c
index 19e0450..6a6ab34 100644
--- gcc/testsuite/gcc.dg/tree-ssa/vrp66.c
+++ gcc/testsuite/gcc.dg/tree-ssa/vrp66.c
@@ -1,5 +1,5 @@
 /* PR tree-optimization/52267 */
-/* { dg-do run } */
+/* { dg-do run { target { ! int16 } } } */
 /* { dg-options "-O2" } */
 
 extern void abort (void);
diff --git gcc/testsuite/gcc.target/avr/misspelled-handler-warning.c gcc/testsuite/gcc.target/avr/misspelled-handler-warning.c
new file mode 100644
index 0000000..51be22b
--- /dev/null
+++ gcc/testsuite/gcc.target/avr/misspelled-handler-warning.c
@@ -0,0 +1,13 @@
+/* Test warning emitted for functions with nmi attribute that do
+ * not start with __vector */
+/* { dg-do compile } */
+
+
+void __attribute__((interrupt)) interrupt_fun() /* { dg-warning "'interrupt_fun' appears to be a misspelled interrupt handler" } */
+{}
+
+void __attribute__((signal)) signal_fun() /* { dg-warning "'signal_fun' appears to be a misspelled signal handler" } */
+{}
+
+void __attribute__((nmi)) nmi_fun() /* { dg-warning "'nmi_fun' appears to be a misspelled nmi handler" } */
+{}
diff --git gcc/testsuite/gcc.target/avr/progmem-error-1.cpp gcc/testsuite/gcc.target/avr/progmem-error-1.cpp
index cf53cc8..934b93c 100644
--- gcc/testsuite/gcc.target/avr/progmem-error-1.cpp
+++ gcc/testsuite/gcc.target/avr/progmem-error-1.cpp
@@ -2,4 +2,4 @@
 
 #include "progmem.h"
 
-char str[] PROGMEM = "Hallo"; /* { dg-error "must be const" } */
+char str[] PROGMEM = "Hallo"; /* { dg-error "must be const" "" { target avr-*-* } 1 } */
diff --git gcc/testsuite/gcc.target/avr/torture/builtins-4-roundfx.c gcc/testsuite/gcc.target/avr/torture/builtins-4-roundfx.c
index 6ad0775..46e915a 100644
--- gcc/testsuite/gcc.target/avr/torture/builtins-4-roundfx.c
+++ gcc/testsuite/gcc.target/avr/torture/builtins-4-roundfx.c
@@ -72,11 +72,11 @@ DEFTEST1 (long long accum, llk)
 
 static void test2hr (void)
 {
-  TEST2 (hr, 1, 0x7f, 0x40);
-  TEST2 (hr, 2, 0x7f, 0b1100000);
-  TEST2 (hr, 3, 0x7f, 0b1110000);
-  TEST2 (hr, 4, 0x7f, 0b1111000);
-
+  TEST2 (hr, 1, 0x7f, 0x7f);
+  TEST2 (hr, 2, 0x70, 0x7f);
+  TEST2 (hr, 3, 0x78, 0x7f);
+  TEST2 (hr, 4, 0x7f, 0x7f);
+ 
   TEST2 (uhr, 1, 0x7f, 0x80);
   TEST2 (uhr, 2, 0x7f, 0x80);
   TEST2 (uhr, 3, 0x7f, 0x80);
@@ -85,10 +85,13 @@ static void test2hr (void)
 
 void test2k (void)
 {
-  TEST2 (k, 1, 0x7fffffff, 0x7fff8000 | 0b100000000000000);
-  TEST2 (k, 2, 0x7fffffff, 0x7fff8000 | 0b110000000000000);
-  TEST2 (k, 3, 0x7fffffff, 0x7fff8000 | 0b111000000000000);
-  TEST2 (k, 4, 0x7fffffff, 0x7fff8000 | 0b111100000000000);
+  TEST2 (k, 1, 0x7fffff00, 0x7fffffff);
+  TEST2 (k, 2, 0x7ffffff0, 0x7fffffff);
+  TEST2 (k, 2, 0x7ffff000, 0x7fffffff);
+  TEST2 (k, 3, 0x7ffff000, 0x7ffff000);
+  TEST2 (k, 3, 0x7ffff800, 0x7fffffff);
+  TEST2 (k, 3, 0x7ffff7ff, 0x7ffff000);
+  TEST2 (k, 4, 0x7ffff7ff, 0x7ffff800);
 
   TEST2 (uk, 1, 0x7fffffff, 1ul << 31);
   TEST2 (uk, 2, 0x7fffffff, 1ul << 31);
diff --git gcc/testsuite/gcc.target/avr/torture/pr57631.c gcc/testsuite/gcc.target/avr/torture/pr57631.c
new file mode 100644
index 0000000..ecefbfc
--- /dev/null
+++ gcc/testsuite/gcc.target/avr/torture/pr57631.c
@@ -0,0 +1,17 @@
+/* PR target/57631 */
+/* { dg-do compile } */
+
+void __attribute__((signal)) func1 (void) __asm ("__vector1");
+void func1  (void)
+{
+}
+
+void __attribute__((signal)) func2 (void)  __asm ("__vecto1");
+void func2  (void) /* { dg-warning "misspelled signal handler" } */
+{
+}
+
+void __attribute__((signal)) __vector_3 (void)  __asm ("__vecto1");
+void __vector_3 (void) /* { dg-warning "misspelled signal handler" } */
+{
+}
diff --git gcc/testsuite/gcc.target/avr/xmega_const_hi_io_address.c gcc/testsuite/gcc.target/avr/xmega_const_hi_io_address.c
new file mode 100644
index 0000000..3e83249
--- /dev/null
+++ gcc/testsuite/gcc.target/avr/xmega_const_hi_io_address.c
@@ -0,0 +1,15 @@
+/* Verify that loading the contents of a constant int address in I/O range
+   uses two IN instructions with the correct SFR offset for XMEGA*/
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "Only for XMEGAs" { "avr-*-*" } { "*" } { "-mmcu=atxmega*" } } */
+
+void func()
+{
+    volatile int val = *((int *)0x20);
+    *((int *)0x20) = 0xCAFE;
+
+}
+
+/* { dg-final { scan-assembler "\tin r\\d+,0x20\n\tin r\\d+,0x20\\+1" } } */
+/* { dg-final { scan-assembler "\tout 0x20,r\\d+\n\tout 0x20\\+1,r\\d+" } } */
diff --git gcc/testsuite/gcc.target/avr/xmega_const_qi_io_address.c gcc/testsuite/gcc.target/avr/xmega_const_qi_io_address.c
new file mode 100644
index 0000000..09352fa
--- /dev/null
+++ gcc/testsuite/gcc.target/avr/xmega_const_qi_io_address.c
@@ -0,0 +1,14 @@
+/* Verify that loading the contents of a constant address in I/O range
+   uses the IN instruction with the correct SFR offset for XMEGA*/
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "Only for XMEGAs" { "avr-*-*" } { "*" } { "-mmcu=atxmega*" } } */
+
+void func()
+{
+    volatile char val = *((char *)0x20);
+    *((char *)0x20) = 42;
+}
+
+/* { dg-final { scan-assembler "\tin r\\d+,0x20" } } */
+/* { dg-final { scan-assembler "\tout 0x20,r\\d+" } } */
diff --git gcc/testsuite/gcc.target/avr/xmega_interrupt_no_cli.c gcc/testsuite/gcc.target/avr/xmega_interrupt_no_cli.c
new file mode 100644
index 0000000..c2c3db1
--- /dev/null
+++ gcc/testsuite/gcc.target/avr/xmega_interrupt_no_cli.c
@@ -0,0 +1,14 @@
+/* Verify that XMEGA interrupts don't have a cli or sei
+   and that SPL is written before SPH*/
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "Only for XMEGAs" { "avr-*-*" } { "*" } { "-mmcu=atxmega*" } } */
+
+void __attribute__((interrupt)) __vector_1()
+{
+    volatile int w = 19, x = 20, y = 30, z = 42;
+}
+
+/* { dg-final { scan-assembler-not "\tcli" } } */
+/* { dg-final { scan-assembler "\tout __SP_L__,r\\d+\n\tout __SP_H__,r\\d+" } } */
+
diff --git gcc/testsuite/gcc.target/avr/xmega_sfr_offsets.c gcc/testsuite/gcc.target/avr/xmega_sfr_offsets.c
new file mode 100644
index 0000000..68fd8ae
--- /dev/null
+++ gcc/testsuite/gcc.target/avr/xmega_sfr_offsets.c
@@ -0,0 +1,18 @@
+/* Verify that SFR offsets for XMEGAs do not have the 0x20 offset 
+   and that they are saved on entry, restored on exit for an interrupt
+   function  */
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-skip-if "Only for XMEGAs" { "avr-*-*" } { "*" } { "-mmcu=atxmega128a1" } } */
+
+void __attribute__((interrupt)) __vector_1()
+{
+}
+
+/* { dg-final { scan-assembler "__SREG__ = 0x3f" } } */
+/* { dg-final { scan-assembler "__RAMPD__ = 0x38" } } */
+/* { dg-final { scan-assembler "\tin r0,__SREG__" } } */
+/* { dg-final { scan-assembler "\tin r0,__RAMPD__" } } */
+/* { dg-final { scan-assembler "\tpop r0\n\tout __SREG__,r0" } } */
+/* { dg-final { scan-assembler "\tpop r0\n\tout __RAMPD__,r0" } } */
+
diff --git gcc/testsuite/lib/target-supports.exp gcc/testsuite/lib/target-supports.exp
index a146f17..1ee360a 100644
--- gcc/testsuite/lib/target-supports.exp
+++ gcc/testsuite/lib/target-supports.exp
@@ -1678,6 +1678,15 @@ proc check_effective_target_x32 { } {
     }]
 }
 
+# Return 1 if we're generating 32-bit integers using default
+# options, 0 otherwise.
+
+proc check_effective_target_int32 { } {
+    return [check_no_compiler_messages int32 object {
+	int dummy[sizeof (int) == 4 ? 1 : -1];
+    }]
+}
+
 # Return 1 if we're generating 32-bit or larger integers using default
 # options, 0 otherwise.
 
diff --git libgcc/ChangeLog.AVR libgcc/ChangeLog.AVR
new file mode 100644
index 0000000..8a68aa1
--- /dev/null
+++ libgcc/ChangeLog.AVR
@@ -0,0 +1,8 @@
+2013-08-23  Joern Rennecke <joern.rennecke@embecosm.com>
+      Merged from fsf-gcc/trunk:
+      2013-07-19  Georg-Johann Lay  <avr@gjlay.de>
+	PR target/57516
+	* config/avr/lib1funcs-fixed.S (__roundqq3, __rounduqq3)
+	(__round_s2_const, __round_u2_const)
+	(__round_s4_const, __round_u4_const, __round_x8):
+	Saturate result if addition result cannot be represented.
diff --git libgcc/ChangeLog.Atmel libgcc/ChangeLog.Atmel
new file mode 100644
index 0000000..2c7983f
--- /dev/null
+++ libgcc/ChangeLog.Atmel
@@ -0,0 +1,29 @@
+2013-01-08  Vidya Praveen <vidya.praveen@atmel.com>
+	    Praveen Kumar Kaushik <Praveen_Kumar.Kaushik@atmel.com>
+	    Senthil Kumar Selvaraj <Senthil_Kumar.Selvaraj@atmel.com>
+	    Pitchumani Sivanupandi <Pitchumani.S@atmel.com>
+
+	Updated library functions for AVRTINY arch.
+	* config/avr/lib1funcs.S: Updated zero/tmp regs for AVRTINY.
+	Replaced occurrences of r0/r1 with tmp/zero reg macros.
+	Added wsubi/ wadi macros that expands conditionally as sbiw/ adiw
+	or AVRTINY equivalent. Replaced occurrences of sbiw/adiw with
+	wsubi/wadi macors.
+	(__mulsi3_helper): Update stack, preserve callee saved regs and
+	argument from stack. Restore callee save registers.
+	(__mulpsi3): Likewise.
+	(__muldi3, __udivmodsi4, __divmodsi4, __negsi2, __umoddi3, __udivmod64,
+	__moddi3, __adddi3, __adddi3_s8, __subdi3, __cmpdi2, __cmpdi2_s8,
+	__negdi2, __prologue_saves__, __epilogue_restores__): Excluded for 
+	AVRTINY.
+	(__tablejump__): Added lpm equivalent instructions for AVRTINY.
+	(__do_copy_data): Added new definition for AVRTINY.
+	(__do_clear_bss): Replace r17 by r18 to preserve zero reg for AVRTINY.
+	(__tablejump_elpm__, __load_3, __load_4, __xload_1, __xload_2, __xload_3,
+	__xload_4, __movmemx_qi, __movmemx_hi): Excluded for AVRTINY.
+	* config/avr/lib1funcs-fixed.S: Replaced occurrences of r0/r1 with
+	tmp/zero reg macros. Replaced occurrences of sbiw/adiw with wsubi/wadi
+	macors.
+    * config/avr/t-avr (LIB1ASMFUNCS): Remove unsupported functions for
+	AVRTINY.
+
diff --git libgcc/config/avr/lib1funcs-fixed.S libgcc/config/avr/lib1funcs-fixed.S
index d80389c..c41ef11 100644
--- libgcc/config/avr/lib1funcs-fixed.S
+++ libgcc/config/avr/lib1funcs-fixed.S
@@ -31,8 +31,27 @@
 ;; Fixed point library routines for AVR
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
+#if defined __AVR_TINY__
+#define __zero_reg__ r17
+#define __tmp_reg__ r16
+#else                                                                                                                                              
+#define __zero_reg__ r1
+#define __tmp_reg__ r0
+#endif
+
+.macro waddi r_arg1, i_arg2
+#if defined (__AVR_TINY__)
+    subi \r_arg1,   lo8(-\i_arg2)
+    sbci \r_arg1+1, hi8(-\i_arg2)
+#else
+    adiw \r_arg1, \i_arg2
+#endif
+.endm
+
 .section .text.libgcc.fixed, "ax", @progbits
 
+#ifndef __AVR_TINY__
+
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Conversions to float
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -1464,12 +1483,13 @@ DEFUN  __roundqq3
     ;; Add-Saturate 2^{-RP-1}
     add     A0, C0
     brvc 0f
-    ldi     A0, 0x7f
+    ldi     C0, 0x7f
+    rjmp 9f
 0:  ;; Mask out bits beyond RP
     lsl     C0
     neg     C0
     and     C0, A0
-    mov     C1, __tmp_reg__
+9:  mov     C1, __tmp_reg__
     ret
 ENDF  __roundqq3
 #endif /* L_roundqq3 */
@@ -1488,12 +1508,13 @@ DEFUN  __rounduqq3
     ;; Add-Saturate 2^{-RP-1}
     add     A0, C0
     brcc 0f
-    ldi     A0, 0xff
+    ldi     C0, 0xff
+    rjmp 9f
 0:  ;; Mask out bits beyond RP
     lsl     C0
     neg     C0
     and     C0, A0
-    mov     C1, __tmp_reg__
+9:  mov     C1, __tmp_reg__
     ret
 ENDF  __rounduqq3
 #endif /* L_rounduqq3 */
@@ -1565,16 +1586,17 @@ ENDF  __rounduha3
 
 DEFUN  __round_s2_const
     brvc 2f
-    ldi     A1, 0x7f
+    ldi     C1, 0x7f
     rjmp 1f
     ;; FALLTHRU (Barrier)
 ENDF  __round_s2_const
 
 DEFUN __round_u2_const
     brcc 2f
-    ldi     A1, 0xff
+    ldi     C1, 0xff
 1:
-    ldi     A0, 0xff
+    ldi     C0, 0xff
+    rjmp 9f
 2:
     ;; Saturation is performed now.
     ;; Currently, we have C[] = 2^{-RP-1}
@@ -1586,7 +1608,7 @@ DEFUN __round_u2_const
     ;; Clear the bits beyond the rounding point.
     and     C0, A0
     and     C1, A1
-    ret
+9:  ret
 ENDF  __round_u2_const
 
 #endif /* L_round_2_const */
@@ -1681,18 +1703,19 @@ ENDF  __roundusa3
 
 DEFUN  __round_s4_const
     brvc 2f
-    ldi     A3, 0x7f
+    ldi     C3, 0x7f
     rjmp 1f
     ;; FALLTHRU (Barrier)
 ENDF  __round_s4_const
 
 DEFUN __round_u4_const
     brcc 2f
-    ldi     A3, 0xff
+    ldi     C3, 0xff
 1:
-    ldi     A2, 0xff
-    ldi     A1, 0xff
-    ldi     A0, 0xff
+    ldi     C2, 0xff
+    ldi     C1, 0xff
+    ldi     C0, 0xff
+    rjmp 9f
 2:
     ;; Saturation is performed now.
     ;; Currently, we have C[] = 2^{-RP-1}
@@ -1707,7 +1730,7 @@ DEFUN __round_u4_const
     and     C1, A1
     and     C2, A2
     and     C3, A3
-    ret
+9:  ret
 ENDF  __round_u4_const
 
 #endif /* L_round_4_const */
@@ -1847,12 +1870,13 @@ DEFUN __round_x8
 1:  ;; Unsigned
     brcc    3f
     ;; Unsigned overflow: A[] = 0xff...
-2:  ldi     A7, 0xff
-    ldi     A6, 0xff
-    wmov    A0, A6
-    wmov    A2, A6
-    wmov    A4, A6
-    bld     A7, 7
+2:  ldi     C7, 0xff
+    ldi     C6, 0xff
+    wmov    C0, C6
+    wmov    C2, C6
+    wmov    C4, C6
+    bld     C7, 7
+    rjmp 9f
 3:
     ;;  C[] = -C[] - C[]
     push    A0
@@ -1869,7 +1893,7 @@ DEFUN __round_x8
     and     C5, A5
     and     C6, A6
     and     C7, A7
-    ;; Epilogue
+9:  ;; Epilogue
     pop r29
     pop r28
     pop r17
@@ -1908,3 +1932,5 @@ DEFUN __ret
     ret
 ENDF  __ret
 #endif /* L_ret */
+
+#endif /* if not __AVR_TINY__ */
diff --git libgcc/config/avr/lib1funcs.S libgcc/config/avr/lib1funcs.S
index f3c6e0c..6544b28 100644
--- libgcc/config/avr/lib1funcs.S
+++ libgcc/config/avr/lib1funcs.S
@@ -21,8 +21,13 @@ a copy of the GCC Runtime Library Exception along with this program;
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
+#if defined (__AVR_TINY__)
+#define __zero_reg__ r17
+#define __tmp_reg__ r16
+#else
 #define __zero_reg__ r1
 #define __tmp_reg__ r0
+#endif
 #define __SREG__ 0x3f
 #if defined (__AVR_HAVE_SPH__)
 #define __SP_H__ 0x3e
@@ -114,6 +119,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 ;; Support function entry and exit for convenience
 
+.macro wsubi r_arg1, i_arg2
+#if defined (__AVR_TINY__)
+    subi \r_arg1,   lo8(\i_arg2)
+    sbci \r_arg1+1, hi8(\i_arg2)
+#else
+    sbiw \r_arg1, \i_arg2
+#endif
+.endm
+
 .macro DEFUN name
 .global \name
 .func \name
@@ -134,7 +148,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 .endm
 
 ;; Skip next instruction, typically a jump target
+#if defined(__AVR_TINY__)
 #define skip cpse 0,0
+#else
+#define skip cpse 16,16
+#endif
 
 ;; Negate a 2-byte value held in consecutive registers
 .macro NEG2  reg
@@ -207,16 +225,16 @@ ENDF __mulqi3
     Multiplication  16 x 16  without MUL
 *******************************************************/
 
-#define A0  r22
-#define A1  r23
-#define B0  r24
-#define BB0 r20
-#define B1  r25
+#define A0  22
+#define A1  23
+#define B0  24
+#define BB0 20
+#define B1  25
 ;; Output overlaps input, thus expand result in CC0/1
-#define C0  r24
-#define C1  r25
+#define C0  24
+#define C1  25
 #define CC0  __tmp_reg__
-#define CC1  R21
+#define CC1  21
 
 #if defined (L_umulqihi3)
 ;;; R25:R24 = (unsigned int) R22 * (unsigned int) R24
@@ -282,7 +300,7 @@ DEFUN __mulhi3
     rol     B1
 3:
     ;; If B == 0 we are ready
-    sbiw    B0, 0
+    wsubi   B0, 0
     breq 9f
 
     ;; Carry = n-th bit of A
@@ -390,6 +408,18 @@ ENDF __mulhisi3
 
 #if defined (L_mulsi3)
 DEFUN __mulsi3
+#if defined (__AVR_TINY__)
+    in     r26, __SP_L__ ; safe to use X, as it is CC0/CC1
+    in     r27, __SP_H__
+    subi   r26, lo8(-3)   ; Add 3 to point past return address
+    sbci   r27, hi8(-3)
+    push   B0    ; save callee saved regs
+    push   B1
+    ld     B0, X+   ; load from caller stack
+    ld     B1, X+
+    ld     B2, X+
+    ld     B3, X
+#endif
     ;; Clear result
     clr     CC2
     clr     CC3
@@ -415,12 +445,17 @@ DEFUN __mulsi3_helper
     ;; Only continue if  A != 0
     sbci    A1, 0
     brne 2b
-    sbiw    A2, 0
+    wsubi   A2, 0
     brne 2b
 
     ;; All bits of A are consumed:  Copy result to return register C
     wmov    C0, CC0
     wmov    C2, CC2
+#if defined (__AVR_TINY__)
+    pop     B1      ; restore callee saved regs
+    pop     B0 
+#endif  /* defined (__AVR_TINY__) */
+
     ret
 ENDF __mulsi3_helper
 #endif /* L_mulsi3 */
@@ -670,9 +705,12 @@ ENDF __mulpsi3
 #undef C0
 
 #else /* !HAVE_MUL */
-
 ;; C[0..2]: Expand Result
+#if defined (__AVR_TINY__)
+#define C0  16
+#else
 #define C0  0
+#endif /* defined (__AVR_TINY__) */
 #define C1  C0+1
 #define C2  21
 
@@ -680,6 +718,17 @@ ENDF __mulpsi3
 ;; Clobbers: __tmp_reg__, R18, R19, R20, R21
 
 DEFUN __mulpsi3
+#if defined (__AVR_TINY__)
+    in r26,__SP_L__ 
+    in r27,__SP_H__
+    subi r26, lo8(-3)   ; Add 3 to point past return address
+    sbci r27, hi8(-3)
+    push B0    ; save callee saved regs
+    push B1
+    ld B0,X+   ; load from caller stack 
+    ld B1,X+
+    ld B2,X+
+#endif /* defined (__AVR_TINY__) */
 
     ;; C[] = 0
     clr     __tmp_reg__
@@ -706,6 +755,10 @@ DEFUN __mulpsi3
     mov     A2, C2
 
     clr     __zero_reg__
+#if defined (__AVR_TINY__)
+    pop B1
+    pop B0
+#endif /* (__AVR_TINY__) */
     ret
 ENDF __mulpsi3
 
@@ -797,8 +850,8 @@ ENDF __mulsqipsi3
 #define B6  B0+6
 #define B7  B0+7
 
+#ifndef __AVR_TINY__
 #if defined (__AVR_HAVE_MUL__)
-
 ;; Define C[] for convenience
 ;; Notice that parts of C[] overlap A[] respective B[]
 #define C0  16
@@ -1000,6 +1053,7 @@ ENDF __muldi3
 
 #endif /* L_muldi3 */
 #endif /* HAVE_MUL */
+#endif /* if not __AVR_TINY__ */
 
 #undef B7
 #undef B6
@@ -1157,7 +1211,7 @@ ENDF __mulsidi3
 /**********************************************************
     Widening Multiplication 64 = 32 x 32  without  MUL
 **********************************************************/
-
+#ifndef __AVR_TINY__ /* if not __AVR_TINY__ */
 #if defined (L_mulsidi3) && !defined (__AVR_HAVE_MUL__)
 #define A0 18
 #define A1 A0+1
@@ -1253,7 +1307,7 @@ ENDF __umulsidi3
 #undef BB3
 #undef Mask
 #endif /* L_mulsidi3 && !HAVE_MUL */
-
+#endif /* if not __AVR_TINY__ */
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 	
 
@@ -1425,7 +1479,7 @@ ENDF __divmodhi4
 #define r_cnt   21
 
 #if defined (L_udivmodpsi4)
-;; R24:R22 = R24:R22  udiv  R20:R18
+;; R24:R22 = R24:R24  udiv  R20:R18
 ;; R20:R18 = R24:R22  umod  R20:R18
 ;; Clobbers: R21, R25, R26
 
@@ -1660,6 +1714,10 @@ ENDF __negsi2
 #undef r_arg2L
 #undef r_cnt
 
+/* *di routines use registers below R19 and won't work with tiny arch
+   right now. */
+
+#if !defined (__AVR_TINY__)
 /*******************************************************
        Division 64 / 64
        Modulo   64 % 64
@@ -2075,12 +2133,15 @@ ENDF __negdi2
 #undef A1
 #undef A0
 
+#endif /* !defined (__AVR_TINY__) */
+
 
 .section .text.libgcc.prologue, "ax", @progbits
 
 /**********************************
  * This is a prologue subroutine
  **********************************/
+#if !defined (__AVR_TINY__)
 #if defined (L_prologue)
 
 ;; This function does not clobber T-flag; 64-bit division relies on it
@@ -2186,6 +2247,7 @@ DEFUN __epilogue_restores__
 	ret
 ENDF __epilogue_restores__
 #endif /* defined (L_epilogue) */
+#endif /* !defined (__AVR_TINY__) */
 
 #ifdef L_exit
 	.section .fini9,"ax",@progbits
@@ -2230,8 +2292,13 @@ DEFUN __tablejump__
 #else
 	ijmp
 #endif
-
-#else /* !HAVE_LPMX */
+#elif defined (__AVR_TINY__)
+	wsubi 30, -(__AVR_TINY_PM_BASE_ADDRESS__) ; Add PM offset to Z
+	ld __tmp_reg__, Z+
+	ld r31, Z   ; Use ld instead of lpm to load Z
+	mov r30, __tmp_reg__    
+	ijmp
+#else /* !HAVE_LPMX && !AVR_TINY */
 	lpm
 	adiw r30, 1
 	push r0
@@ -2246,6 +2313,26 @@ DEFUN __tablejump__
 ENDF __tablejump__
 #endif /* defined (L_tablejump) */
 
+#if defined(__AVR_TINY__)
+#ifdef L_copy_data
+        .section .init4,"ax",@progbits
+        .global __do_copy_data
+__do_copy_data:
+        ldi     r18, hi8(__data_end)
+        ldi     r26, lo8(__data_start)
+        ldi     r27, hi8(__data_start)
+        ldi     r30, lo8(__data_load_start + __AVR_TINY_PM_BASE_ADDRESS__)
+        ldi     r31, hi8(__data_load_start + __AVR_TINY_PM_BASE_ADDRESS__)
+        rjmp    .L__do_copy_data_start
+.L__do_copy_data_loop:
+        ld      r19, z+
+        st      X+, r19
+.L__do_copy_data_start:
+        cpi     r26, lo8(__data_end)
+        cpc     r27, r18
+        brne    .L__do_copy_data_loop
+#endif
+#else
 #ifdef L_copy_data
 	.section .init4,"ax",@progbits
 DEFUN __do_copy_data
@@ -2311,13 +2398,14 @@ DEFUN __do_copy_data
 #endif /* ELPM && RAMPD */
 ENDF __do_copy_data
 #endif /* L_copy_data */
+#endif /* !defined (__AVR_TINY__) */
 
 /* __do_clear_bss is only necessary if there is anything in .bss section.  */
 
 #ifdef L_clear_bss
 	.section .init4,"ax",@progbits
 DEFUN __do_clear_bss
-	ldi	r17, hi8(__bss_end)
+	ldi	r18, hi8(__bss_end)
 	ldi	r26, lo8(__bss_start)
 	ldi	r27, hi8(__bss_start)
 	rjmp	.do_clear_bss_start
@@ -2325,7 +2413,7 @@ DEFUN __do_clear_bss
 	st	X+, __zero_reg__
 .do_clear_bss_start:
 	cpi	r26, lo8(__bss_end)
-	cpc	r27, r17
+	cpc	r27, r18
 	brne	.do_clear_bss_loop
 ENDF __do_clear_bss
 #endif /* L_clear_bss */
@@ -2336,7 +2424,21 @@ ENDF __do_clear_bss
 #ifdef L_ctors
 	.section .init6,"ax",@progbits
 DEFUN __do_global_ctors
-#if defined(__AVR_HAVE_ELPM__)
+#if defined(__AVR_TINY__)
+        ldi     r18, hi8(__ctors_start)
+        ldi     r28, lo8(__ctors_end)
+        ldi     r29, hi8(__ctors_end)
+        rjmp    .L__do_global_ctors_start
+.L__do_global_ctors_loop:
+        wsubi   28, 2
+        mov_h   r31, r29
+        mov_l   r30, r28
+        XCALL   __tablejump__
+.L__do_global_ctors_start:
+        cpi     r28, lo8(__ctors_start)
+        cpc     r29, r18
+        brne    .L__do_global_ctors_loop
+#elif defined(__AVR_HAVE_ELPM__)
 	ldi	r17, hi8(__ctors_start)
 	ldi	r28, lo8(__ctors_end)
 	ldi	r29, hi8(__ctors_end)
@@ -2376,7 +2478,21 @@ ENDF __do_global_ctors
 #ifdef L_dtors
 	.section .fini6,"ax",@progbits
 DEFUN __do_global_dtors
-#if defined(__AVR_HAVE_ELPM__)
+#if defined(__AVR_TINY__)
+        ldi     r18, hi8(__dtors_end)
+        ldi     r28, lo8(__dtors_start)
+        ldi     r29, hi8(__dtors_start)
+        rjmp    .L__do_global_dtors_start
+.L__do_global_dtors_loop:
+        mov_h   r31, r29
+        mov_l   r30, r28
+        XCALL   __tablejump__
+        wsubi   28, -2
+.L__do_global_dtors_start:
+        cpi     r28, lo8(__dtors_end)
+        cpc     r29, r18
+        brne    .L__do_global_dtors_loop
+#elif defined(__AVR_HAVE_ELPM__)
 	ldi	r17, hi8(__dtors_end)
 	ldi	r28, lo8(__dtors_start)
 	ldi	r29, hi8(__dtors_start)
@@ -2404,7 +2520,11 @@ DEFUN __do_global_dtors
 	mov_h	r31, r29
 	mov_l	r30, r28
 	XCALL	__tablejump__
-	adiw	r28, 2
+#if defined (__AVR_TINY__)
+	wsubi	28, -2
+#else
+	adiw    r28, 2
+#endif
 .L__do_global_dtors_start:
 	cpi	r28, lo8(__dtors_end)
 	cpc	r29, r17
@@ -2415,6 +2535,7 @@ ENDF __do_global_dtors
 
 .section .text.libgcc, "ax", @progbits
 
+#if !defined (__AVR_TINY__)
 #ifdef L_tablejump_elpm
 DEFUN __tablejump_elpm__
 #if defined (__AVR_HAVE_ELPMX__)
@@ -2445,7 +2566,9 @@ DEFUN __tablejump_elpm__
 #endif
 ENDF __tablejump_elpm__
 #endif /* defined (L_tablejump_elpm) */
+#endif /* !defined (__AVR_TINY__) */
 
+#if !defined (__AVR_TINY__)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Loading n bytes from Flash; n = 3,4
 ;; R22... = Flash[Z]
@@ -2491,7 +2614,9 @@ ENDF __load_4
 #endif /* L_load_4 */
 
 #endif /* L_load_3 || L_load_3 */
+#endif /* !defined (__AVR_TINY__) */
 
+#if !defined (__AVR_TINY__)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Loading n bytes from Flash or RAM;  n = 1,2,3,4
 ;; R22... = Flash[R21:Z] or RAM[Z] depending on R21.7
@@ -2617,7 +2742,9 @@ ENDF __xload_4
 #endif /* L_xload_4 */
 
 #endif /* L_xload_{1|2|3|4} */
+#endif /* if !defined (__AVR_TINY__) */
 
+#if !defined (__AVR_TINY__)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; memcopy from Address Space __pgmx to RAM
 ;; R23:Z = Source Address
@@ -2689,6 +2816,7 @@ ENDF __movmemx_hi
 #undef LOOP
 
 #endif /* L_movmemx */
+#endif /* !defined (__AVR_TINY__) */ 
 
 
 .section .text.libgcc.builtins, "ax", @progbits
diff --git libgcc/config/avr/t-avr libgcc/config/avr/t-avr
index 4613047..66cb40a 100644
--- libgcc/config/avr/t-avr
+++ libgcc/config/avr/t-avr
@@ -3,12 +3,7 @@ LIB1ASMFUNCS = \
 	_mulqi3 \
 	_mulhi3 \
 	_mulqihi3 _umulqihi3 \
-	_mulpsi3 _mulsqipsi3 \
-	_mulhisi3 \
-	_umulhisi3 \
-	_usmulhisi3 \
-	_muluhisi3 \
-	_mulshisi3 \
+	_mulpsi3 \
 	_mulsi3 \
 	_udivmodqi4 \
 	_divmodqi4 \
@@ -17,20 +12,10 @@ LIB1ASMFUNCS = \
 	_divmodpsi4 _udivmodpsi4 \
 	_udivmodsi4 \
 	_divmodsi4 \
-	_divdi3 _udivdi3 \
-	_muldi3 _muldi3_6 \
-	_mulsidi3 _umulsidi3 \
-	_udivmod64 \
-	_negsi2 _negdi2 \
-	_prologue \
-	_epilogue \
+	_negsi2 \
 	_exit \
 	_cleanup \
 	_tablejump \
-	_tablejump_elpm \
-	_load_3 _load_4 \
-	_xload_1 _xload_2 _xload_3 _xload_4 \
-	_movmemx \
 	_copy_data \
 	_clear_bss \
 	_ctors \
@@ -40,24 +25,56 @@ LIB1ASMFUNCS = \
 	_loop_ffsqi2 \
 	_ctzsi2 \
 	_ctzhi2 \
-	_clzdi2 \
 	_clzsi2 \
 	_clzhi2 \
-	_paritydi2 \
 	_paritysi2 \
 	_parityhi2 \
 	_popcounthi2 \
 	_popcountsi2 \
-	_popcountdi2 \
 	_popcountqi2 \
 	_bswapsi2 \
+	_fmul _fmuls _fmulsu
+
+# The below functions either use registers that are not present
+# in tiny core, or use a different register conventions (don't save
+# callee saved regs, for example)
+# _mulhisi3 and variations - clobber R18, R19
+# All *di funcs - use regs < R16 or expect args in regs < R20
+# _prologue and _epilogue save registers < R16
+# _tablejump/_tablejump_elmp - expect lpm and elpm support
+# _load ad _xload variations - expect lpm and elpm support
+# _movmemx - expects elpm/lpm
+
+ifneq ($(MULTIFLAGS),-mmcu=avrtiny)
+LIB1ASMFUNCS += \
+    _mulsqipsi3 \
+	_mulhisi3 \
+	_umulhisi3 \
+	_usmulhisi3 \
+	_muluhisi3 \
+	_mulshisi3 \
+    _muldi3 _muldi3_6 \
+    _mulsidi3 _umulsidi3 \
+	_divdi3 _udivdi3 \
+	_udivmod64 \
+	_negdi2 \
+	_prologue \
+	_epilogue \
+	_tablejump_elpm \
+	_load_3 _load_4 \
+	_xload_1 _xload_2 _xload_3 _xload_4 \
+	_movmemx \
+	_clzdi2 \
+	_paritydi2 \
+	_popcountdi2 \
 	_bswapdi2 \
 	_ashldi3 _ashrdi3 _lshrdi3 _rotldi3 \
 	_adddi3 _adddi3_s8 _subdi3 \
-	_cmpdi2 _cmpdi2_s8 \
-	_fmul _fmuls _fmulsu
+	_cmpdi2 _cmpdi2_s8
+endif
 
 # Fixed point routines in avr/lib1funcs-fixed.S
+ifneq ($(MULTIFLAGS),-mmcu=avrtiny)
 LIB1ASMFUNCS += \
 	_fractqqsf _fractuqqsf \
 	_fracthqsf _fractuhqsf _fracthasf _fractuhasf \
@@ -88,8 +105,8 @@ LIB1ASMFUNCS += \
 	_round_x8 \
 	_rounddq3 _roundudq3 \
 	_roundda3 _rounduda3 \
-	_roundta3 _rounduta3 \
-
+	_roundta3 _rounduta3
+endif
 
 LIB2FUNCS_EXCLUDE = \
 	_moddi3 _umoddi3 \
